<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SemiCircular SemiSimulator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #111;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    #newDotBtn {
      position: fixed;
      top: 16px;
      right: 16px;
      padding: 8px 14px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.45);
      display: none;
    }

    #newDotBtn:hover {
      background: rgba(30,64,175,0.95);
      border-color: rgba(191,219,254,0.9);
    }

    #newDotBtn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    #newDotBtn:disabled:hover {
      background: rgba(15,23,42,0.9);
      border-color: rgba(148,163,184,0.7);
    }

    #resetBtn {
      position: fixed;
      left: 30px;
      bottom: 6px;
      padding: 6px 12px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 13px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.45);
    }

    #resetBtn:hover {
      background: rgba(30,64,175,0.95);
      border-color: rgba(191,219,254,0.9);
    }

    #selectorPanel {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 14px;
      align-items: center;
      padding: 10px 12px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(148,163,184,0.7);
      border-radius: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      z-index: 20;
      user-select: none;
    }

    #selectorPanel .group {
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }

    #selectorPanel .label {
      font-size: 12px;
      color: rgba(226,232,240,0.9);
      letter-spacing: 0.2px;
      margin-right: 2px;
    }

    #selectorPanel .segbtn {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.55);
      background: rgba(2,6,23,0.35);
      color: rgba(226,232,240,0.92);
      cursor: pointer;
      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease;
    }

    #selectorPanel .segbtn:hover {
      transform: translateY(-1px);
      background: rgba(30,64,175,0.35);
      border-color: rgba(191,219,254,0.85);
    }

    #selectorPanel .segbtn.active {
      background: rgba(30,64,175,0.85);
      border-color: rgba(191,219,254,0.95);
      color: #ffffff;
    }

    /* Canal buttons: make selection unmistakable */
    #selectorPanel [data-canal].active {
      background: rgba(34,197,94,0.88);
      border-color: rgba(187,247,208,0.98);
      color: #ffffff;
    }

  </style>
</head>
<body>
  <canvas id="earCanvas"></canvas>
  <button id="newDotBtn">Add Otolith</button>
  <button id="resetBtn">Reset Orientation</button>

  <div id="selectorPanel" aria-label="Canal and side selector">
    <div class="group" aria-label="Side selector">
      <span class="label">Side</span>
      <button class="segbtn" data-side="R" type="button">Right</button>
      <button class="segbtn" data-side="L" type="button">Left</button>
    </div>
    <div class="group" aria-label="Canal selector">
      <span class="label">Canal</span>
      <button class="segbtn" data-canal="posterior" type="button">Posterior</button>
      <button class="segbtn" data-canal="superior" type="button">Superior</button>
      <button class="segbtn" data-canal="lateral" type="button">Lateral</button>
    </div>
  </div>


  <script>
    const canvas = document.getElementById('earCanvas');
    const ctx = canvas.getContext('2d');
    const newDotBtn = document.getElementById('newDotBtn');
    const resetBtn = document.getElementById('resetBtn');
    const selectorPanel = document.getElementById('selectorPanel');
    const sideButtons = Array.from(document.querySelectorAll('#selectorPanel [data-side]'));
    const canalButtons = Array.from(document.querySelectorAll('#selectorPanel [data-canal]'));

    // Selected ear side + canal
    let selectedSide = 'R';       // 'R' | 'L'
    let selectedCanal = 'posterior'; // 'posterior' | 'superior' | 'lateral'

    function setActiveButtons() {
      for (const b of sideButtons) b.classList.toggle('active', b.dataset.side === selectedSide);
      for (const b of canalButtons) b.classList.toggle('active', b.dataset.canal === selectedCanal);
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ---- Geometry helpers ----
    function generateCanal(type) {
      const pts = [];
      const r = 1.4;
      const segments = 260;
      const full = Math.PI * 2;
      let center, t0, labelAngle, labelPoint;

      if (type === 'lateral') {
        center = { x: 0, y: 0, z: r };
        t0 = -Math.PI / 2;
        labelAngle = t0 + Math.PI / 2;
        for (let i = 0; i <= segments; i++) {
          const t = t0 + (i / segments) * full;
          const x = center.x + r * Math.cos(t);
          const y = 0;
          const z = center.z + r * Math.sin(t);
          pts.push({ x, y, z });
        }
        labelPoint = {
          x: center.x + r * Math.cos(labelAngle),
          y: 0,
          z: center.z + r * Math.sin(labelAngle)
        };
      } else if (type === 'superior') {
        center = { x: 0, y: r, z: 0 };
        t0 = Math.PI;
        labelAngle = t0 - Math.PI / 2;
        for (let i = 0; i <= segments; i++) {
          const t = t0 + (i / segments) * full;
          const x = 0;
          const y = center.y + r * Math.cos(t);
          const z = center.z + r * Math.sin(t);
          pts.push({ x, y, z });
        }
        labelPoint = {
          x: 0,
          y: center.y + r * Math.cos(labelAngle),
          z: center.z + r * Math.sin(labelAngle)
        };
      } else if (type === 'posterior') {
        center = { x: r, y: 0, z: 0 };
        t0 = Math.PI;
        labelAngle = t0 + Math.PI / 2;
        for (let i = 0; i <= segments; i++) {
          const t = t0 + (i / segments) * full;
          const x = center.x + r * Math.cos(t);
          const y = center.y + r * Math.sin(t);
          const z = 0;
          pts.push({ x, y, z });
        }
        labelPoint = {
          x: center.x + r * Math.cos(labelAngle),
          y: center.y + r * Math.sin(labelAngle),
          z: 0
        };
      }

      return { points: pts, labelPoint };
    }
    const lateral = generateCanal('lateral');
    const superior = generateCanal('superior');
    const posterior = generateCanal('posterior');

    const baseCanalsByType = {
      lateral: {
        key: 'lateral',
        name: 'L',
        color: '#7dd3fc',
        points: lateral.points,
        labelPoint: lateral.labelPoint
      },
      superior: {
        key: 'superior',
        name: 'S',
        color: '#38bdf8',
        points: superior.points,
        labelPoint: superior.labelPoint
      },
      posterior: {
        key: 'posterior',
        name: 'P',
        color: '#0ea5e9',
        points: posterior.points,
        labelPoint: posterior.labelPoint
      }
    };

    function mirrorCanal(canal) {
      return {
        ...canal,
        points: canal.points.map(p => ({ x: -p.x, y: p.y, z: p.z })),
        labelPoint: { x: -canal.labelPoint.x, y: canal.labelPoint.y, z: canal.labelPoint.z }
      };
    }

    // Precompute canals for each side by mirroring across the sagittal plane (x -> -x)
    const canalsBySide = {
      R: {
        lateral: baseCanalsByType.lateral,
        superior: baseCanalsByType.superior,
        posterior: baseCanalsByType.posterior
      },
      L: {
        lateral: mirrorCanal(baseCanalsByType.lateral),
        superior: mirrorCanal(baseCanalsByType.superior),
        posterior: mirrorCanal(baseCanalsByType.posterior)
      }
    };

    const orderedCanalTypes = ['lateral', 'superior', 'posterior'];

    function getActiveCanalObj(type) {
      if (!type) return null;
      return canalsBySide[selectedSide][type];
    }

    function getActiveCanalsList() {
      return orderedCanalTypes.map(getActiveCanalObj);
    }


    // ---- Interaction state ----
    let rotationX = 0.7;
    let rotationY = -0.4;

    let isDragging = false;
    let lastX = 0;
    let lastY = 0;
    let hoverControl = null; // 'up' | 'down' | 'left' | 'right' | null

    // ---- Mini orientation widget (corner) quick-rotate controls ----
    function getOrientationWidgetLayout() {
      const boxSize = 90;
      const cx = 80;
      const cy = canvas.height - 150;
      const btnR = 16;
      const btnOffset = (boxSize / 2) + 18;
      const buttons = {
        up:    { x: cx,           y: cy - btnOffset },
        down:  { x: cx,           y: cy + btnOffset },
        left:  { x: cx - btnOffset, y: cy },
        right: { x: cx + btnOffset, y: cy }
      };
      return { cx, cy, boxSize, btnR, buttons };
    }

    function hitTestRotationControl(px, py) {
      const { buttons, btnR } = getOrientationWidgetLayout();
      for (const key of Object.keys(buttons)) {
        const b = buttons[key];
        const d = Math.hypot(px - b.x, py - b.y);
        if (d <= btnR + 2) return key;
      }
      return null;
    }

    function normalizeAngle(a) {
      const twoPi = Math.PI * 2;
      a = (a + Math.PI) % twoPi;
      if (a < 0) a += twoPi;
      return a - Math.PI;
    }

    function applyRotationControl(ctrl) {
      const step = Math.PI / 2;
      if (ctrl === 'left') rotationY -= step;
      if (ctrl === 'right') rotationY += step;
      if (ctrl === 'up') rotationX -= step;
      if (ctrl === 'down') rotationX += step;

      rotationX = normalizeAngle(rotationX);
      rotationY = normalizeAngle(rotationY);
    }

    function drawRotationButtons(layout) {
      const { buttons, btnR } = layout;
      const glyph = { up: '▲', down: '▼', left: '◀', right: '▶' };

      for (const key of Object.keys(buttons)) {
        const b = buttons[key];
        const isHover = hoverControl === key;

        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = isHover ? 'rgba(34,197,94,0.25)' : 'rgba(15,23,42,0.92)';
        ctx.strokeStyle = isHover ? 'rgba(34,197,94,0.95)' : 'rgba(148,163,184,0.65)';
        ctx.lineWidth = 2;
        ctx.arc(b.x, b.y, btnR, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.font = '14px system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText(glyph[key] || '?', b.x, b.y + 0.5);
        ctx.restore();
      }
    }

    canvas.addEventListener('pointerdown', (e) => {
      // If the user clicks a quick-rotate arrow, rotate 90° and do NOT begin drag rotation.
      const hit = hitTestRotationControl(e.clientX, e.clientY);
      if (hit) {
        applyRotationControl(hit);
        hoverControl = hit;
        canvas.style.cursor = 'pointer';
        return;
      }

      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointerup', (e) => {
      isDragging = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}

      // Refresh hover state so the cursor updates immediately after click/drag ends.
      hoverControl = hitTestRotationControl(e.clientX, e.clientY);
      canvas.style.cursor = hoverControl ? 'pointer' : 'grab';
    });

    canvas.addEventListener('pointerleave', () => {
      isDragging = false;
      hoverControl = null;
      canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!isDragging) {
        hoverControl = hitTestRotationControl(e.clientX, e.clientY);
        canvas.style.cursor = hoverControl ? 'pointer' : 'grab';
        return;
      }

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;

      rotationY += dx * 0.01;
      rotationX += dy * 0.01;

      lastX = e.clientX;
      lastY = e.clientY;
    });

    // ---- Camera / projection ----
    function worldToCamera(v) {
      const cosX = Math.cos(rotationX);
      const sinX = Math.sin(rotationX);
      const cosY = Math.cos(rotationY);
      const sinY = Math.sin(rotationY);

      let y = v.y * cosX - v.z * sinX;
      let z = v.y * sinX + v.z * cosX;
      let x = v.x;

      let x2 = x * cosY + z * sinY;
      let z2 = -x * sinY + z * cosY;
      let y2 = y;

      return { x: x2, y: y2, z: z2 };
    }

    function projectVertex(v) {
      const cam = worldToCamera(v);
      const distance = 4;
      const fov = 260;
      const zCamera = cam.z + distance;
      const factor = fov / zCamera;

      const sx = cam.x * factor + canvas.width / 2;
      const sy = -cam.y * factor + canvas.height / 2;

      return { x: sx, y: sy, z: cam.z };
    }

    function drawPolyline(points3D, color, width) {
      const projected = points3D.map(projectVertex);
      ctx.beginPath();
      for (let i = 0; i < projected.length; i++) {
        const p = projected[i];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.lineWidth = width;
      ctx.strokeStyle = color;
      ctx.stroke();
    }

    // ---- Red dot states ----
    let dotState = 'none'; // 'canal' | 'falling' | 'none'
    let dotParam = 0.15;
    let dotVel = 0.0;
    const baseGravityStrength = 0.00005;
    const damping = 0.985;
    const maxSpeed = 0.0005;

    let fallX = 0;
    let fallY = 0;
    let fallVy = 0;

    function resetDotInCanal() {
      if (!selectedCanal) return;
      dotState = 'canal';
      dotParam = 0.15;
      dotVel = 0.0;
    }


    function handleSelectionChange() {
      setActiveButtons();

      // If an otolith is already in play, keep the experience coherent.
      if (dotState === 'canal') {
        if (selectedCanal) {
          resetDotInCanal();
        } else {
          // No canal selected -> remove otolith.
          dotState = 'none';
        }
        updateButtonVisibility();
      } else if (dotState === 'falling') {
        dotState = 'none';
        updateButtonVisibility();
      } else {
        updateButtonVisibility();
      }
    }

    for (const btn of sideButtons) {
      btn.addEventListener('click', () => {
        selectedSide = btn.dataset.side;
        handleSelectionChange();
      });
    }

    for (const btn of canalButtons) {
      btn.addEventListener('click', () => {
        const clicked = btn.dataset.canal;
        selectedCanal = (selectedCanal === clicked) ? null : clicked;
        handleSelectionChange();
      });
    }

    setActiveButtons();

    function updateNewDotBtnEnabled() {
      const enabled = !!selectedCanal;
      newDotBtn.disabled = !enabled;
      newDotBtn.textContent = enabled ? 'Add Otolith' : 'Select a Canal';
    }

    function updateButtonVisibility() {
      updateNewDotBtnEnabled();
      newDotBtn.style.display = dotState === 'none' ? 'block' : 'none';
    }

    newDotBtn.addEventListener('click', () => {
      if (dotState === 'none' && selectedCanal) {
        resetDotInCanal();
        updateButtonVisibility();
      }
    });

// ---- Confetti ----
    const confetti = [];
    const confettiColors = ['#f97316', '#22c55e', '#3b82f6', '#eab308', '#ec4899', '#a855f7', '#facc15'];

    function spawnConfetti(x, y) {
      const count = 150;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        confetti.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          life: 60 + Math.random() * 40,
          size: 2 + Math.random() * 3,
          color: confettiColors[Math.floor(Math.random() * confettiColors.length)]
        });
      }
    }

    function updateConfetti() {
      for (let i = confetti.length - 1; i >= 0; i--) {
        const c = confetti[i];
        c.vy += 0.08;
        c.x += c.vx;
        c.y += c.vy;
        c.life -= 1;
        if (c.life <= 0) {
          confetti.splice(i, 1);
        }
      }
    }

    function drawConfetti() {
      for (const c of confetti) {
        ctx.beginPath();
        ctx.fillStyle = c.color;
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ---- Dot motion in canal ----
    function updateDotInCanal() {
      if (!selectedCanal) return;
      const canalObj = getActiveCanalObj(selectedCanal);
      if (!canalObj) return;
      const pts = canalObj.points;
      const n = pts.length - 1;
      if (n <= 0) return;

      let t = dotParam * n;
      let i = Math.floor(t);
      let frac = t - i;
      let i2 = (i + 1) % pts.length;

      const p1 = pts[i];
      const p2 = pts[i2];

      const cam1 = worldToCamera(p1);
      const cam2 = worldToCamera(p2);

      let tx = cam2.x - cam1.x;
      let ty = cam2.y - cam1.y;
      let tz = cam2.z - cam1.z;
      const len = Math.hypot(tx, ty, tz) || 1.0;
      tx /= len; ty /= len; tz /= len;

      const gx = 0, gy = -1, gz = 0;
      const slope = tx * gx + ty * gy + tz * gz;

      dotVel *= damping;
      const g = baseGravityStrength;
      dotVel += slope * g;

      if (dotVel > maxSpeed) dotVel = maxSpeed;
      if (dotVel < -maxSpeed) dotVel = -maxSpeed;

      dotParam = (dotParam + dotVel) % 1;
      if (dotParam < 0) dotParam += 1;

      const dotWorld = getDotWorldPosition();
      const distToVest = Math.hypot(dotWorld.x, dotWorld.y, dotWorld.z);
      if (distToVest < 0.12) {
        const screen = projectVertex(dotWorld);
        fallX = screen.x;
        fallY = screen.y;
        fallVy = 1.5;
        dotState = 'falling';
        spawnConfetti(screen.x, screen.y);
      }
    }

    function getDotWorldPosition() {
      if (!selectedCanal) return { x: 0, y: 0, z: 0 };
      const canalObj = getActiveCanalObj(selectedCanal);
      if (!canalObj) return { x: 0, y: 0, z: 0 };
      const pts = canalObj.points;
      const n = pts.length - 1;
      if (n <= 0) return { x: 0, y: 0, z: 0 };

      let t = dotParam * n;
      let i = Math.floor(t);
      let frac = t - i;
      let i2 = (i + 1) % pts.length;

      const p1 = pts[i];
      const p2 = pts[i2];

      return {
        x: p1.x + (p2.x - p1.x) * frac,
        y: p1.y + (p2.y - p1.y) * frac,
        z: p1.z + (p2.z - p1.z) * frac
      };
    }

    // ---- Falling dot ----
    function updateFallingDot() {
      fallVy += 0.25;
      fallY += fallVy;
      if (fallY - 10 > canvas.height) {
        dotState = 'none';
        updateButtonVisibility();
      }
    }

    // ---- Orientation cube + cylinder I ----
    let movementLevel = 0;
    let prevRotX = rotationX;
    let prevRotY = rotationY;

    resetBtn.addEventListener('click', () => {
      rotationX = 0;
      rotationY = 0;
      prevRotX = rotationX;
      prevRotY = rotationY;
    });

    function drawOrientationCube() {
      const layout = getOrientationWidgetLayout();
      const size = 35;
      const cx = layout.cx;
      const cy = layout.cy;
      const boxSize = layout.boxSize;

      function projectMini(p) {
        const cam = worldToCamera(p);
        const sx = cx + cam.x * size;
        const sy = cy - cam.y * size;
        return { x: sx, y: sy };
      }

      const verts = [
        { x: -1, y: -1, z: -1 },
        { x:  1, y: -1, z: -1 },
        { x:  1, y:  1, z: -1 },
        { x: -1, y:  1, z: -1 },
        { x: -1, y: -1, z:  1 },
        { x:  1, y: -1, z:  1 },
        { x:  1, y:  1, z:  1 },
        { x: -1, y:  1, z:  1 }
      ];

      const edges = [
        [0,1],[1,2],[2,3],[3,0],
        [4,5],[5,6],[6,7],[7,4],
        [0,4],[1,5],[2,6],[3,7]
      ];

      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = 'rgba(15,23,42,0.9)';
      ctx.strokeStyle = 'rgba(148,163,184,0.6)';
      ctx.lineWidth = 1;
      if (ctx.roundRect) {
        ctx.roundRect(cx - boxSize/2, cy - boxSize/2, boxSize, boxSize, 8);
      } else {
        ctx.rect(cx - boxSize/2, cy - boxSize/2, boxSize, boxSize);
      }
      ctx.fill();
      ctx.stroke();

      const projVerts = verts.map(projectMini);
      ctx.beginPath();
      for (const [i1, i2] of edges) {
        const p1 = projVerts[i1];
        const p2 = projVerts[i2];
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
      }
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.font = '14px system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';

      const A = projectMini({ x: 0, y: 0, z:  1.4 });
      const P = projectMini({ x: 0, y: 0, z: -1.4 });
      const S = projectMini({ x: 0, y:  1.4, z: 0 });
      const R = projectMini({ x:  1.4, y: 0, z: 0 });
      const L = projectMini({ x: -1.4, y: 0, z: 0 });

      ctx.fillText('A', A.x, A.y);
      ctx.fillText('P', P.x, P.y);
      ctx.fillText('S', S.x, S.y);
      ctx.fillText('R', R.x, R.y);
      ctx.fillText('L', L.x, L.y);

      const Iinner = projectMini({ x: 0, y: -1.1, z: 0 });
      const Iouter = projectMini({ x: 0, y: -1.6, z: 0 });

      const cylinderDiameter = boxSize * 0.3;
      const cylinderRadius = cylinderDiameter / 2;

      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = cylinderDiameter;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(Iinner.x, Iinner.y);
      ctx.lineTo(Iouter.x, Iouter.y);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = '#ffffff';
      ctx.arc(Iouter.x, Iouter.y, cylinderRadius, 0, Math.PI * 2);
      ctx.fill();

      // 90° quick-rotate buttons around the mini orientation widget
      drawRotationButtons(layout);

      ctx.restore();
    }

    // ---- Eye inset (nystagmus simulation) ----
    let eyeOffsetX = 0;
    let eyePhase = 0;
    const eyeCycleFrames = 80;

    function updateEyes() {
      const active = (dotState === 'canal' && Math.abs(dotVel) > 0.00001);

      if (active) {
        eyePhase = (eyePhase + 1) % eyeCycleFrames;
        const phase = eyePhase / eyeCycleFrames;
        const slowDir = dotVel > 0 ? -1 : 1;
        const quickDir = -slowDir;
        const maxOffset = 7;
        let offset;

        if (phase < 0.9) {
          offset = slowDir * maxOffset * (phase / 0.9);
        } else {
          const fastFrac = (phase - 0.9) / 0.1;
          offset = quickDir * maxOffset * 1.3 * fastFrac;
        }
        eyeOffsetX = offset;
      } else {
        eyePhase = 0;
        eyeOffsetX += (0 - eyeOffsetX) * 0.15;
      }
    }

    function drawEyesBox() {
      const boxX = 20;
      const boxY = 20;
      const boxW = 140;
      const boxH = 70;

      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = 'rgba(15,23,42,0.9)';
      ctx.strokeStyle = 'rgba(148,163,184,0.7)';
      ctx.lineWidth = 1.5;
      if (ctx.roundRect) {
        ctx.roundRect(boxX, boxY, boxW, boxH, 10);
      } else {
        ctx.rect(boxX, boxY, boxW, boxH);
      }
      ctx.fill();
      ctx.stroke();

      const eyeRadius = 18;
      const pupilRadius = 7;
      const leftEyeCx = boxX + boxW * 0.33;
      const rightEyeCx = boxX + boxW * 0.67;
      const eyesCy = boxY + boxH * 0.55;

      ctx.beginPath();
      ctx.fillStyle = '#e5e7eb';
      ctx.arc(leftEyeCx, eyesCy, eyeRadius, 0, Math.PI * 2);
      ctx.arc(rightEyeCx, eyesCy, eyeRadius, 0, Math.PI * 2);
      ctx.fill();

      function clampPupil(cx) {
        const maxOffset = eyeRadius - pupilRadius - 2;
        const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, eyeOffsetX));
        return cx + clampedOffset;
      }

      const leftPupilCx = clampPupil(leftEyeCx);
      const rightPupilCx = clampPupil(rightEyeCx);

      ctx.beginPath();
      ctx.fillStyle = '#020617';
      ctx.arc(leftPupilCx, eyesCy, pupilRadius, 0, Math.PI * 2);
      ctx.arc(rightPupilCx, eyesCy, pupilRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = 'rgba(248,250,252,0.8)';
      ctx.arc(leftPupilCx - 2, eyesCy - 3, 2, 0, Math.PI * 2);
      ctx.arc(rightPupilCx - 2, eyesCy - 3, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // ---- Movement meter on right ----
    function updateMovementMetric() {
      const dRx = rotationX - prevRotX;
      const dRy = rotationY - prevRotY;
      const rotationDelta = Math.hypot(dRx, dRy);

      const rotationActivity = Math.min(1, rotationDelta * 8);
      const dotActivityInstant = dotState === 'canal'
        ? Math.min(1, Math.abs(dotVel) / maxSpeed)
        : 0;

      const target = Math.max(rotationActivity, dotActivityInstant);
      movementLevel = movementLevel * 0.9 + target * 0.1;

      prevRotX = rotationX;
      prevRotY = rotationY;
    }

    function drawMovementMeter() {
      const meterWidth = 26;
      const meterHeight = canvas.height - 140;
      const x = canvas.width - 60;
      const y = 70;

      ctx.save();

      ctx.beginPath();
      ctx.fillStyle = 'rgba(15,23,42,0.95)';
      ctx.strokeStyle = 'rgba(148,163,184,0.8)';
      ctx.lineWidth = 2;
      if (ctx.roundRect) {
        ctx.roundRect(x, y, meterWidth, meterHeight, 10);
      } else {
        ctx.rect(x, y, meterWidth, meterHeight);
      }
      ctx.fill();
      ctx.stroke();

      const padding = 4;
      const innerX = x + padding;
      const innerY = y + padding;
      const innerW = meterWidth - padding * 2;
      const innerH = meterHeight - padding * 2;

      ctx.fillStyle = '#020617';
      ctx.fillRect(innerX, innerY, innerW, innerH);

      const filledHeight = innerH * movementLevel;
      const filledY = innerY + innerH - filledHeight;

      const grad = ctx.createLinearGradient(0, innerY + innerH, 0, innerY);
      grad.addColorStop(0, '#22c55e');
      grad.addColorStop(0.5, '#eab308');
      grad.addColorStop(1, '#ef4444');

      ctx.fillStyle = grad;
      ctx.fillRect(innerX, filledY, innerW, filledHeight);

      ctx.font = '13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('Discomfort', x + meterWidth / 2, y + meterHeight + 8);

      ctx.restore();
    }

    // ---- Main draw loop ----
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.lineCap = 'round';

      const activeCanals = getActiveCanalsList();
      for (const canal of activeCanals) {
        const isSelected = canal.key === selectedCanal;
        drawPolyline(canal.points, isSelected ? '#22c55e' : canal.color, isSelected ? 18 : 14);
      }

      const vestibule = projectVertex({ x: 0, y: 0, z: 0 });
      ctx.beginPath();
      ctx.fillStyle = '#f9fafb';
      ctx.arc(vestibule.x, vestibule.y, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.font = '20px system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000000';
      const activeCanals2 = getActiveCanalsList();
      for (const canal of activeCanals2) {
        const lp = projectVertex(canal.labelPoint);
        ctx.fillText(canal.name, lp.x, lp.y);
      }

      if (dotState === 'canal') {
        const dotWorld = getDotWorldPosition();
        const dotScreen = projectVertex(dotWorld);
        ctx.beginPath();
        ctx.fillStyle = '#ef4444';
        ctx.arc(dotScreen.x, dotScreen.y, 6, 0, Math.PI * 2);
        ctx.fill();
      } else if (dotState === 'falling') {
        ctx.beginPath();
        ctx.fillStyle = '#ef4444';
        ctx.arc(fallX, fallY, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      drawConfetti();
      drawOrientationCube();
      drawEyesBox();
      drawMovementMeter();
    }

    function loop() {
      if (dotState === 'canal') {
        updateDotInCanal();
      } else if (dotState === 'falling') {
        updateFallingDot();
      }
      updateConfetti();
      updateMovementMetric();
      updateEyes();
      draw();
      requestAnimationFrame(loop);
    }

    updateButtonVisibility();
    loop();
  </script>
</body>
</html>
