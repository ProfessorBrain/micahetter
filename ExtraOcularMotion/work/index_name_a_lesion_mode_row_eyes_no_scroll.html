<!DOCTYPE html>
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Extraocular Muscle Simulator – Binocular Yoked (Patient View, Bilateral Sliders)</title>
<style>
    :root{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color:#0f172a;
      color:#e5e7eb;
    }
    body{margin:0;padding:0;}
    .app{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      justify-content:center;
      padding:12px;
      box-sizing:border-box;
    }
    .header{text-align:center;margin-bottom:12px;}
    .header h1{margin:0;font-size:1.6rem;letter-spacing:0.04em;}
    .header p{margin:4px 0 0;font-size:0.9rem;color:#9ca3af;}

    /* 3-column layout: OD sliders | eyes | OS sliders */
    .main{
      display:flex;
      gap:10px;
      align-items:stretch;
      justify-content:center;
      flex-wrap:nowrap;
    }

    /* Wrap side panels on narrower screens to keep the two eyes side-by-side without horizontal scrollbars */
    @media (max-width: 1200px){
      .main{ flex-wrap:wrap; align-items:flex-start; }
    }

    .eye-panel{
      background: radial-gradient(circle at 20% 20%, #1f2937, #020617);
      border-radius:18px;
      padding:12px;
      position:relative;
      box-shadow:0 18px 40px rgba(0,0,0,0.7);
      flex:0 0 560px;
      min-width:560px;
    }

    .eyes-row{
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:14px;
      flex-wrap:nowrap;
      overflow:hidden;
      padding-bottom:0;
    }

    @media (max-width: 620px){
      .eye-panel{
        min-width:0;
        flex:1 1 100%;
      }
      .eyes-row{
        gap:10px;
      }
      .eye-wrapper{
        width:220px;
        height:220px;
      }
      .eye-circle{
        inset:18px;
        width:184px;
        height:184px;
      }
      .iris{
        width:96px;
        height:96px;
        margin:-48px 0 0 -48px;
      }
      .pupil{
        width:36px;
        height:36px;
        margin:-18px 0 0 -18px;
      }
    }

    .eye-column{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      flex:0 0 auto;
    }

    .eye-label{
      margin:0;
      font-size:0.80rem;
      text-transform:uppercase;
      letter-spacing:0.07em;
      color:#9ca3af;
    }

    .eye-wrapper{position:relative;width:260px;height:260px;}
    svg.vectorCanvas{position:absolute;inset:0;pointer-events:none;
      -webkit-clip-path: circle(41% at 50% 50%);
      clip-path: circle(41% at 50% 50%);
    }

    .eye-circle{
      position:absolute;inset:20px;margin:auto;
      width:220px;height:220px;border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, #e5e7eb);
      box-shadow:
        0 0 0 6px rgba(15,23,42,0.8),
        0 20px 35px rgba(0,0,0,0.8);
      overflow:hidden;
      touch-action:none;
      cursor:grab;
    }
    .eye-circle.dragging{cursor:grabbing;}

    .corneal-highlight{
      position:absolute;top:26%;left:22%;
      width:80px;height:80px;border-radius:50%;
      background: radial-gradient(circle, rgba(255,255,255,0.8), transparent 70%);
      pointer-events:none;
      opacity:0.85;
      filter:blur(1px);
    }

    .iris{
      position:absolute;top:50%;left:50%;
      width:110px;height:110px;margin:-55px 0 0 -55px;
      border-radius:50%;
      background:
        radial-gradient(circle at 30% 30%, #93c5fd, #1d4ed8 55%, #020617 75%),
        repeating-conic-gradient(from 0deg,
          rgba(147,197,253,0.15) 0deg 8deg,
          rgba(30,64,175,0.75) 8deg 16deg);
      box-shadow:
        inset 0 0 18px rgba(15,23,42,0.8),
        0 0 8px rgba(37,99,235,0.8);
      transform-origin:center center;
      transition:transform 0.06s linear;
      pointer-events:none;
    }

    .pupil{
      position:absolute;top:50%;left:50%;
      width:40px;height:40px;margin:-20px 0 0 -20px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #111827, #020617 70%);
      box-shadow:0 0 16px rgba(0,0,0,0.9), 0 0 3px rgba(0,0,0,0.8);
      pointer-events:none;
    }

    .axes-labels{
      position:absolute;inset:0;
      pointer-events:none;
      font-size:0.7rem;
      color:#9ca3af;
      text-shadow:0 0 4px rgba(0,0,0,0.8);
    }
    .axes-labels .up{position:absolute;top:4px;left:50%;transform:translateX(-50%);}
    .axes-labels .down{position:absolute;bottom:4px;left:50%;transform:translateX(-50%);}
    .axes-labels .left{position:absolute;top:50%;left:4px;transform:translateY(-50%);}
    .axes-labels .right{position:absolute;top:50%;right:4px;transform:translateY(-50%);}

    .eye-footer{margin-top:10px;font-size:0.8rem;color:#9ca3af;text-align:center;}
    .gaze-readout{font-weight:600;color:#fbbf24;}

    .controls{
      flex:0 1 380px;
      background: radial-gradient(circle at 80% 0%, #1f2937, #020617);
      border-radius:18px;
      padding:12px;
      box-shadow:0 18px 40px rgba(0,0,0,0.7);
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height: 680px;
      overflow-y:auto;
      min-width: 280px;
      max-width: 400px;
    }
    .controls h2{margin:0;font-size:1.0rem;}
    .controls p{margin:2px 0 6px;font-size:0.80rem;color:#9ca3af;}

    .slider-group{
      margin-bottom:6px;
      padding:6px 8px;
      border-radius:10px;
      background:rgba(15,23,42,0.85);
      border:1px solid rgba(55,65,81,0.8);
    }

    .slider-header{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:8px;
      margin-bottom:4px;
      font-size:0.80rem;
    }

    .muscle-name{font-weight:600;letter-spacing:0.03em;}
    .muscle-name .side-tag{
      font-size:0.7rem;
      font-weight:500;
      color:#9ca3af;
      text-transform:uppercase;
      margin-left:4px;
    }

    .slider-value{
      font-feature-settings:"tnum" 1, "lnum" 1;
      color:#e5e7eb;
      min-width:32px;
      text-align:right;
      font-size:0.8rem;
    }

    .slider-subtext{font-size:0.70rem;color:#9ca3af;}

    input[type="range"]{
      width:100%;
      appearance:none;
      height:5px;
      border-radius:999px;
      background: linear-gradient(90deg, #ef4444, #eab308, #22c55e);
      outline:none;
      margin:4px 0 0;
    }
    input[type="range"]::-webkit-slider-thumb{
      appearance:none;
      width:14px;height:14px;border-radius:50%;
      background:#e5e7eb;
      border:2px solid #0f172a;
      box-shadow:0 0 0 3px rgba(248,250,252,0.25);
      cursor:pointer;
    }
    input[type="range"]::-moz-range-thumb{
      width:14px;height:14px;border-radius:50%;
      background:#e5e7eb;
      border:2px solid #0f172a;
      box-shadow:0 0 0 3px rgba(248,250,252,0.25);
      cursor:pointer;
    }
    input[type="range"]::-moz-range-track{
      height:5px;border-radius:999px;
      background: linear-gradient(90deg, #ef4444, #eab308, #22c55e);
    }

    .buttons-row{
      display:flex;
      gap:8px;
      justify-content:flex-start;
      margin-top:4px;
      flex-wrap:wrap;
    }
    button{
      border-radius:999px;
      border:1px solid #4b5563;
      background:rgba(15,23,42,0.9);
      color:#e5e7eb;
      padding:6px 12px;
      font-size:0.8rem;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow:0 8px 16px rgba(0,0,0,0.6);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease, border-color 0.08s ease;
    }
    button span.icon{font-size:0.9rem;}
    button:hover{
      transform: translateY(-1px);
      background: rgba(15,23,42,1);
      border-color: #9ca3af;
      box-shadow: 0 12px 22px rgba(0,0,0,0.75);
    }
    button:active{
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 6px 12px rgba(0,0,0,0.8);
    }

    .legend{
      margin-top:4px;
      font-size:0.75rem;
      color:#9ca3af;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap:4px 12px;
    }
    .legend-item{display:flex;align-items:baseline;gap:6px;}
    .legend-swatch{
      width:10px;height:10px;border-radius:50%;
      background:#93c5fd;
      box-shadow:0 0 6px rgba(59,130,246,0.8);
    }
    .legend-label{font-size:0.72rem;}

    
    .ask-look{
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .ask-look-grid{
      display: grid;
      grid-template-columns: 44px auto 44px;
      grid-template-rows: 44px 44px 44px;
      row-gap: 8px;
      column-gap: 3px;
      align-items: center;
      justify-items: center;
      width: fit-content;
      max-width: 100%;
      }
    .ask-center{
      grid-column: 2;
      grid-row: 2;
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(75,85,99,0.9);
      background: rgba(15,23,42,0.75);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #e5e7eb;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      text-align: center;
      box-shadow: 0 10px 20px rgba(0,0,0,0.55);
      user-select: none;
      line-height: 1.1;
      min-width: 140px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      outline: none;
    }

    .ask-center:hover{
      transform: translateY(-1px);
      border-color: #9ca3af;
      box-shadow: 0 14px 24px rgba(0,0,0,0.75);
      background: rgba(15,23,42,0.85);
    }
    .ask-center:active{
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 7px 12px rgba(0,0,0,0.8);
    }
    .ask-btn{
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      font-size: 1.05rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 18px rgba(0,0,0,0.6);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease, border-color 0.08s ease;
      user-select: none;
    }
    .ask-btn:hover{
      transform: translateY(-1px);
      border-color: #9ca3af;
      box-shadow: 0 14px 24px rgba(0,0,0,0.75);
      background: rgba(15,23,42,1);
    }
    .ask-btn:active{
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 7px 12px rgba(0,0,0,0.8);
    }
    .ask-up{ grid-column: 2; grid-row: 1; }
    .ask-left{ grid-column: 1; grid-row: 2; }
    .ask-right{ grid-column: 3; grid-row: 2; }
    .ask-down{ grid-column: 2; grid-row: 3; }
    .ask-upleft{ grid-column: 1; grid-row: 1; }
    .ask-upright{ grid-column: 3; grid-row: 1; }
    .ask-downleft{ grid-column: 1; grid-row: 3; }
    .ask-downright{ grid-column: 3; grid-row: 3; }

    .ask-hint{
      font-size: 0.75rem;
      color: #9ca3af;
      text-align: center;
    }

    
    .lesion-row{
      display:flex;
      justify-content:center;
      margin-top:8px;
    }
    .lesion-btn{
      border-radius:999px;
      border:1px solid #4b5563;
      background:rgba(15,23,42,0.9);
      color:#e5e7eb;
      padding:6px 12px;
      font-size:0.8rem;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow:0 8px 16px rgba(0,0,0,0.6);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease, border-color 0.08s ease;
    }
    .lesion-btn:hover{
      transform: translateY(-1px);
      background: rgba(15,23,42,1);
      border-color: #9ca3af;
      box-shadow: 0 12px 22px rgba(0,0,0,0.75);
    }
    .lesion-btn:active{
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 6px 12px rgba(0,0,0,0.8);
    }

    .modal-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.65);
      z-index: 9999;
      padding: 14px;
    }
    .modal-overlay.show{ display:flex; }

    .modal-card{
      width: min(720px, 96vw);
      background: radial-gradient(circle at 80% 0%, #1f2937, #020617);
      border: 1px solid rgba(75,85,99,0.95);
      border-radius: 18px;
      box-shadow: 0 24px 60px rgba(0,0,0,0.85);
      padding: 14px;
    }
    .modal-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .modal-title{
      font-size: 1.05rem;
      font-weight: 800;
      letter-spacing: 0.03em;
    }
    .modal-close{
      border-radius: 999px;
      border: 1px solid rgba(75,85,99,0.95);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      width: 36px;
      height: 36px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,0.6);
    }
    .modal-close:hover{ border-color:#9ca3af; }
    .modal-close:active{ transform: translateY(1px) scale(0.98); }

    .modal-cols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .modal-col-title{
      font-size: 0.78rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin: 0 0 8px;
    }
    .chk{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(55,65,81,0.8);
      cursor: pointer;
      user-select: none;
      margin-bottom: 8px;
    }
    .chk input{
      width: 18px;
      height: 18px;
      accent-color: #60a5fa;
    }
    .chk span{
      font-size: 0.92rem;
      color: #e5e7eb;
    }
    .modal-footer-note{
      margin-top: 8px;
      font-size: 0.78rem;
      color: #9ca3af;
      text-align:center;
    }

    .modal-sep{
      height: 10px;
      margin: 6px 0 10px;
      border-top: 1px dashed rgba(148,163,184,0.35);
      width: 100%;
    }
    .mlf-row{
      display: flex;
      justify-content: flex-start;
    }

    .slider-group.is-disabled{
      opacity: 0.60;
    }
    .slider-group.is-disabled .muscle-name{
      text-decoration: line-through;
      text-decoration-thickness: 2px;
      text-decoration-color: rgba(229,231,235,0.8);
    }
    input[type="range"]:disabled{
      cursor:not-allowed;
      filter: grayscale(0.25);
    }

    @media (max-width: 700px){
      .modal-cols{ grid-template-columns: 1fr; }
    }

    /* On very narrow screens, allow the whole layout to wrap (avoids scrollbars) */
    @media (max-width: 860px){
      .main{ flex-wrap:wrap; }
      .eye-panel{ flex:1 1 100%; min-width:0; }
      .controls{ flex:1 1 100%; max-width:none; }
    }

    /* --- Game mode: Name the Lesion --- */
    .lesion-row{
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .lesion-btn.lesion-btn-game{
      border-color:#6d28d9;
    }
    .lesion-btn.lesion-btn-game:hover{
      border-color:#8b5cf6;
    }

    body.game-mode .controls{
      visibility:hidden; /* keep layout stable but hide sandbox controls */
    }
    body.game-mode #lesionBtn{
      opacity:0.45;
      pointer-events:none;
      filter: grayscale(0.4);
    }

    .game-panel{
      margin-top:10px;
      border:1px solid rgba(148,163,184,0.22);
      background: rgba(15,23,42,0.72);
      border-radius:16px;
      padding:12px 14px;
      box-shadow:0 12px 24px rgba(0,0,0,0.55);
      max-width: 520px;
      margin-left:auto;
      margin-right:auto;
    }
    .game-top{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .game-title{
      font-weight:700;
      letter-spacing:0.02em;
      color:#e5e7eb;
      font-size:0.95rem;
    }
    .game-stats{
      display:flex;
      align-items:center;
      gap:10px;
      color:#cbd5e1;
      font-size:0.82rem;
      opacity:0.95;
    }
    .game-dot{ opacity:0.55; }
    .game-label{ color:#9ca3af; margin-right:6px; font-size:0.75rem; letter-spacing:0.02em; text-transform:uppercase; }
    .game-controls{
      display:flex;
      gap:10px;
      margin-top:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:center;
    }
    .game-select-wrap{
      display:flex;
      gap:10px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(75,85,99,0.75);
      background: rgba(2,6,23,0.55);
    }
    .game-select-wrap select{
      background: transparent;
      color:#e5e7eb;
      border:none;
      outline:none;
      font-size:0.86rem;
    }
    .game-select-wrap option{
      background:#0b1220;
      color:#e5e7eb;
    }
    .mini-btn{
      border-radius:999px;
      border:1px solid rgba(75,85,99,0.85);
      background: rgba(2,6,23,0.55);
      color:#e5e7eb;
      padding:6px 12px;
      font-size:0.82rem;
      cursor:pointer;
      box-shadow:0 8px 16px rgba(0,0,0,0.45);
      transition: transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease, background 0.08s ease, opacity 0.08s ease;
    }
    .mini-btn:hover{
      transform: translateY(-1px);
      border-color:#64748b;
      box-shadow:0 10px 18px rgba(0,0,0,0.5);
    }
    .mini-btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
      transform:none;
      box-shadow:0 8px 16px rgba(0,0,0,0.35);
    }
    .mini-btn-primary{
      border-color:#2563eb;
      background: rgba(37,99,235,0.18);
    }
    .mini-btn-primary:hover{
      border-color:#3b82f6;
      background: rgba(59,130,246,0.22);
    }
    .game-feedback{
      margin-top:10px;
      text-align:center;
      color:#e5e7eb;
      font-size:0.9rem;
      min-height:1.2em;
    }
</style>
</head>
<body>
<div class="app">
<div class="main">
<!-- OD sliders (left side of screen) -->
<section aria-label="Right eye muscle controls" class="controls">
<h2>Right eye muscle meters</h2>

<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Medial rectus <span class="side-tag">(adduction)</span></div>
<div class="slider-value" id="od_mrVal">50</div>
</div>
<input id="od_mr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Right eye: adduction (toward nose) → left gaze.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Lateral rectus <span class="side-tag">(abduction)</span></div>
<div class="slider-value" id="od_lrVal">50</div>
</div>
<input id="od_lr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Right eye: abduction (toward temple) → right gaze.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Superior rectus <span class="side-tag">(elevates + adducts)</span></div>
<div class="slider-value" id="od_srVal">50</div>
</div>
<input id="od_sr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: elevation. Secondary: adduction, intorsion.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Inferior rectus <span class="side-tag">(depresses + adducts)</span></div>
<div class="slider-value" id="od_irVal">50</div>
</div>
<input id="od_ir" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: depression. Secondary: adduction, extorsion.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Superior oblique <span class="side-tag">(depresses + abducts)</span></div>
<div class="slider-value" id="od_soVal">50</div>
</div>
<input id="od_so" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: intorsion. Secondary: depression in adduction, abduction.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Inferior oblique <span class="side-tag">(elevates + abducts)</span></div>
<div class="slider-value" id="od_ioVal">50</div>
</div>
<input id="od_io" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: extorsion. Secondary: elevation in adduction, abduction.</div>
</div>


</section>
<!-- Eyes (center) -->
<section aria-label="Binocular eye visualization" class="eye-panel">
<div class="eyes-row">
<!-- Patient RIGHT eye appears on viewer LEFT -->
<div class="eye-column">
<h3 class="eye-label">Right eye</h3>
<div class="eye-wrapper">
<svg aria-hidden="true" class="vectorCanvas" viewbox="0 0 260 260">
<defs>
<marker id="arrowHeadRight" markerheight="8" markerunits="strokeWidth" markerwidth="8" orient="auto" refx="4" refy="4">
<path d="M0,0 L8,4 L0,8 z" fill="#fbbf24"></path>
</marker>
</defs>
<line stroke="rgba(75,85,99,0.7)" stroke-dasharray="4 4" stroke-width="1.2" x1="130" x2="130" y1="20" y2="240"></line>
<line stroke="rgba(75,85,99,0.7)" stroke-dasharray="4 4" stroke-width="1.2" x1="20" x2="240" y1="130" y2="130"></line>
<line id="netVectorRight" marker-end="url(#arrowHeadRight)" opacity="0.0" stroke="#fbbf24" stroke-width="3" x1="130" x2="130" y1="130" y2="130"></line>
</svg>
<div class="eye-circle" data-eye="right">
<div class="corneal-highlight"></div>
<div class="iris" id="irisOD"><div class="pupil"></div></div>
</div>
<!-- Patient view: OD temporal = outer (viewer left), nasal = inner (viewer right) -->
<div aria-hidden="true" class="axes-labels">
<div class="up">Up</div>
<div class="down">Down</div>
<div class="left">Temporal</div>
<div class="right">Nasal</div>
</div>
</div>
</div>
<!-- Patient LEFT eye appears on viewer RIGHT -->
<div class="eye-column">
<h3 class="eye-label">Left eye</h3>
<div class="eye-wrapper">
<svg aria-hidden="true" class="vectorCanvas" viewbox="0 0 260 260">
<defs>
<marker id="arrowHeadLeft" markerheight="8" markerunits="strokeWidth" markerwidth="8" orient="auto" refx="4" refy="4">
<path d="M0,0 L8,4 L0,8 z" fill="#fbbf24"></path>
</marker>
</defs>
<line stroke="rgba(75,85,99,0.7)" stroke-dasharray="4 4" stroke-width="1.2" x1="130" x2="130" y1="20" y2="240"></line>
<line stroke="rgba(75,85,99,0.7)" stroke-dasharray="4 4" stroke-width="1.2" x1="20" x2="240" y1="130" y2="130"></line>
<line id="netVectorLeft" marker-end="url(#arrowHeadLeft)" opacity="0.0" stroke="#fbbf24" stroke-width="3" x1="130" x2="130" y1="130" y2="130"></line>
</svg>
<div class="eye-circle" data-eye="left">
<div class="corneal-highlight"></div>
<div class="iris" id="irisOS"><div class="pupil"></div></div>
</div>
<!-- Patient view: OS nasal = inner (viewer left), temporal = outer (viewer right) -->
<div aria-hidden="true" class="axes-labels">
<div class="up">Up</div>
<div class="down">Down</div>
<div class="left">Nasal</div>
<div class="right">Temporal</div>
</div>
</div>
</div>
</div>
<div aria-label="Ask patient to look controls" class="ask-look">
<div class="ask-look-grid">
<button aria-label="Ask eyes to move up-left" class="ask-btn ask-upleft" id="askUpLeft" type="button">↖</button>
<button aria-label="Ask patient to look up" class="ask-btn ask-up" id="askUp" type="button">↑</button>
<button aria-label="Ask eyes to move up-right" class="ask-btn ask-upright" id="askUpRight" type="button">↗</button>
<button aria-label="Ask patient to look left" class="ask-btn ask-left" id="askLeft" type="button">←</button>
<button class="ask-center" id="askCenter" type="button" aria-label="Center gaze">Ask to Look</button>
<button aria-label="Ask patient to look right" class="ask-btn ask-right" id="askRight" type="button">→</button>
<button aria-label="Ask eyes to move down-left" class="ask-btn ask-downleft" id="askDownLeft" type="button">↙</button>
<button aria-label="Ask patient to look down" class="ask-btn ask-down" id="askDown" type="button">↓</button>
<button aria-label="Ask eyes to move down-right" class="ask-btn ask-downright" id="askDownRight" type="button">↘</button>
</div>
</div>
<div class="eye-footer">
        Conjugate gaze: <span class="gaze-readout" id="gazeReadout">Primary position</span>
</div>
      <div class="lesion-row">
        <button class="lesion-btn" id="lesionBtn" type="button">Add a lesion</button>
        <button class="lesion-btn lesion-btn-game" id="nameLesionBtn" type="button">Name a Lesion</button>
      </div>

      <div class="game-panel" id="gamePanel" aria-live="polite" hidden>
        <div class="game-top">
          <div class="game-title">Name the Lesion</div>
          <div class="game-stats">
            <span class="game-stat"><span class="game-label">Time</span> <span id="gameTimer">0.0s</span></span>
            <span class="game-dot">•</span>
            <span class="game-stat"><span class="game-label">Looks</span> <span id="gameLooks">0</span></span>
            <span class="game-dot">•</span>
            <span class="game-stat"><span class="game-label">Score</span> <span id="gameScore">0</span></span>
          </div>
        </div>

        <div class="game-controls">
          <button class="mini-btn" id="gameNewRound" type="button">New round</button>

          <label class="game-select-wrap" aria-label="Select diagnosis to submit">
            <span class="game-label">Diagnosis</span>
            <select id="diagnosisSelect">
              <option value="" selected disabled>Select…</option>
              <option value="R_CN_VI">Right CN VI palsy</option>
              <option value="L_CN_VI">Left CN VI palsy</option>
              <option value="R_CN_IV">Right CN IV palsy</option>
              <option value="L_CN_IV">Left CN IV palsy</option>
              <option value="R_CN_III">Right CN III palsy</option>
              <option value="L_CN_III">Left CN III palsy</option>
              <option value="R_INO">Right INO (right MLF lesion)</option>
              <option value="L_INO">Left INO (left MLF lesion)</option>
            </select>
          </label>

          <button class="mini-btn mini-btn-primary" id="submitGuess" type="button" disabled>Submit</button>
          <button class="mini-btn" id="revealLesionBtn" type="button" disabled>Reveal lesion</button>
        </div>

        <div class="game-feedback" id="gameFeedback"></div>
      </div>

</section>
<!-- OS sliders (right side of screen, to the right of the left eye) -->
<section aria-label="Left eye muscle controls" class="controls">
<h2>Left eye muscle meters</h2>

<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Medial rectus <span class="side-tag">(adduction)</span></div>
<div class="slider-value" id="os_mrVal">50</div>
</div>
<input id="os_mr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Left eye: adduction (toward nose) → right gaze.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Lateral rectus <span class="side-tag">(abduction)</span></div>
<div class="slider-value" id="os_lrVal">50</div>
</div>
<input id="os_lr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Left eye: abduction (toward temple) → left gaze.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Superior rectus <span class="side-tag">(elevates + adducts)</span></div>
<div class="slider-value" id="os_srVal">50</div>
</div>
<input id="os_sr" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: elevation. Secondary: adduction, intorsion.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Inferior rectus <span class="side-tag">(depresses + adducts)</span></div>
<div class="slider-value" id="os_irVal">50</div>
</div>
<input id="os_ir" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: depression. Secondary: adduction, extorsion.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Superior oblique <span class="side-tag">(depresses + abducts)</span></div>
<div class="slider-value" id="os_soVal">50</div>
</div>
<input id="os_so" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: intorsion. Secondary: depression in adduction, abduction.</div>
</div>
<div class="slider-group">
<div class="slider-header">
<div class="muscle-name">Inferior oblique <span class="side-tag">(elevates + abducts)</span></div>
<div class="slider-value" id="os_ioVal">50</div>
</div>
<input id="os_io" max="100" min="0" type="range" value="50"/>
<div class="slider-subtext">Primary: extorsion. Secondary: elevation in adduction, abduction.</div>
</div>

</section>
</div>
</div>

  <div class="modal-overlay" id="lesionModal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="lesionTitle">
      <div class="modal-header">
        <div class="modal-title" id="lesionTitle">Lesion</div>
        <button class="modal-close" id="lesionClose" type="button" aria-label="Close">✕</button>
      </div>
      <div class="modal-body">
        
        <div class="modal-cols">
          <div class="modal-col">
            <div class="modal-col-title">Right eye</div>

            <div class="cn-block">
              <div class="cn-title">CN III</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_mr" checked><span>Medial rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_sr" checked><span>Superior rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_ir" checked><span>Inferior rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_io" checked><span>Inferior oblique</span></label>
              </div>
            </div>

            <div class="cn-block">
              <div class="cn-title">CN IV</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_so" checked><span>Superior oblique</span></label>
              </div>
            </div>

            <div class="cn-block">
              <div class="cn-title">CN VI</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_od_lr" checked><span>Lateral rectus</span></label>
              </div>
            </div>

            <div class="modal-sep"></div>
            <div class="mlf-row"><label class="chk chk-special"><input type="checkbox" id="lesion_mlf_right"><span>MLF lesion (INO)</span></label></div>
          </div>

          <div class="modal-col">
            <div class="modal-col-title">Left eye</div>

            <div class="cn-block">
              <div class="cn-title">CN III</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_mr" checked><span>Medial rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_sr" checked><span>Superior rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_ir" checked><span>Inferior rectus</span></label>
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_io" checked><span>Inferior oblique</span></label>
              </div>
            </div>

            <div class="cn-block">
              <div class="cn-title">CN IV</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_so" checked><span>Superior oblique</span></label>
              </div>
            </div>

            <div class="cn-block">
              <div class="cn-title">CN VI</div>
              <div class="cn-items">
                <label class="chk chk-sub"><input type="checkbox" id="lesion_os_lr" checked><span>Lateral rectus</span></label>
              </div>
            </div>

            <div class="modal-sep"></div>
            <div class="mlf-row"><label class="chk chk-special"><input type="checkbox" id="lesion_mlf_left"><span>MLF lesion (INO)</span></label></div>
          </div>
        </div>

        </div>
</div>
    </div>
  </div>

<script>
  // Patient-space convention:
  // h > 0  = patient looks to their RIGHT.
  // When facing the patient, patient-right is on the viewer's LEFT -> horizontal is flipped for rendering.
  //
  // We keep a single "conjugate gaze" state (h, v). Either eye's sliders can drive it.
  // When gaze is set, both sets of sliders are updated from gaze using eye-specific mapping.

  const state = {
    gazeH: 0, // patient-space
    gazeV: 0, // patient-space
    isProgrammatic: false,
    lastDriver: "drag" // "od" | "os" | "drag"
  };

  const irisOD = document.getElementById("irisOD");
  const irisOS = document.getElementById("irisOS");
  const netVectorRight = document.getElementById("netVectorRight");
  const netVectorLeft  = document.getElementById("netVectorLeft");
  const gazeReadout = document.getElementById("gazeReadout");
  const lesionBtn = document.getElementById("lesionBtn");
  const lesionModal = document.getElementById("lesionModal");
  const lesionClose = document.getElementById("lesionClose");
  const nameLesionBtn = document.getElementById("nameLesionBtn");

  const gamePanel = document.getElementById("gamePanel");
  const gameNewRoundBtn = document.getElementById("gameNewRound");
  const diagnosisSelect = document.getElementById("diagnosisSelect");
  const submitGuessBtn = document.getElementById("submitGuess");
  const revealLesionBtn = document.getElementById("revealLesionBtn");
  const gameTimerEl = document.getElementById("gameTimer");
  const gameLooksEl = document.getElementById("gameLooks");
  const gameScoreEl = document.getElementById("gameScore");
  const gameFeedbackEl = document.getElementById("gameFeedback");


  const eyeCircles = document.querySelectorAll(".eye-circle");


  const askUpBtn = document.getElementById("askUp");
  const askDownBtn = document.getElementById("askDown");
  const askLeftBtn = document.getElementById("askLeft");
  const askRightBtn = document.getElementById("askRight");
  const askUpLeftBtn = document.getElementById("askUpLeft");
  const askUpRightBtn = document.getElementById("askUpRight");
  const askDownLeftBtn = document.getElementById("askDownLeft");
  const askDownRightBtn = document.getElementById("askDownRight");
  const askCenterBtn = document.getElementById("askCenter");

  const GAZE_SCALE = 1.4; // keep in sync with setGazeDirect scaling

  function getCurrentNorm(){
    return {
      h: Math.max(-1, Math.min(1, state.gazeH / GAZE_SCALE)),
      v: Math.max(-1, Math.min(1, state.gazeV / GAZE_SCALE))
    };
  }

  function animateGazeTo(targetHNorm, targetVNorm, ms=180){
    const start = getCurrentNorm();
    const endH = Math.max(-1, Math.min(1, targetHNorm));
    const endV = Math.max(-1, Math.min(1, targetVNorm));
    const t0 = performance.now();

    function easeInOut(t){
      // smoothstep
      return t*t*(3 - 2*t);
    }

    function step(now){
      const t = Math.min(1, (now - t0) / ms);
      const e = easeInOut(t);
      const h = start.h + (endH - start.h) * e;
      const v = start.v + (endV - start.v) * e;
      setGazeDirect(h, v);
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function wireAskButtons(){
    if (!askUpBtn) return;

    const __animate = animateGazeTo;
    const doAsk = (h, v) => {
      if (game.active && game.roundActive){
        game.looks++;
        updateGameHUD();
      }
      __animate(h, v);
    };

    // Patient-direction arrows:
    // ↑ up (v=+1)
    // ↓ down (v=-1)
    // ← patient-left gaze (h=-1)
    // → patient-right gaze (h=+1)
    askUpBtn.addEventListener("click", () => doAsk(0, 1));
    askDownBtn.addEventListener("click", () => doAsk(0, -1));
    askLeftBtn.addEventListener("click", () => doAsk(1, 0));
        askRightBtn.addEventListener("click", () => doAsk(-1, 0));

    // Diagonals (screen directions):
    // ↖ up-left  = up + patient right (h=+1, v=+1)
    // ↗ up-right = up + patient left  (h=-1, v=+1)
    // ↙ down-left  = down + patient right (h=+1, v=-1)
    // ↘ down-right = down + patient left  (h=-1, v=-1)
    if (askUpLeftBtn) askUpLeftBtn.addEventListener("click", () => doAsk(1, 1));
    if (askUpRightBtn) askUpRightBtn.addEventListener("click", () => doAsk(-1, 1));
    if (askDownLeftBtn) askDownLeftBtn.addEventListener("click", () => doAsk(1, -1));
    if (askDownRightBtn) askDownRightBtn.addEventListener("click", () => doAsk(-1, -1));

    if (askCenterBtn){
      askCenterBtn.addEventListener("click", () => doAsk(0, 0));
    }
  }


  const MAX_VECTOR_MAG = 1.8;
  const MAX_OFFSET_PX = 40;
  const VERTICAL_GAIN = 1.28;  // make vertical excursions slightly larger than horizontal
  const ARROW_SCALE = 55;
  const SVG_CENTER = 130;

  // OD muscle vectors in patient-space (as in prior version)
  const OD = {
    mr: { label:"Medial rectus",   horiz:-1.0, vert: 0.0, valId:"od_mrVal", sliderId:"od_mr" },
    lr: { label:"Lateral rectus",  horiz: 1.0, vert: 0.0, valId:"od_lrVal", sliderId:"od_lr" },
    sr: { label:"Superior rectus", horiz:-0.3, vert: 1.0, valId:"od_srVal", sliderId:"od_sr" },
    ir: { label:"Inferior rectus", horiz:-0.3, vert:-1.0, valId:"od_irVal", sliderId:"od_ir" },
    so: { label:"Superior oblique",horiz: 0.3, vert:-0.7, valId:"od_soVal", sliderId:"od_so" },
    io: { label:"Inferior oblique",horiz: 0.3, vert: 0.7, valId:"od_ioVal", sliderId:"od_io" }
  };

  // OS muscle vectors in patient-space:
  // Horizontal actions are mirrored vs OD:
  // - OS MR adducts (toward nose) = patient RIGHT gaze (h positive)
  // - OS LR abducts (toward temple) = patient LEFT gaze (h negative)
  // SR/IR adduct (toward nose) -> patient RIGHT (positive), so horiz sign flips.
  // Obliques abduct -> patient LEFT (negative), so horiz sign flips.
  const OS = {
    mr: { label:"Medial rectus",   horiz: 1.0, vert: 0.0, valId:"os_mrVal", sliderId:"os_mr" },
    lr: { label:"Lateral rectus",  horiz:-1.0, vert: 0.0, valId:"os_lrVal", sliderId:"os_lr" },
    sr: { label:"Superior rectus", horiz: 0.3, vert: 1.0, valId:"os_srVal", sliderId:"os_sr" },
    ir: { label:"Inferior rectus", horiz: 0.3, vert:-1.0, valId:"os_irVal", sliderId:"os_ir" },
    so: { label:"Superior oblique",horiz:-0.3, vert:-0.7, valId:"os_soVal", sliderId:"os_so" },
    io: { label:"Inferior oblique",horiz:-0.3, vert: 0.7, valId:"os_ioVal", sliderId:"os_io" }
  };

  const odSliders = {};
  const osSliders = {};
  Object.keys(OD).forEach(k => odSliders[k] = document.getElementById(OD[k].sliderId));
  Object.keys(OS).forEach(k => osSliders[k] = document.getElementById(OS[k].sliderId));

  const muscleKeys = ["mr","lr","sr","ir","so","io"];
const enabled = { od: {}, os: {} };
  const mlf = { right: false, left: false };
  muscleKeys.forEach(k => { enabled.od[k] = true; enabled.os[k] = true; });

  // --- Name the Lesion game mode ---
  const game = {
    active: false,
    roundActive: false,
    startMs: null,
    looks: 0,
    score: 0,
    answerId: null,
    answerLabel: null,
    raf: null,
    sandboxSnapshot: null
  };

  const DIAG_POOL = [
    { id:"R_CN_VI",  label:"Right CN VI palsy",  apply: ()=>{ setMuscleEnabled("od","lr", false); } },
    { id:"L_CN_VI",  label:"Left CN VI palsy",   apply: ()=>{ setMuscleEnabled("os","lr", false); } },
    { id:"R_CN_IV",  label:"Right CN IV palsy",  apply: ()=>{ setMuscleEnabled("od","so", false); } },
    { id:"L_CN_IV",  label:"Left CN IV palsy",   apply: ()=>{ setMuscleEnabled("os","so", false); } },
    { id:"R_CN_III", label:"Right CN III palsy", apply: ()=>{
        ["mr","sr","ir","io"].forEach(k=> setMuscleEnabled("od", k, false));
      } },
    { id:"L_CN_III", label:"Left CN III palsy",  apply: ()=>{
        ["mr","sr","ir","io"].forEach(k=> setMuscleEnabled("os", k, false));
      } },
    { id:"R_INO",    label:"Right INO (right MLF lesion)", apply: ()=>{ mlf.right = true; } },
    { id:"L_INO",    label:"Left INO (left MLF lesion)",   apply: ()=>{ mlf.left  = true; } }
  ];

  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  function snapshotSandbox(){
    const snap = {
      enabled: deepClone(enabled),
      mlf: deepClone(mlf),
      sliders: { od:{}, os:{} },
      gazeH: state.gazeH,
      gazeV: state.gazeV
    };
    muscleKeys.forEach(k=>{
      snap.sliders.od[k] = Number(odSliders[k]?.value ?? 50);
      snap.sliders.os[k] = Number(osSliders[k]?.value ?? 50);
    });
    return snap;
  }

  function restoreSandbox(snap){
    if (!snap) return;

    // Restore enabled flags and slider values
    muscleKeys.forEach(k=>{
      setMuscleEnabled("od", k, !!snap.enabled.od[k]);
      setMuscleEnabled("os", k, !!snap.enabled.os[k]);
    });

    mlf.right = !!snap.mlf.right;
    mlf.left  = !!snap.mlf.left;

    muscleKeys.forEach(k=>{
      if (odSliders[k]) odSliders[k].value = String(snap.sliders.od[k]);
      if (osSliders[k]) osSliders[k].value = String(snap.sliders.os[k]);
    });

    refreshLesionCheckboxes();
    renderFromSliders();

    const hNorm = Math.max(-1, Math.min(1, (snap.gazeH || 0) / GAZE_SCALE));
    const vNorm = Math.max(-1, Math.min(1, (snap.gazeV || 0) / GAZE_SCALE));
    setGazeDirect(hNorm, vNorm);
  }

  function refreshLesionCheckboxes(){
    // Muscle checkboxes
    ["od","os"].forEach(eye=>{
      muscleKeys.forEach(k=>{
        const cb = document.getElementById(`lesion_${eye}_${k}`);
        if (cb) cb.checked = !!enabled[eye][k];
      });
    });
    // MLF checkboxes
    const mlfRightCb = document.getElementById("lesion_mlf_right");
    const mlfLeftCb  = document.getElementById("lesion_mlf_left");
    if (mlfRightCb) mlfRightCb.checked = !!mlf.right;
    if (mlfLeftCb)  mlfLeftCb.checked  = !!mlf.left;
  }

  function resetToNormal(){
    // All muscles enabled + all sliders neutral
    muscleKeys.forEach(k=>{
      setMuscleEnabled("od", k, true);
      setMuscleEnabled("os", k, true);
      if (odSliders[k]) odSliders[k].value = "50";
      if (osSliders[k]) osSliders[k].value = "50";
    });
    mlf.right = false;
    mlf.left = false;
    refreshLesionCheckboxes();
    renderFromSliders();
  }

  function setGameUIVisible(isVisible){
    if (!gamePanel) return;
    gamePanel.hidden = !isVisible;
  }

  function updateGameHUD(){
    if (gameLooksEl) gameLooksEl.textContent = String(game.looks);
    if (gameScoreEl) gameScoreEl.textContent = String(game.score);
  }

  function formatTime(ms){
    const s = Math.max(0, ms / 1000);
    return `${s.toFixed(1)}s`;
  }

  function tickTimer(){
    if (!game.roundActive) return;
    const now = performance.now();
    if (gameTimerEl && game.startMs != null){
      gameTimerEl.textContent = formatTime(now - game.startMs);
    }
    game.raf = requestAnimationFrame(tickTimer);
  }

  function startRound(){
    resetToNormal();

    // Pick answer
    const pick = DIAG_POOL[Math.floor(Math.random() * DIAG_POOL.length)];
    game.answerId = pick.id;
    game.answerLabel = pick.label;

    // Apply lesion pattern
    pick.apply();
    refreshLesionCheckboxes();
    renderFromSliders();

    // Reset exam
    animateGazeTo(0, 0);

    // Reset scorekeeping
    game.looks = 0;
    game.roundActive = true;
    game.startMs = performance.now();

    if (gameFeedbackEl) gameFeedbackEl.textContent = "Round started. Use Ask to Look, then submit your diagnosis.";
    if (diagnosisSelect){
      diagnosisSelect.value = "";
      diagnosisSelect.disabled = false;
    }
    if (submitGuessBtn) submitGuessBtn.disabled = true; // enable once user chooses
    if (revealLesionBtn) revealLesionBtn.disabled = true;

    updateGameHUD();

    if (game.raf) cancelAnimationFrame(game.raf);
    game.raf = requestAnimationFrame(tickTimer);
  }

  function endRoundAndScore(isCorrect){
    game.roundActive = false;
    if (game.raf) cancelAnimationFrame(game.raf);
    game.raf = null;

    const elapsedMs = (performance.now() - (game.startMs ?? performance.now()));
    const secs = Math.max(0, elapsedMs / 1000);

    let pts = 0;
    if (isCorrect){
      // Simple scoring: base 100, minus looks and time
      pts = Math.round(Math.max(10, 100 - (game.looks * 6) - (secs * 2.2)));
      game.score += pts;
    }

    updateGameHUD();

    return { pts, secs };
  }

  function submitGuess(){
    if (!game.active || !game.roundActive) return;
    if (!diagnosisSelect) return;

    const guess = diagnosisSelect.value;
    if (!guess) return;

    const isCorrect = (guess === game.answerId);
    const result = endRoundAndScore(isCorrect);

    if (submitGuessBtn) submitGuessBtn.disabled = true;
    if (revealLesionBtn) revealLesionBtn.disabled = false;

    if (gameFeedbackEl){
      if (isCorrect){
        gameFeedbackEl.textContent = `Correct: ${game.answerLabel}. ${formatTime(result.secs*1000)} • Looks ${game.looks} • +${result.pts}`;
      } else {
        const prettyGuess = diagnosisSelect.options[diagnosisSelect.selectedIndex]?.textContent?.trim() || "Your guess";
        gameFeedbackEl.textContent = `Incorrect (${prettyGuess}). Correct: ${game.answerLabel}. ${formatTime(result.secs*1000)} • Looks ${game.looks}`;
      }
    }
  }

  function enterGameMode(){
    if (game.active) return;
    game.active = true;

    game.sandboxSnapshot = snapshotSandbox();

    document.body.classList.add("game-mode");
    setGameUIVisible(true);

    if (lesionBtn) lesionBtn.disabled = true;
    if (nameLesionBtn) nameLesionBtn.textContent = "Exit Game";

    if (gameNewRoundBtn){
      gameNewRoundBtn.disabled = false;
    }
    startRound();
  }

  function exitGameMode(){
    if (!game.active) return;

    game.active = false;
    game.roundActive = false;
    if (game.raf) cancelAnimationFrame(game.raf);
    game.raf = null;

    document.body.classList.remove("game-mode");
    setGameUIVisible(false);

    if (lesionBtn) lesionBtn.disabled = false;
    if (nameLesionBtn) nameLesionBtn.textContent = "Name a Lesion";

    // Restore sandbox exactly as it was
    restoreSandbox(game.sandboxSnapshot);
    game.sandboxSnapshot = null;

    if (gameFeedbackEl) gameFeedbackEl.textContent = "";
  }


  function setMuscleEnabled(eye, k, isEnabled){
    enabled[eye][k] = !!isEnabled;
    const defs = (eye === "od") ? OD : OS;
    const sliders = (eye === "od") ? odSliders : osSliders;
    const slider = sliders[k];
    if (!slider) return;

    const group = slider.closest(".slider-group");
    if (group){
      group.classList.toggle("is-disabled", !isEnabled);
    }

    slider.disabled = !isEnabled;

    if (!isEnabled){
      slider.value = "50";
      const span = document.getElementById(defs[k].valId);
      if (span) span.textContent = "50";
    }
  }


  function clampVector(h, v, maxMag){
    let mag = Math.sqrt(h*h + v*v) || 0;
    if (mag > maxMag && mag > 0){
      const s = maxMag / mag;
      h *= s; v *= s; mag = maxMag;
    }
    return { h, v, mag };
  }

  function describeGaze(h, v){
    const mag = Math.sqrt(h*h + v*v);
    if (mag < 0.05) return "Primary position";

    const dirH = h > 0.12 ? "patient right" : (h < -0.12 ? "patient left" : "");
    const dirV = v > 0.12 ? "up" : (v < -0.12 ? "down" : "");

    if (dirH && dirV) return `${dirV} + ${dirH}`;
    if (dirH) return dirH;
    if (dirV) return dirV;
    return "Near primary";
  }

  function renderFromSliders(){
    const od = computeNetFromSliders('od');
    const os = computeNetFromSliders('os');

    // INO simulation via MLF lesion:
    // - Right MLF lesion: impaired right eye adduction on attempted patient-left gaze (h < 0).
    // - Left  MLF lesion: impaired left  eye adduction on attempted patient-right gaze (h > 0).
    // We treat state.gazeH/state.gazeV as the intended conjugate gaze command.
    const intendedH = state.gazeH;
    const intendedV = state.gazeV;

        const baseOD = computeBaselineOffset('od');
    const baseOS = computeBaselineOffset('os');

    let odH = od.h + baseOD.h, odV = od.v + baseOD.v;
    let osH = os.h + baseOS.h, osV = os.v + baseOS.v;

    ({ h: odH, v: odV } = clampVector(odH, odV, MAX_VECTOR_MAG));
    ({ h: osH, v: osV } = clampVector(osH, osV, MAX_VECTOR_MAG));

    const adductionLimit = 0.12; // small residual adduction allowed
    const gazeThresh = 0.12;

    const now = performance.now();

    // Dissociated abducting nystagmus (simple oscillation on abducting eye when INO present and in the provoking gaze).
    function nystagmusAmp(){
      const mag = Math.min(1, Math.abs(intendedH) / 1.2);
      return 0.11 * mag;
    }
    const freq = 6.5; // slower, more apparent

    if (mlf.right && intendedH < -gazeThresh){
      // Right eye should adduct (negative h). Limit adduction.
      odH = Math.max(odH, -adductionLimit);

      // Left eye is abducting: add nystagmus around its abducted position.
      osH = osH + Math.sin(now/1000 * (2*Math.PI*freq)) * nystagmusAmp();
    }

    if (mlf.left && intendedH > gazeThresh){
      // Left eye should adduct (positive h). Limit adduction.
      osH = Math.min(osH, adductionLimit);

      // Right eye is abducting: add nystagmus.
      odH = odH + Math.sin(now/1000 * (2*Math.PI*freq)) * nystagmusAmp();
    }

    ({ h: odH, v: odV } = clampVector(odH, odV, MAX_VECTOR_MAG));
    ({ h: osH, v: osV } = clampVector(osH, osV, MAX_VECTOR_MAG));

    renderEyes(odH, odV, osH, osV);

    // Drive a small animation loop only when nystagmus should be visible.
    const needAnim = (mlf.right && intendedH < -gazeThresh) || (mlf.left && intendedH > gazeThresh);
    setINOAnimating(needAnim);
  }


  let inoRAF = null;
  let inoAnimating = false;

  function setINOAnimating(on){
    if (on && !inoAnimating){
      inoAnimating = true;
      const tick = ()=>{
        if (!inoAnimating){ inoRAF = null; return; }
        // Re-render using current state/lesion effects.
        renderFromSliders();
        inoRAF = requestAnimationFrame(tick);
      };
      inoRAF = requestAnimationFrame(tick);
    } else if (!on && inoAnimating){
      inoAnimating = false;
      if (inoRAF){ cancelAnimationFrame(inoRAF); inoRAF = null; }
    }
  }

  function renderEyes(odHPatient, odVPatient, osHPatient, osVPatient){
    const od = clampVector(odHPatient, odVPatient, MAX_VECTOR_MAG);
    const os = clampVector(osHPatient, osVPatient, MAX_VECTOR_MAG);

    // Patient view: horizontal is flipped for on-screen rendering
    const odScreenH = -od.h;
    const osScreenH = -os.h;

    const odOffsetX = odScreenH * MAX_OFFSET_PX;
    const odOffsetY = -od.v * MAX_OFFSET_PX * VERTICAL_GAIN;

    const osOffsetX = osScreenH * MAX_OFFSET_PX;
    const osOffsetY = -os.v * MAX_OFFSET_PX * VERTICAL_GAIN;

    irisOD.style.transform = `translate(${odOffsetX.toFixed(1)}px, ${odOffsetY.toFixed(1)}px)`;
    irisOS.style.transform = `translate(${osOffsetX.toFixed(1)}px, ${osOffsetY.toFixed(1)}px)`;

    function updateArrow(line, vec){
      if (!line) return;
      if (vec.mag < 0.03){
        line.setAttribute("opacity","0.0");
      } else {
        line.setAttribute("opacity","1.0");
        line.setAttribute("x1", SVG_CENTER);
        line.setAttribute("y1", SVG_CENTER);
        line.setAttribute("x2", SVG_CENTER + (-vec.h) * ARROW_SCALE);  // screen H
        line.setAttribute("y2", SVG_CENTER - vec.v * ARROW_SCALE * VERTICAL_GAIN);
      }
    }
    updateArrow(netVectorRight, od);
    updateArrow(netVectorLeft, os);

    // Readout reflects the last commanded conjugate gaze (not necessarily perfectly conjugate with peripheral lesions)
    gazeReadout.textContent = describeGaze(state.gazeH, state.gazeV);
  }

  function computeNetFromSliders(eye){
    let netH = 0, netV = 0;
    const defs = (eye === "od") ? OD : OS;
    const sliders = (eye === "od") ? odSliders : osSliders;

    for (const k of Object.keys(defs)){
      const def = defs[k];
      const raw = Number(sliders[k].value);
      const isEnabled = enabled[eye][k];
      const delta = isEnabled ? ((raw - 50) / 50) : 0;

      const span = document.getElementById(def.valId);
      if (span) span.textContent = String(raw);

      netH += delta * def.horiz;
      netV += delta * def.vert;
    }
    const { h, v } = clampVector(netH, netV, MAX_VECTOR_MAG);
    return { h, v };
  }

  function computeBaselineOffset(eye){
    // Passive primary-position drift when muscles are disabled (e.g., CN palsy).
    // Uses the average of remaining muscles' direction vectors (so full set averages to ~0).
    let sumH = 0, sumV = 0, count = 0;
    const defs = (eye === "od") ? OD : OS;

    for (const k of Object.keys(defs)){
      if (enabled[eye][k]){
        sumH += defs[k].horiz;
        sumV += defs[k].vert;
        count++;
      }
    }
    if (count === 0) return { h: 0, v: 0 };

    const tonic = 1.30; // strength of passive drift
    const h0 = (sumH / count) * tonic;
    const v0 = (sumV / count) * tonic;

    return clampVector(h0, v0, MAX_VECTOR_MAG);
  }


  // Inverse mapping: gaze -> slider values (smooth)
  // hNorm, vNorm in [-1, 1] (patient-space)
  function gazeToODSliders(hNorm, vNorm){
    const base = 50;
    const clampVal = (x)=>Math.max(0, Math.min(100, x));

    const h = Math.max(-1, Math.min(1, hNorm||0));
    const v = Math.max(-1, Math.min(1, vNorm||0));
    const mag = Math.sqrt(h*h + v*v);
    const strength = Math.min(1, mag);

    const horizGain = 45;
    let mr = base - horizGain * h;
    let lr = base + horizGain * h;

    const vertGainRectus = 40;
    const vertGainOblique = 30;
    const abductionFactor = Math.max(0, h); // OD abduction in patient-right

    let sr=base, ir=base, so=base, io=base;

    if (v > 0.01){
      const rectusShare = 0.3 + 0.5 * abductionFactor; // more abduction -> SR dominates
      const obliqueShare = 1 - rectusShare;
      const extraRect = vertGainRectus * v * strength;
      const extraObl  = vertGainOblique * v * strength;
      sr = base + extraRect * rectusShare;
      io = base + extraObl  * obliqueShare;
      ir = base - 20 * v * strength;
      so = base - 10 * v * strength;
    } else if (v < -0.01){
      const vAbs = -v;
      const rectusShare = 0.3 + 0.5 * abductionFactor; // more abduction -> IR dominates
      const obliqueShare = 1 - rectusShare;
      const extraRect = vertGainRectus * vAbs * strength;
      const extraObl  = vertGainOblique * vAbs * strength;
      ir = base + extraRect * rectusShare;
      so = base + extraObl  * obliqueShare;
      sr = base - 20 * vAbs * strength;
      io = base - 10 * vAbs * strength;
    }

    if (Math.abs(v) < 0.15 * Math.max(strength, 0.15)){
      sr=(sr+base)/2; ir=(ir+base)/2; so=(so+base)/2; io=(io+base)/2;
    }

    return {
      mr: clampVal(mr), lr: clampVal(lr), sr: clampVal(sr), ir: clampVal(ir), so: clampVal(so), io: clampVal(io)
    };
  }

  function gazeToOSSliders(hNorm, vNorm){
    const base = 50;
    const clampVal = (x)=>Math.max(0, Math.min(100, x));

    const h = Math.max(-1, Math.min(1, hNorm||0));
    const v = Math.max(-1, Math.min(1, vNorm||0));
    const mag = Math.sqrt(h*h + v*v);
    const strength = Math.min(1, mag);

    const horizGain = 45;
    // OS horizontal is opposite of OD:
    // patient right (h>0) -> OS adduction (MR increases), OS LR decreases
    let mr = base + horizGain * h;
    let lr = base - horizGain * h;

    const vertGainRectus = 40;
    const vertGainOblique = 30;
    // OS abduction occurs in patient-left gaze (h<0)
    const abductionFactor = Math.max(0, -h);

    let sr=base, ir=base, so=base, io=base;

    if (v > 0.01){
      const rectusShare = 0.3 + 0.5 * abductionFactor; // more abduction (patient-left) -> SR dominates
      const obliqueShare = 1 - rectusShare;            // more adduction (patient-right) -> IO dominates
      const extraRect = vertGainRectus * v * strength;
      const extraObl  = vertGainOblique * v * strength;
      sr = base + extraRect * rectusShare;
      io = base + extraObl  * obliqueShare;
      ir = base - 20 * v * strength;
      so = base - 10 * v * strength;
    } else if (v < -0.01){
      const vAbs = -v;
      const rectusShare = 0.3 + 0.5 * abductionFactor; // more abduction -> IR dominates
      const obliqueShare = 1 - rectusShare;            // more adduction -> SO dominates
      const extraRect = vertGainRectus * vAbs * strength;
      const extraObl  = vertGainOblique * vAbs * strength;
      ir = base + extraRect * rectusShare;
      so = base + extraObl  * obliqueShare;
      sr = base - 20 * vAbs * strength;
      io = base - 10 * vAbs * strength;
    }

    if (Math.abs(v) < 0.15 * Math.max(strength, 0.15)){
      sr=(sr+base)/2; ir=(ir+base)/2; so=(so+base)/2; io=(io+base)/2;
    }

    return {
      mr: clampVal(mr), lr: clampVal(lr), sr: clampVal(sr), ir: clampVal(ir), so: clampVal(so), io: clampVal(io)
    };
  }

  function applySliders(eye, values){
    const defs = (eye === "od") ? OD : OS;
    const sliders = (eye === "od") ? odSliders : osSliders;
    for (const k of Object.keys(values)){
      const isEnabled = enabled[eye][k];
      sliders[k].value = String(isEnabled ? Math.round(values[k]) : 50);
      const span = document.getElementById(defs[k].valId);
      if (span) span.textContent = sliders[k].value;

      const group = sliders[k].closest('.slider-group');
      if (group){ group.classList.toggle('is-disabled', !isEnabled); }
      sliders[k].disabled = !isEnabled;
    }
  }

  function setGazeFromSliders(driverEye){
    if (state.isProgrammatic) return;
    state.lastDriver = driverEye;

    const { h, v } = computeNetFromSliders(driverEye);

    // Update conjugate gaze
    state.gazeH = h;
    state.gazeV = v;

    // Render from gaze
    renderFromSliders();

    // Update the opposite eye sliders to match the same gaze
    state.isProgrammatic = true;
    try{
      const maxNorm = 1.4; // same scale used in drag mapping
      const hNorm = Math.max(-1, Math.min(1, state.gazeH / maxNorm));
      const vNorm = Math.max(-1, Math.min(1, state.gazeV / maxNorm));

      if (driverEye === "od"){
        applySliders("os", gazeToOSSliders(hNorm, vNorm));
      } else {
        applySliders("od", gazeToODSliders(hNorm, vNorm));
      }
    } finally {
      state.isProgrammatic = false;
    }
  }

  function setGazeDirect(hNorm, vNorm){
    // hNorm, vNorm in [-1,1], patient-space
    const scale = GAZE_SCALE;
    state.gazeH = hNorm * scale;
    state.gazeV = vNorm * scale;
    state.lastDriver = "drag";

    renderFromSliders();

    state.isProgrammatic = true;
    try{
      applySliders("od", gazeToODSliders(hNorm, vNorm));
      applySliders("os", gazeToOSSliders(hNorm, vNorm));
    } finally {
      state.isProgrammatic = false;
    }
  }


  function openLesionModal(){
    if (!lesionModal) return;
    lesionModal.classList.add("show");
    lesionModal.setAttribute("aria-hidden","false");
  }

  function closeLesionModal(){
    if (!lesionModal) return;
    lesionModal.classList.remove("show");
    lesionModal.setAttribute("aria-hidden","true");
  }

  function syncLesionCheckbox(eye, k){
    const id = `lesion_${eye}_${k}`;
    const cb = document.getElementById(id);
    if (!cb) return;

    cb.checked = !!enabled[eye][k];

    cb.addEventListener("change", ()=>{
      setMuscleEnabled(eye, k, cb.checked);

      // Reapply the last command to refresh both sides and re-render.
      const hNorm = Math.max(-1, Math.min(1, state.gazeH / GAZE_SCALE));
      const vNorm = Math.max(-1, Math.min(1, state.gazeV / GAZE_SCALE));
      setGazeDirect(hNorm, vNorm);
});
  }

  function wireLesionUI(){
    const mlfRightCb = document.getElementById("lesion_mlf_right");
    const mlfLeftCb  = document.getElementById("lesion_mlf_left");
if (mlfRightCb){
      mlfRightCb.checked = !!mlf.right;
      mlfRightCb.addEventListener("change", ()=>{
        mlf.right = mlfRightCb.checked;
        renderFromSliders();
      });
    }
    if (mlfLeftCb){
      mlfLeftCb.checked = !!mlf.left;
      mlfLeftCb.addEventListener("change", ()=>{
        mlf.left = mlfLeftCb.checked;
        renderFromSliders();
      });
    }

    if (lesionBtn){
      lesionBtn.addEventListener("click", openLesionModal);
    }
    if (lesionClose){
      lesionClose.addEventListener("click", closeLesionModal);
    }
    if (lesionModal){
      lesionModal.addEventListener("click", (e)=>{
        if (e.target === lesionModal) closeLesionModal();
      });
      window.addEventListener("keydown", (e)=>{
        if (e.key === "Escape" && lesionModal.classList.contains("show")){
          closeLesionModal();
        }
      });
    }

    muscleKeys.forEach(k=>{
      syncLesionCheckbox("od", k);
      syncLesionCheckbox("os", k);
    });

    // Ensure initial UI reflects enabled state
    muscleKeys.forEach(k=>{
      setMuscleEnabled("od", k, true);
      setMuscleEnabled("os", k, true);
    });
}

  // Slider listeners
  Object.keys(OD).forEach(k=>{
    odSliders[k].addEventListener("input", ()=>setGazeFromSliders("od"));
    odSliders[k].addEventListener("change", ()=>setGazeFromSliders("od"));
  });
  Object.keys(OS).forEach(k=>{
    osSliders[k].addEventListener("input", ()=>setGazeFromSliders("os"));
    osSliders[k].addEventListener("change", ()=>setGazeFromSliders("os"));
  });

  // Drag: pointer dx screen-left should map to patient-right
  let isDragging = false;
  let activePointerId = null;
  let activeCircle = null;

  function handlePointer(e, circleElem){
    const rect = circleElem.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const maxDrag = rect.width * 0.40;

    const hNorm = Math.max(-1, Math.min(1, (-dx)/maxDrag));
    const vNorm = Math.max(-1, Math.min(1, (-dy)/maxDrag));

    setGazeDirect(hNorm, vNorm);
  }

  eyeCircles.forEach(circle=>{
    circle.addEventListener("pointerdown",(e)=>{
      isDragging = true;
      activePointerId = e.pointerId;
      activeCircle = circle;
      circle.classList.add("dragging");
      circle.setPointerCapture(e.pointerId);
      e.preventDefault();
      handlePointer(e, circle);
    });

    circle.addEventListener("pointermove",(e)=>{
      if (!isDragging || e.pointerId !== activePointerId) return;
      e.preventDefault();
      handlePointer(e, activeCircle);
    });

    const end = (e)=>{
      if (!isDragging || e.pointerId !== activePointerId) return;
      isDragging = false;
      if (activeCircle){
        activeCircle.classList.remove("dragging");
        try{ activeCircle.releasePointerCapture(e.pointerId); } catch(err){}
      }
      activePointerId = null;
      activeCircle = null;
    };

    circle.addEventListener("pointerup", end);
    circle.addEventListener("pointercancel", end);
    circle.addEventListener("pointerleave", end);
  });

  // Controls

// Initial state
  wireAskButtons();
  wireLesionUI();
  // Game mode wiring
  if (nameLesionBtn){
    nameLesionBtn.addEventListener("click", ()=>{
      if (game.active) exitGameMode();
      else enterGameMode();
    });
  }

  if (diagnosisSelect){
    diagnosisSelect.addEventListener("change", ()=>{
      if (!submitGuessBtn) return;
      submitGuessBtn.disabled = !(game.active && game.roundActive && !!diagnosisSelect.value);
    });
  }

  if (submitGuessBtn){
    submitGuessBtn.addEventListener("click", submitGuess);
  }

  if (gameNewRoundBtn){
    gameNewRoundBtn.addEventListener("click", ()=>{
      if (!game.active) return;
      startRound();
    });
  }

  if (revealLesionBtn){
    revealLesionBtn.addEventListener("click", ()=>{
      if (!game.active) return;
      openLesionModal();
    });
  }

  setGazeDirect(0,0);
</script>
</body>
</html>
