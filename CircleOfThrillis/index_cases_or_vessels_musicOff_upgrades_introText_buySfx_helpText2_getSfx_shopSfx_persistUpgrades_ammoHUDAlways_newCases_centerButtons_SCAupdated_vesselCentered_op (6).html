<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Circle of Thrillis: Clot Busters</title>
<link rel="icon" type="image/png" href="favicon.png" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0d10;
    --panel:#11151c;
    --ink:#e9eef5;
    --muted:#a9b6c7;
    --maze:#0a0a0a;
    --path:#0a0a0a;
    --line:#2a3342;
    --good:#3ddc97;
    --bad:#ff5c7a;
    --warn:#ffd166;
    --font-ui: "Orbitron", "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --font-body: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:var(--font-body);}
  .wrap{max-width:980px; margin:0 auto; padding:14px 12px 24px;}
  .title{display:flex; gap:10px; align-items:baseline; justify-content:flex-start; flex-wrap:wrap;}
  .title h1{font-family:var(--font-ui); font-size:19px; margin:0; letter-spacing:1px; text-transform:uppercase;}
  .title .meta{font-family:var(--font-ui); font-size:12px; color:var(--muted); letter-spacing:.6px;}
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px;
    padding:12px 12px;
    margin-top:0;
  }

  .layout{
    margin-top:12px;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:center;
  }
  .leftCol{
    width:min(420px, 92vw);
    flex:0 0 auto;
  }
  .leftActions{
    margin-top:10px;
    display:flex;
    width:100%;
    justify-content:center;
    align-items:center;
    gap: 8px;
    flex-wrap:nowrap;
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;
    padding-bottom:2px;
  }
  
  .creditBlurb{
    margin-top:8px;
    font-size:12px;
    opacity:0.65;
    text-align:center;
    width:100%;
    letter-spacing:0.2px;
    user-select:none;
    pointer-events:none;
  }
.rightCol{
    flex:1 1 520px;
    display:flex;
    justify-content:center;
  }
  @media (max-width: 860px){
    .layout{flex-direction:column; align-items:stretch;}
    .leftCol{width:100%;}
    .leftActions{justify-content:center;}
    .rightCol{justify-content:center;}
  }
  #stem{font-family:var(--font-body); font-size:clamp(18px, 2.2vw, 22px); line-height:1.5; margin:0; color:var(--ink);
  text-shadow: 0 0 10px rgba(0, 190, 255, 0.12);
}
#stem.isVesselPrompt{ text-align:center; }

  #logoImg{
    width:100%;
    max-width:320px;
    height:auto;
    display:block;
    margin:0 auto 10px;
    object-fit:contain;
    filter: drop-shadow(0 0 10px rgba(0,180,255,.25));
  }
  #stem strong{font-weight:750;}
  .game{
    margin-top:0;
    display:flex;
    justify-content:center;
    align-items:center;
  
    position:relative;
  }
  canvas{
    width:720px;
    height:720px;
    max-width:92vw;
    max-height:92vh;
    aspect-ratio: 1 / 1;
    border-radius:16px;
    background:#14161a;
    box-shadow:0 10px 30px rgba(0,0,0,.45), 0 0 0 4px rgba(0,180,255,.60), 0 0 22px rgba(0,180,255,.55), 0 0 50px rgba(0,90,255,.30);
    border:3px solid rgba(0,180,255,.90);
    image-rendering: pixelated;
    touch-action:none;
  }
  .kbd{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size:11px;
    padding:2px 6px;
    border-radius:7px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);
    color:var(--ink);
  }
  .iconBtn{
    cursor:pointer;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    color:var(--ink);
    border-radius:10px;
    padding:6px 10px;
    display:inline-flex;
    align-items:center;
    gap:8px;
  
    font-family:var(--font-ui);}
  .iconBtn:hover{background:rgba(255,255,255,.07);}
  .iconBtn:active{transform:translateY(1px);}
  .iconBtn svg{
    width:16px;
    height:16px;
    display:block;
    fill:none;
    stroke:currentColor;
    stroke-width:2.2;
    stroke-linecap:round;
    stroke-linejoin:round;
  }
  .modalBackdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.55);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
    z-index:50;
  }
  .modalBackdrop.hidden{display:none;}
  .hidden{display:none !important;}
  .modalBox{
    width:min(420px, 92vw);
    background:rgba(18,22,29,.98);
    border:1px solid rgba(255,255,255,.12);
    border-radius:16px;
    padding:14px 14px 12px;
    box-shadow:0 24px 70px rgba(0,0,0,.55);
  }
  .modalHead{
    display:flex;
    align-items:center;
    justify-content:flex-start;
    gap:10px;
    margin-bottom:12px;
  }
  .modalHead .h{font-weight:700; letter-spacing:.3px;
    font-family:var(--font-ui); letter-spacing:1px; text-transform:uppercase;}
  .toggleRow{
    display:flex;
    align-items:center;
    justify-content:flex-start;
    gap:10px;
    padding:10px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
  }
  .toggleRow span{color:var(--ink); font-size:14px;}
  .toggleRow input{width:20px; height:20px;}
  .modeRadios{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  .modeRadio{display:flex; gap:6px; align-items:center;}
  .modeRadio input{margin:0;}

  .modalHint{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }


  /* Shop */
  .shopTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:2px 0 10px;
  }
  .shopStat{
    font-family:var(--font-ui);
    font-size:12px;
    letter-spacing:.7px;
    text-transform:uppercase;
    color:rgba(233,238,245,.92);
  }
  .shopList{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .shopItem{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    padding:10px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
  }
  .shopItem .name{
    font-family:var(--font-ui);
    font-weight:800;
    letter-spacing:.9px;
    text-transform:uppercase;
    font-size:13px;
    margin:0;
  }
  .shopItem .desc{
    margin-top:4px;
    font-size:12px;
    color:var(--muted);
    line-height:1.35;
  }
  .shopMsg{
    margin-top:10px;
    min-height:16px;
    font-size:12px;
    color:var(--muted);
  }
  .shopMsg.bad{color:#ff8aa0;}
  .shopMsg.good{color:#7fffd4;}


  .gameOver{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }
  .gameOverBox{
    pointer-events:auto;
    padding:34px 42px;
    border-radius:22px;
    background: #000000;
    border: 3px solid #00b4ff;
    box-shadow: 0 0 18px rgba(0,180,255,.65), 0 0 52px rgba(0,90,255,.45);
    text-align:center;
    letter-spacing:.08em;
    width: min(560px, 86%);
  }
  .goTitle{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-weight: 900;
    font-size: 36px;
    color: #eaf6ff;
  }
  .goSub{
    margin-top:12px;
    font-size: 16px;
    color: rgba(234,246,255,.9);
    line-height: 1.4;

  .playAgainBtn{
    margin-top:10px;
    padding:10px 18px;
    border-radius:14px;
    border:2px solid #00b4ff;
    background: transparent;
    color:#eaf6ff;
    font-weight:900;
    font-size:16px;
    cursor:pointer;
    box-shadow: 0 0 12px rgba(0,180,255,.35);
    transition: transform .08s ease, box-shadow .12s ease;
  }
  .playAgainBtn:hover{ transform: translateY(-1px); box-shadow: 0 0 18px rgba(0,180,255,.45); }
  .playAgainBtn:active{ transform: translateY(0px); }
  }

  button{font-family:var(--font-ui); letter-spacing:.6px;}

  /* Instructions */
  .helpBody{
    margin-top:10px;
    color: var(--ink);
    font-family: var(--font-ui);
    font-size: 14px;
    line-height: 1.45;
  }
  .helpBody ul{
    margin: 10px 0 0 18px;
    padding: 0;
  }
  .helpBody li{
    margin: 6px 0;
    color: rgba(234,246,255,.95);
  }
  .helpFooter{
    display:flex;
    justify-content:center;
    margin-top:14px;
  }
  .okBtn{
    cursor:pointer;
    border:1px solid rgba(93,240,255,.38);
    background:rgba(93,240,255,.10);
    color:var(--ink);
    border-radius:12px;
    padding:10px 14px;
    font-weight:900;
    letter-spacing:1px;
    text-transform:uppercase;
  }
  .okBtn:hover{background:rgba(93,240,255,.16);}
  .okBtn:active{transform:translateY(1px);}


  /* Music */
  #musicCtl{
    display:none;
    opacity:0.92;
    margin-left:0;
    align-items:center;
    gap:6px;
    flex-wrap:nowrap;
    white-space:nowrap;
  }
  #musicCtl .iconBtn{
    padding:8px 12px;
    font-size:12px;
    backdrop-filter: blur(6px);
  }
</style>
</head>
<body>

<audio id="bgMusic" src="goodthemeedit.mp3" loop preload="auto"></audio>
<audio id="sfxExplosion" src="explosionQ.mp3" preload="auto"></audio>
<audio id="sfxEnemyExplosion" src="explosion.mp3" preload="auto"></audio>
<audio id="sfxLaser" src="laserQ.mp3" preload="auto"></audio>
<audio id="sfxWarp" src="warp.mp3" preload="auto"></audio>
<audio id="sfxBuy" src="buy.mp3" preload="auto"></audio>

<audio id="sfxGet" src="get.mp3" preload="auto"></audio>
<audio id="sfxShop" src="shop.mp3" preload="auto"></audio>

<audio id="sfxGameOver" src="gameover.mp3" preload="auto"></audio>
<audio id="sfxHit" src="gothit.mp3" preload="auto"></audio>
<div class="wrap">
<div class="layout">
    <div class="leftCol">
      <div class="panel">
    <img id="logoImg" src="logo.png" alt="Circle of Thrillis: Clot Busters" />
    <p id="stem"></p>
  </div>
      <div class="leftActions">
        <button id="btnSettings" class="iconBtn" type="button" aria-label="Options">Options</button>
        <button id="btnHow" class="iconBtn" type="button" aria-label="How to play">?</button>
<div id="musicCtl" aria-live="polite">
  <button id="musicBtn" class="iconBtn" type="button" aria-label="Toggle background music">â™« Music</button>
  <button id="sfxBtn" class="iconBtn" type="button" aria-label="Toggle sound effects">ðŸ”Š SFX: On</button>
</div>

      </div>
      <div class="creditBlurb">created by micah etter, md</div>
    </div>

    <div class="rightCol">
      <div class="game">
    <canvas id="c" width="720" height="720" aria-label="Circle of Thrillis: Clot Busters maze"></canvas>
    <div id="gameOver" class="gameOver hidden" aria-live="polite">
      <div class="gameOverBox">
        <div class="goTitle">GAME OVER</div>
        <div class="goSub"><button id="playAgainBtn" class="playAgainBtn" type="button">Play Again</button></div>
      </div>
    </div>
  </div>
    </div>
  </div>
</div>

  <!-- Settings modal -->
  <div id="settingsBackdrop" class="modalBackdrop hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modalBox">
      <div class="modalHead">
        <div class="h" id="settingsTitle">Options</div>
        <button id="btnCloseSettings" class="iconBtn" type="button" aria-label="Close settings">âœ•</button>
      </div>
      <label class="toggleRow">
        <span>Vessel labels</span>
        <input id="toggleLabels" type="checkbox" />
      </label>
      <label class="toggleRow" style="margin-top:10px;">
        <span>Enemies</span>
        <input id="toggleEnemies" type="checkbox" />
      </label>

      <div class="toggleRow" style="margin-top:10px; align-items:flex-start;">
        <span>Prompt mode</span>
        <div class="modeRadios" role="radiogroup" aria-label="Prompt mode">
          <label class="modeRadio">
            <input id="modeCases" type="radio" name="promptMode" value="cases" />
            <span>Cases</span>
          </label>
          <label class="modeRadio">
            <input id="modeVessels" type="radio" name="promptMode" value="vessels" />
            <span>Vessels</span>
          </label>
        </div>
      </div>

      <div style="margin-top:14px; display:flex; justify-content:center;">
  <button id="btnResetProgress" class="iconBtn" type="button" style="border-color: rgba(255,92,122,.55); background: rgba(255,92,122,.10);">Reset progress</button>
</div>

    </div>
  </div>

  <!-- Shop modal -->
  <div id="shopBackdrop" class="modalBackdrop hidden" role="dialog" aria-modal="true" aria-labelledby="shopTitle">
    <div class="modalBox">
      <div class="modalHead">
        <div class="h" id="shopTitle">Shop</div>
        <button id="btnCloseShop" class="iconBtn" type="button" aria-label="Close shop">âœ•</button>
      </div>

      <div class="shopTop">
        <div class="shopStat">Currency: ðŸ’Š <span id="shopCash">0</span></div>
        <div class="shopStat">Ammo: <span id="shopAmmo">0</span></div>
      </div>

      <div class="shopList">
        <div class="shopItem">
          <div class="left">
            <div class="name">Blaster Pack</div>
            <div class="desc">Adds 15 blaster shots. Press <b>Ctrl</b> to Fire.</div>
          </div>
          <div class="buy">
            <button id="buyBlaster" type="button">Buy (ðŸ’Š 6)</button>
          </div>
        </div>

        <div class="shopItem">
          <div class="left">
            <div class="name">Extra Heart</div>
            <div class="desc">Gain +1 life (max 5).</div>
          </div>
          <div class="buy">
            <button id="buyHeart" type="button">Buy (ðŸ’Š 4)</button>
          </div>
        </div>
        <div class="shopItem">
          <div class="left">
            <div class="name">Speed Booster</div>
            <div class="desc">Increase ship speed by 25%.</div>
          </div>
          <div class="buy">
            <button id="buyBooster" type="button">Buy (ðŸ’Š 12)</button>
          </div>
        </div>

        <div class="shopItem">
          <div class="left">
            <div class="name">Shield Armor</div>
            <div class="desc">Adds 1 armor charge that absorbs an enemy hit (max 3).</div>
          </div>
          <div class="buy">
            <button id="buyArmor" type="button">Buy (ðŸ’Š 10)</button>
          </div>
        </div>

        <div class="shopItem">
          <div class="left">
            <div class="name">Plasma Cannon</div>
            <div class="desc">Unlimited ammo.</div>
          </div>
          <div class="buy">
            <button id="buyPlasma" type="button">Buy (ðŸ’Š 50)</button>
          </div>
        </div>

        <div class="shopItem">
          <div class="left">
            <div class="name">Chrome Hull</div>
            <div class="desc">Invincible to enemy contact; ramming destroys ships.</div>
          </div>
          <div class="buy">
            <button id="buyChrome" type="button">Buy (ðŸ’Š 100)</button>
          </div>
        </div>

      </div>

      <div id="shopMsg" class="shopMsg"></div>
    </div>
  </div>


  <!-- Instructions modal -->
  <div id="helpBackdrop" class="modalBackdrop hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalBox" style="width:min(560px, 94vw);">
      <div class="modalHead">
        <div class="h" id="helpTitle">How to play</div>
      </div>
      <div class="helpBody">
        <div style="color:rgba(234,246,255,.92);">
          Navigate the Circle of Willis and bomb the correct clotted vessel!
        </div>
        <ul>
          <li><b>Move:</b> Arrow keys or WASD (swipe on touch devices).</li>
          <li><b>Bust:</b> Press <b>Space</b> to drop a <b>Buster Bomb</b> to bust the clot in the correct vessel!</li>
                    <li><b>Blaster:</b> Press <b>Ctrl</b> to fire. Buy more ammo in the shop.</li>
          <li><b>Health:</b> Bombing the wrong target costs a heart.</li>
          <li><b>Pills:</b> Collect the pills to buy upgrades.</li>
          <li><b>Shop:</b> Appears intermittently. Buy upgrades here!</li>
          <li><b>Options:</b> Use Options to toggle enemies, vessel labels, and prompt mode.</li>
        </ul>
        <div class="modalHint">Press <b>Esc</b> (or click <b>?</b>) any time to view these instructions again.</div>
      </div>
      <div class="helpFooter">
        <button id="btnHelpOk" class="okBtn" type="button">Okay</button>
      </div>
    </div>
  </div>


<script>
(() => {
  "use strict";

  // Hide the logo element if the local file isn't present.
  const _logoImg = document.getElementById("logoImg");
  if (_logoImg){
    _logoImg.addEventListener("error", () => { _logoImg.style.display = "none"; });
  }

  // =============================
  // Background music (goodthemeedit.mp3 in same directory)
  // =============================
  const bgMusic = document.getElementById("bgMusic");
  const musicCtl = document.getElementById("musicCtl");
  const musicBtn = document.getElementById("musicBtn");

  // Music toggle (persisted; default OFF)
  const MUSIC_KEY = "cot_music_enabled";
  let musicEnabled = false;
  try{
    const v = localStorage.getItem(MUSIC_KEY);
    if (v !== null) musicEnabled = (v === "1" || v === "true");
  } catch(_e){}


  const setMusicButtonLabel = () => {
    if (!musicBtn || !bgMusic) return;
    musicBtn.textContent = bgMusic.paused ? "â™« Music: Off" : "â™« Music: On";
  };

  const showMusicCtl = () => {
    if (!musicCtl) return;
    musicCtl.style.display = "flex";
    setMusicButtonLabel();
  };

  const hideMusicCtl = () => {
    if (!musicCtl) return;
    musicCtl.style.display = "none";
  };

  const tryPlayMusic = async () => {
    if (!bgMusic) return true;
    bgMusic.loop = true;
    if (typeof bgMusic.volume === "number") bgMusic.volume = 0.35;
    try{
      await bgMusic.play();
      showMusicCtl(); // keep a small on-screen toggle so users can pause if desired
      return true;
    } catch (e){
      // Autoplay is commonly blocked until user interaction.
      showMusicCtl();
      if (musicBtn) musicBtn.textContent = "â™« Enable music";
      return false;
    }
  };

  const toggleMusic = async (ev) => {
    if (ev) ev.stopPropagation();
    if (!bgMusic) return;

    if (bgMusic.paused){
      const ok = await tryPlayMusic();
      if (ok){
        musicEnabled = true;
        try { localStorage.setItem(MUSIC_KEY, "1"); } catch(_e){}
      }
      setMusicButtonLabel();
    } else {
      bgMusic.pause();
      musicEnabled = false;
      try { localStorage.setItem(MUSIC_KEY, "0"); } catch(_e){}
      showMusicCtl();
    }
  };

  if (musicBtn){
    musicBtn.addEventListener("click", toggleMusic);
  }

  // Sound effects toggle (persisted)
  const sfxBtn = document.getElementById("sfxBtn");
  const SFX_KEY = "cot_sfx_enabled";
  let sfxEnabled = true;
  try{
    const v = localStorage.getItem(SFX_KEY);
    if (v !== null) sfxEnabled = (v === "1" || v === "true");
  } catch(_e){}
  const setSfxButtonLabel = () => {
    if (!sfxBtn) return;
    sfxBtn.textContent = sfxEnabled ? "ðŸ”Š SFX: On" : "ðŸ”‡ SFX: Off";
  };
  const stopAllSfx = () => {
    try{
      if (typeof sfx !== "object" || !sfx) return;
      Object.values(sfx).forEach(p => {
        if (!p || !p.pool) return;
        p.pool.forEach(a => { try{ a.pause(); a.currentTime = 0; } catch(_e){} });
      });
    } catch(_e){}
  };
  const toggleSfx = (ev) => {
    if (ev) ev.stopPropagation();
    sfxEnabled = !sfxEnabled;
    try{ localStorage.setItem(SFX_KEY, sfxEnabled ? "1" : "0"); } catch(_e){}
    if (!sfxEnabled) stopAllSfx();
    setSfxButtonLabel();
  };
  if (sfxBtn){
    sfxBtn.addEventListener("click", toggleSfx);
    setSfxButtonLabel();
  }


  // Show the music/SFX controls, but default music to OFF unless the user enabled it previously.
  showMusicCtl();
  setMusicButtonLabel();

  // Only auto-start if the user previously enabled music.
  (async () => {
    if (!musicEnabled) return;
    const ok = await tryPlayMusic();
    if (!ok){
      const once = () => { tryPlayMusic(); };
      window.addEventListener("pointerdown", once, { once:true, passive:true });
      window.addEventListener("keydown",    once, { once:true });
    }
  })();
// =============================
  // Sound effects (explosionQ.mp3, explosion.mp3, laserQ.mp3, warp.mp3, gameover.mp3, gothit.mp3 in same directory)
  // =============================
  // sfxExplosion -> grenade detonation (explosionQ.mp3)
  // sfxEnemyExplosion -> enemy destroyed (explosion.mp3)
  const _sfxExplosionQBase    = document.getElementById("sfxExplosion");
  const _sfxEnemyExplosionBase = document.getElementById("sfxEnemyExplosion");
  const _sfxLaserBase         = document.getElementById("sfxLaser");
  const _sfxGameOverBase      = document.getElementById("sfxGameOver");
  const _sfxHitBase           = document.getElementById("sfxHit");
  const _sfxWarpBase          = document.getElementById("sfxWarp");
  const _sfxBuyBase           = document.getElementById("sfxBuy");
  const _sfxShopBase          = document.getElementById("sfxShop");
  const _sfxGetBase           = document.getElementById("sfxGet");

  const buildSfxPool = (baseEl, poolSize, volume) => {
    if (!baseEl) return { pool: [], idx: 0, volume };
    const pool = [baseEl];
    baseEl.volume = volume;
    baseEl.preload = "auto";
    for (let i = 1; i < poolSize; i++){
      const a = baseEl.cloneNode(true);
      // Keep clones out of the DOM; remove id to avoid accidental collisions.
      a.removeAttribute("id");
      a.volume = volume;
      a.preload = "auto";
      pool.push(a);
    }
    return { pool, idx: 0, volume };
  };

  const sfx = {
    explosionQ: buildSfxPool(_sfxExplosionQBase,        6, 0.70),
    explosion:  buildSfxPool(_sfxEnemyExplosionBase,   6, 0.70),
    laser:      buildSfxPool(_sfxLaserBase,        8, 0.45),
    warp:       buildSfxPool(_sfxWarpBase,         4, 0.55),
    buy:        buildSfxPool(_sfxBuyBase,          4, 0.65),
    shop:       buildSfxPool(_sfxShopBase,         2, 0.65),
    get:        buildSfxPool(_sfxGetBase,          6, 0.55),
    gameover:   buildSfxPool(_sfxGameOverBase,     2, 0.75),
    hit:        buildSfxPool(_sfxHitBase,          6, 0.60),
  };

  let sfxUnlocked = false;
  const unlockSfxOnce = () => {
    if (sfxUnlocked) return;
    sfxUnlocked = true;

    // Prime audio on first user gesture to reduce "play() failed" on mobile browsers.
    for (const key of Object.keys(sfx)){
      const a = sfx[key]?.pool?.[0];
      if (!a) continue;
      const prevMuted = a.muted;
      a.muted = true;
      try{
        const pr = a.play();
        if (pr && typeof pr.then === "function"){
          pr.then(() => {
            a.pause();
            a.currentTime = 0;
            a.muted = prevMuted;
          }).catch(() => { a.muted = prevMuted; });
        } else {
          a.pause();
          a.currentTime = 0;
          a.muted = prevMuted;
        }
      } catch (_e){
        a.muted = prevMuted;
      }
    }
  };

  window.addEventListener("pointerdown", unlockSfxOnce, { once:true, passive:true });
  window.addEventListener("keydown",     unlockSfxOnce, { once:true });

  const playSfx = (name) => {
        if (!sfxEnabled) return;
    const p = sfx[name];
    if (!p || !p.pool || p.pool.length === 0) return;
    const a = p.pool[p.idx];
    p.idx = (p.idx + 1) % p.pool.length;
    try{
      a.currentTime = 0;
      const pr = a.play();
      if (pr && typeof pr.catch === "function") pr.catch(() => {});
    } catch (_e){}
  };


  // =============================
  // Maze geometry (vector, PNG-free)
  // =============================
  const CW = 720, CH = 720;


  // Spawn padding to avoid edge artifacts
  const WALL_PAD = 18;
  // Thickness of "vessel corridors" (uniform everywhere)
  const T = 54;

  // Overlap to ensure corridors truly intersect for a non-zero-radius player
  const O = 18;

  // Utility
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));


  const wrap = (v, max)=>{
    v = v % max;
    if (v < 0) v += max;
    return v;
  };
  // Rects that form the walkable corridor (black vessel "walls" in your reference image)
  // This is an approximation of the provided Circle-of-Willis silhouette.
  const rects = [];
  const addRect = (x,y,w,h)=>rects.push({x,y,w,h});

  // Upper circulation: big "frame" + two ACA stalks + long lateral arms
  // Midline long horizontal bar (lateral arms)
  addRect(0, 240, CW, T);

  // Upper rectangle frame
  const upperX = 160, upperY = 120, upperW = 400, upperH = 120;
  addRect(upperX, upperY, upperW, T);                          // top
  addRect(upperX, upperY, T, upperH + T);                      // left side down to midline bar
  addRect(upperX + upperW - T, upperY, T, upperH + T);         // right side

  // ACA stalks (two vertical)
  addRect(270, 0, T, upperY + O);
  addRect(396, 0, T, upperY + O);

  // Lateral wrap tunnels (outer horizontal corridors): extend all the way to the playfield edge
  // and sit flush with the upper bar to avoid tiny misaligned corner stubs.
  addRect(0, upperY, upperX + O, T);
  addRect(upperX + upperW - O, upperY, CW - (upperX + upperW - O), T);

  // Basilar trunk (connects the CoW to the posterior circulation)
const trunkX = Math.round((CW - T)/2);

// Bottom "square" (junction box outline)
// Moved slightly upward so the vertebrals can descend to the bottom edge (as in your reference).
const sqOuterW = 180, sqOuterH = 200;
const sqY = 450;
const sqX = trunkX - Math.round((sqOuterW - T)/2);

// Basilar trunk goes from the posterior bar down into the square top.
// Use overlap so the ship (non-zero radius) can pass through intersections cleanly.
const trunkTopY = 240 + T - O;
const trunkBottomY = sqY + O;
addRect(trunkX, trunkTopY, T, trunkBottomY - trunkTopY);

// Square outline
addRect(sqX, sqY, sqOuterW, T);                               // top
addRect(sqX, sqY, T, sqOuterH);                               // left
addRect(sqX + sqOuterW - T, sqY, T, sqOuterH);                // right
// Cerebellar branches
// SCA + AICA connect directly to the basilar (rungs touch the trunk).
// Corridor thickness is uniform, so rung height == T.
const rungH = T;
const rungW = 150;

const rungY_SCA  = 315;
const rungY_AICA = 375;

for (const y of [rungY_SCA, rungY_AICA]){
  addRect(trunkX - rungW, y, rungW + O, rungH);   // left rung (overlaps trunk)
  addRect(trunkX + T - O, y, rungW + O, rungH);   // right rung (overlaps trunk)
}

// Vertebral arteries: descend to the bottom of the screen (as in the reference image)
const vertY0 = sqY + sqOuterH;
const vertYStart = vertY0 - O;
const vertH  = CH - vertYStart;
addRect(sqX,                vertYStart, T, vertH);                 // left VA column
addRect(sqX + sqOuterW - T, vertYStart, T, vertH);                 // right VA column

// PICA: comes off the vertebrals (not the basilar)
const picaY = sqY + 70;
const picaLen = 160;
addRect(sqX - picaLen,      picaY, picaLen + O, rungH);                // left PICA (overlaps left VA)
addRect(sqX + sqOuterW - O, picaY, picaLen + O, rungH);                // right PICA (overlaps right VA)

// NOTE: No anterior spinal artery in this maze (matches the reference silhouette).

// Build an offscreen "maze" bitmap for fast collision checks (corridors = black)
  const off = document.createElement("canvas");
  off.width = CW; off.height = CH;
  const og = off.getContext("2d", { alpha: false });
  og.fillStyle = "#f2f2f2";
  og.fillRect(0,0,CW,CH);
  og.fillStyle = "#000";
  for (const r of rects) og.fillRect(r.x, r.y, r.w, r.h);

  // Pixel mask for collision (1 byte per pixel)
  const mazeData = og.getImageData(0,0,CW,CH).data;
  const isWalkable = (px,py)=>{
    // Toroidal wrap: exiting one edge re-enters on the opposite edge.
    let x = px|0, y = py|0;
    x = ((x % CW) + CW) % CW;
    y = ((y % CH) + CH) % CH;
    const i = (y*CW + x)*4;
    // walkable if pixel is "black"
    return mazeData[i] < 32;
  };

  // Pre-render a neon "arcade" visual version of the maze (outer boundary only; no internal seam-lines)
  const mazeVis = document.createElement("canvas");
  mazeVis.width = CW; mazeVis.height = CH;
  const vg = mazeVis.getContext("2d"); // alpha true (glow compositing)

  // background (dark gray)
  vg.fillStyle = "#1b1f24";
  vg.fillRect(0,0,CW,CH);

  // corridors (near-black)
  vg.fillStyle = "#020203";
  for (const r of rects) vg.fillRect(r.x, r.y, r.w, r.h);

    // corridor interior shading (tube-like, subtle black/red)
  (()=>{
    const corrMask = document.createElement("canvas");
    corrMask.width = CW; corrMask.height = CH;
    const mg = corrMask.getContext("2d");
    mg.fillStyle = "#fff";
    for (const r of rects) mg.fillRect(r.x, r.y, r.w, r.h);

    const corrShade = document.createElement("canvas");
    corrShade.width = CW; corrShade.height = CH;
    const tg = corrShade.getContext("2d");

    // Identify junction overlaps between horizontal + vertical corridor rects,
    // so we can paint them ONCE (quadrant split) instead of letting gradients stack brighter.
    const junctions = [];
    const addJ = (x,y,w,h)=>{
      // de-dupe (few junctions, so O(n^2) is fine)
      for (const j of junctions){
        if (Math.abs(j.x-x)<2 && Math.abs(j.y-y)<2 && Math.abs(j.w-w)<2 && Math.abs(j.h-h)<2) return;
      }
      junctions.push({x,y,w,h});
    };
    for (let i=0;i<rects.length;i++){
      const a = rects[i];
      const ha = a.w >= a.h;
      for (let k=i+1;k<rects.length;k++){
        const b = rects[k];
        const hb = b.w >= b.h;
        if (ha === hb) continue; // want one horizontal + one vertical
        const ix = Math.max(a.x, b.x);
        const iy = Math.max(a.y, b.y);
        const ir = Math.min(a.x+a.w, b.x+b.w);
        const ib = Math.min(a.y+a.h, b.y+b.h);
        const iw = ir - ix;
        const ih = ib - iy;
        if (iw <= 0 || ih <= 0) continue;

        // Keep "true" junction-like overlaps (roughly square, about corridor thickness).
        const mn = Math.min(iw, ih);
        const mx = Math.max(iw, ih);
        if (mn >= T*0.55 && mx <= T*2.0) addJ(ix, iy, iw, ih);
      }
    }

    // Fill each corridor rect with a gradient perpendicular to its long axis.
    for (const r of rects){
      const horiz = r.w >= r.h;
      const g = horiz
        ? tg.createLinearGradient(0, r.y, 0, r.y + r.h)
        : tg.createLinearGradient(r.x, 0, r.x + r.w, 0);

      // darker edges, warmer center
      g.addColorStop(0.0, "rgb(0,0,0)");
      g.addColorStop(0.18,"rgb(14,0,0)");
      g.addColorStop(0.50,"rgb(28,3,3)");
      g.addColorStop(0.82,"rgb(14,0,0)");
      g.addColorStop(1.0, "rgb(0,0,0)");

      tg.fillStyle = g;
      tg.fillRect(r.x, r.y, r.w, r.h);

      // faint inner highlight line (gives a "tube" feel)
      tg.save();
      tg.globalAlpha = 0.05;
      tg.strokeStyle = "rgba(180,40,40,0.10)";
      tg.lineWidth = 1.5;
      if (horiz){
        const yy = r.y + r.h*0.42;
        tg.beginPath(); tg.moveTo(r.x+3, yy); tg.lineTo(r.x+r.w-3, yy); tg.stroke();
      } else {
        const xx = r.x + r.w*0.58;
        tg.beginPath(); tg.moveTo(xx, r.y+3); tg.lineTo(xx, r.y+r.h-3); tg.stroke();
      }
      tg.restore();
    }

    // Junction fix: repaint overlaps as a single quadrant-split "tube intersection" shading.
    // This prevents bright seams from multiple corridor gradients stacking at crossings.
    const paintJunction = (j)=>{
      const x = j.x, y = j.y, w = j.w, h = j.h;
      const cx = x + w/2, cy = y + h/2;

      const quads = [
        {qx:x,     qy:y,     qw:w/2, qh:h/2, sx:x,   sy:y},
        {qx:cx,    qy:y,     qw:w/2, qh:h/2, sx:x+w, sy:y},
        {qx:x,     qy:cy,    qw:w/2, qh:h/2, sx:x,   sy:y+h},
        {qx:cx,    qy:cy,    qw:w/2, qh:h/2, sx:x+w, sy:y+h},
      ];

      for (const q of quads){
        tg.save();
        tg.beginPath(); tg.rect(q.qx, q.qy, q.qw, q.qh); tg.clip();

        const g = tg.createLinearGradient(q.sx, q.sy, cx, cy);
        g.addColorStop(0.00, "rgb(0,0,0)");
        g.addColorStop(0.38, "rgb(10,0,0)");
        g.addColorStop(1.00, "rgb(24,3,3)");
        tg.fillStyle = g;
        tg.fillRect(q.qx, q.qy, q.qw, q.qh);

        tg.restore();
      }

      // Tiny center bloom so the intersection doesn't look "quartered"
      tg.save();
      tg.globalAlpha = 0.03;
      const rg = tg.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w,h)*0.55);
      rg.addColorStop(0.0, "rgba(80,10,10,0.35)");
      rg.addColorStop(1.0, "rgba(0,0,0,0)");
      tg.fillStyle = rg;
      tg.fillRect(x, y, w, h);
      tg.restore();
    };
    for (const j of junctions) paintJunction(j);

    // subtle noise speckles (red-tinted)
    let seed = 424242;
    const rand = ()=> (seed = (seed*1664525 + 1013904223) >>> 0) / 4294967296;
    const n = Math.floor((CW*CH)/12000);
    for (let i=0;i<n;i++){
      const x = (rand()*CW)|0;
      const y = (rand()*CH)|0;
      const a = 0.01 + rand()*0.015;
      tg.fillStyle = `rgba(120,20,20,${a})`;
      tg.fillRect(x, y, 1, 1);
    }

    // keep shading inside corridors only
    tg.globalCompositeOperation = "destination-in";
    tg.drawImage(corrMask, 0, 0);

    vg.save();
    vg.globalAlpha = 0.22;
    vg.drawImage(corrShade, 0, 0);
    vg.restore();
  })();;

// Build an edge image from the collision mask so ONLY the outer boundary glows.
  const edge = document.createElement("canvas");
  edge.width = CW; edge.height = CH;
  const eg = edge.getContext("2d");
  const edgeImg = eg.createImageData(CW,CH);
  const ed = edgeImg.data;

  const isCorr = (i)=>mazeData[i] < 32;

  // Portal zones: remove neon "walls" at wrap openings so tunnels look open.
  // We widen by 1px so the crisp outline (shifted copies) doesn't "re-seal" the mouth.
  const inPortalZone = (x,y)=>{
    // Horizontal wrap openings: upper lateral tunnel (MCA row) and posterior bar ends (PCA row)
    const inMcaY = (y >= upperY && y < upperY + T);
    const inPcaY = (y >= 240   && y < 240   + T);
    const inLeftPortal  = (x <= 1)      && (inMcaY || inPcaY);
    const inRightPortal = (x >= CW - 2) && (inMcaY || inPcaY);

    // Top wrap openings: ACA stalks
    const inAca1X = (x >= 270 && x < 270 + T);
    const inAca2X = (x >= 396 && x < 396 + T);
    const inTopPortal = (y <= 1) && (inAca1X || inAca2X);

    // Bottom wrap openings: vertebral arteries
    const inVaLX = (x >= sqX && x < sqX + T);
    const inVaRX = (x >= (sqX + sqOuterW - T) && x < (sqX + sqOuterW));
    const inBottomPortal = (y >= CH - 2) && (inVaLX || inVaRX);

    return inLeftPortal || inRightPortal || inTopPortal || inBottomPortal;
  };

  for (let y=0; y<CH; y++){
    for (let x=0; x<CW; x++){
      const i = (y*CW + x)*4;
      if (!isCorr(i)) continue;

      let edgePx = false;

      // Treat canvas border as an edge, EXCEPT at portal mouths (wrap openings).
      if (x===0 || x===CW-1 || y===0 || y===CH-1){
        edgePx = !inPortalZone(x,y);
      } else {
        const left  = i - 4;
        const right = i + 4;
        const up    = i - (CW*4);
        const down  = i + (CW*4);
        if (!isCorr(left) || !isCorr(right) || !isCorr(up) || !isCorr(down)) edgePx = true;
      }

      if (edgePx){
        ed[i]   = 255;
        ed[i+1] = 70;
        ed[i+2] = 70;
        ed[i+3] = 255;
      }
    }
  }
  eg.putImageData(edgeImg, 0, 0);

  // glow pass
  vg.save();
  vg.globalAlpha = 0.9;
  vg.shadowColor = "rgba(255, 55, 55, 0.95)";
  vg.shadowBlur = 22;
  vg.drawImage(edge, 0, 0);
  vg.restore();

  // crisp pass (slightly thicker)
  vg.save();
  const offsets = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx,dy] of offsets) vg.drawImage(edge, dx, dy);
  vg.restore();

// =============================
  // Game content
  // =============================
  const V = {
    L_ACA: "Left ACA",   R_ACA: "Right ACA",
    L_MCA: "Left MCA",   R_MCA: "Right MCA",
    L_PCA: "Left PCA",   R_PCA: "Right PCA",
    L_SCA: "Left SCA",   R_SCA: "Right SCA",
L_AICA: "Left AICA", R_AICA: "Right AICA",
    L_PICA: "Left PICA", R_PICA: "Right PICA",
// (Anterior spinal artery intentionally omitted)
  };

  // Distal "power pellets" (placed to match the silhouette)
const pellets = [
  {key:"L_ACA",   x:270 + T/2, y:18},
  {key:"R_ACA",   x:396 + T/2, y:18},

  // MCA distal: wrap tunnels (upper lateral arms)
  {key:"L_MCA",   x:18,        y:upperY + T/2},
  {key:"R_MCA",   x:CW-18,     y:upperY + T/2},

  // PCA distal: far ends of the posterior bar
  {key:"L_PCA",   x:18,        y:240 + T/2},
  {key:"R_PCA",   x:CW-18,     y:240 + T/2},

  {key:"L_SCA",   x:trunkX - rungW + 18,           y:rungY_SCA  + rungH/2},
  {key:"R_SCA",   x:trunkX + T + rungW - 18,       y:rungY_SCA  + rungH/2},

  {key:"L_AICA",  x:trunkX - rungW + 18,           y:rungY_AICA + rungH/2},
  {key:"R_AICA",  x:trunkX + T + rungW - 18,       y:rungY_AICA + rungH/2},

  {key:"L_PICA",  x:(sqX - picaLen) + 18,          y:picaY + rungH/2},
  {key:"R_PICA",  x:(sqX + sqOuterW + picaLen) - 18, y:picaY + rungH/2},
// (Anterior spinal artery pellet intentionally omitted)
];

  // Make distal "power pellets" look more like small blood clots (deterministic blobs)
  function _hash32(str){
    // FNV-1a
    let h = 2166136261;
    for (let i = 0; i < str.length; i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function _mulberry32(a){
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function _buildClotShape(seedStr){
    const rng = _mulberry32(_hash32(seedStr));
    const n = 14;
    const TAU = Math.PI * 2;

    const radii = [];
    for (let i = 0; i < n; i++){
      // jagged-ish silhouette
      const wobble = 0.70 + rng() * 0.55;          // 0.70â€“1.25
      const bump   = (rng() < 0.22) ? (0.20 + rng()*0.25) : 0; // occasional lobe
      radii.push((11.2 * wobble) * (1 + bump));
    }

    return {
      n,
      radii,
      // where the highlight sits (deterministic per pellet)
      hiAng: rng() * TAU,
      // small internal "fibrin" line angles
      fibrin: [rng()*TAU, rng()*TAU, rng()*TAU]
    };
  }

  // precompute shapes (stable across frames)
  for (const p of pellets){
    p._clot = _buildClotShape(`${p.key}:${Math.round(p.x)},${Math.round(p.y)}`);
  }

  function drawClotPellet(p){
    const s = p._clot || (p._clot = _buildClotShape(`${p.key}:${Math.round(p.x)},${Math.round(p.y)}`));
    const TAU = Math.PI * 2;

    ctx.save();
    ctx.translate(p.x, p.y);

    // main clot blob
    ctx.shadowColor = "rgba(180, 25, 45, 0.40)";
    ctx.shadowBlur = 10;

    const ptsX = new Array(s.n);
    const ptsY = new Array(s.n);
    for (let i=0; i<s.n; i++){
      const a = (i / s.n) * TAU;
      const r = s.radii[i];
      ptsX[i] = Math.cos(a) * r;
      ptsY[i] = Math.sin(a) * r;
    }

    ctx.beginPath();
    // smooth closed path using quadratic segments
    const xStart = (ptsX[0] + ptsX[s.n-1]) / 2;
    const yStart = (ptsY[0] + ptsY[s.n-1]) / 2;
    ctx.moveTo(xStart, yStart);
    for (let i=0; i<s.n; i++){
      const x1 = ptsX[i], y1 = ptsY[i];
      const x2 = ptsX[(i+1)%s.n], y2 = ptsY[(i+1)%s.n];
      const xc = (x1 + x2) / 2;
      const yc = (y1 + y2) / 2;
      ctx.quadraticCurveTo(x1, y1, xc, yc);
    }
    ctx.closePath();

    ctx.fillStyle = "#6b0f1a";
    ctx.fill();
    ctx.lineWidth = 1.6;
    ctx.strokeStyle = "rgba(255, 170, 190, 0.22)";
    ctx.stroke();

    // subtle highlight lobe
    ctx.save();
    ctx.globalAlpha = 0.65;
    const hx = Math.cos(s.hiAng) * 3.2;
    const hy = Math.sin(s.hiAng) * 3.2;
    ctx.translate(hx, hy);
    ctx.scale(0.62, 0.62);

    ctx.beginPath();
    ctx.moveTo((ptsX[0] + ptsX[s.n-1]) / 2, (ptsY[0] + ptsY[s.n-1]) / 2);
    for (let i=0; i<s.n; i++){
      const x1 = ptsX[i], y1 = ptsY[i];
      const x2 = ptsX[(i+1)%s.n], y2 = ptsY[(i+1)%s.n];
      const xc = (x1 + x2) / 2;
      const yc = (y1 + y2) / 2;
      ctx.quadraticCurveTo(x1, y1, xc, yc);
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(210, 55, 85, 0.55)";
    ctx.fill();
    ctx.restore();

    // fibrin-ish internal strands (very subtle)
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.lineWidth = 1.1;
    ctx.strokeStyle = "rgba(255, 210, 220, 0.45)";
    for (const a of s.fibrin){
      const r1 = 3.0, r2 = 9.6;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
      ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);
      ctx.stroke();
    }
    ctx.restore();

    ctx.restore();
  }

  // Case stems (territory-localizing)
const stems = {
  L_ACA: [
    "A 62-year-old man has sudden right leg weakness and numbness. He becomes very quiet and slow to respond, gives one- or two-word answers, and has new urinary incontinence.",
    "A 54-year-old woman develops acute right leg weakness. She cannot start walking even though she can move her legs in bed, and she repeatedly grasps the examinerâ€™s hand and cannot easily release.",
    "A 71-year-old man has sudden right leg weakness and veers to the right when trying to walk. He seems indifferent to the deficit, initiates very little on his own, and needs repeated prompting to participate."
  ],

  R_ACA: [
    "A 62-year-old woman has sudden left leg weakness and numbness. She becomes apathetic, responds slowly, initiates little on her own, and develops new urinary incontinence.",
    "A 48-year-old man develops acute left leg weakness. During tasks with both hands, his left hand grabs objects on its own and interferes with his intended actions, and he cannot stop it promptly.",
    "A 70-year-old woman has abrupt left leg weakness and falls toward the left. She sits quietly, rarely initiates movement, and appears unconcerned about the deficit despite repeated coaching."
  ],

  L_MCA: [
    "A 68-year-old man has sudden right facial droop and right arm weakness with right-sided numbness. He struggles to get words out and cannot repeat a simple phrase.",
    "A 59-year-old woman develops acute right arm weakness and right facial droop. She can speak fluently, but she cannot understand questions and follows commands poorly.",
    "A 72-year-old man has sudden right-sided weakness and numbness affecting the face and arm more than the leg. He also develops right-sided visual deficits and keeps turning his head to the left."
  ],

  R_MCA: [
    "A 69-year-old woman has acute left face and left arm weakness. She leaves food on the left side of the plate, fails to attend to her left arm, and insists nothing is wrong. Left leg weakness is mild.",
    "A 61-year-old man develops sudden left facial droop and left arm weakness with left-sided numbness. He ignores people standing on his left and bumps into objects on that side.",
    "A 74-year-old woman has abrupt left arm weakness and left-sided sensory loss. She cannot copy a simple drawing, cannot dress herself correctly, and denies that her left arm belongs to her."
  ],

  L_PCA: [
    "A 66-year-old man suddenly develops loss of vision on the right side of space in both eyes. He keeps turning his head to the right and is surprised when people approach from that side.",
    "A 58-year-old woman has abrupt right-sided numbness affecting the face, arm, and leg without clear weakness. Over the next week she develops severe burning pain on the right with light touch.",
    "A 71-year-old man develops sudden loss of vision on the right side of space in both eyes. He also cannot form new memories and repeatedly asks why he is in the hospital."
  ],

  R_PCA: [
    "A 64-year-old woman suddenly develops loss of vision on the left side of space in both eyes. She startles when people appear from her left and keeps scanning to that side.",
    "A 60-year-old man has abrupt loss of vision on the left side of space in both eyes. He recognizes objects but cannot recognize familiar faces, including close family members.",
    "A 69-year-old woman develops sudden left-sided numbness involving the face, arm, and leg without major weakness. Days later she reports constant painful tingling and burning on the left."
  ],

  L_SCA: [
    "A 64-year-old man develops sudden left ptosis and a â€œdown-and-outâ€ left eye with a dilated left pupil. He has prominent right limb ataxia and dysmetria but full strength.",
    "A 57-year-old woman has abrupt left oculomotor palsy (ptosis, impaired adduction/elevation) and a right-sided coarse tremor that worsens with action, plus right limb ataxia. Strength is largely preserved.",
    "A 71-year-old man has acute diplopia and left-sided ptosis, plus marked left-sided limb and gait ataxia and dysarthria, without sensory loss."
  ],

  R_SCA: [
    "A 64-year-old woman develops sudden right ptosis and a â€œdown-and-outâ€ right eye with a dilated right pupil. She has severe left limb ataxia and dysmetria with intact strength.",
    "A 55-year-old man has abrupt right oculomotor palsy and a prominent left-sided action tremor with left limb ataxia; speech is slurred but there is no aphasia.",
    "A 69-year-old woman develops acute diplopia and right-sided ptosis plus pronounced right-sided gait and limb ataxia, without primary weakness."
  ],

  L_AICA: [
    "A 67-year-old man develops sudden vertigo with vomiting and cannot stand without falling. He has new left hearing loss and left facial weakness.",
    "A 58-year-old woman has abrupt severe vertigo and nystagmus. She reports decreased hearing in the left ear, has numbness of the left face, and has difficulty with balance when walking.",
    "A 72-year-old man develops sudden vertigo and left-sided ataxia. He has left upper and lower facial weakness, decreased tearing on the left, and new hearing loss in the left ear."
  ],

  R_AICA: [
    "A 67-year-old woman develops sudden vertigo with vomiting and difficulty with balance. She has new right hearing loss and right facial weakness.",
    "A 56-year-old man has abrupt severe vertigo and nystagmus. He reports decreased hearing in the right ear, has numbness of the right face, and has difficulty with balance when walking.",
    "A 74-year-old woman develops sudden vertigo and right-sided ataxia. She has right upper and lower facial weakness, decreased tearing on the right, and new hearing loss in the right ear."
  ],

  L_PICA: [
    "A 62-year-old man develops sudden vertigo with vomiting and difficulty walking. He becomes hoarse and has significant difficulty with swallowing.",
    "A 55-year-old woman has abrupt vertigo and relentless hiccups. She has difficulty swallowing, her voice is raspy, and she has difficulty with coordination on the left.",
    "A 73-year-old man develops sudden vertigo and nausea with a left-sided gait and limb ataxia. He has left eyelid droop with a small pupil."
  ],

  R_PICA: [
    "A 62-year-old woman develops sudden vertigo with vomiting and cannot stand without falling. She has a hoarse voice and problems with choking and swallowing.",
    "A 57-year-old man has abrupt vertigo and persistent hiccups. He has difficulty swallowing and his voice becomes gravelly. He falls when attempting to walk.",
    "A 74-year-old woman develops sudden dizziness and nausea with right-sided gait and limb ataxia. She has right eyelid droop with a small pupil."
  ]
  // (Anterior spinal artery intentionally omitted)
};


    // Only include territories that have a corresponding distal pellet on the maze
  const vesselKeys = Array.from(new Set(pellets.map(p=>p.key)));

  // =============================
  // Canvas + drawing
  // =============================
  const canvas = document.getElementById("c");
  // =============================
  // Settings
  // =============================
  let showLabels = false;
  try { showLabels = JSON.parse(localStorage.getItem("plaqueMan_showLabels") || "false"); } catch(e){ showLabels = false; }


  let enemiesEnabled = true;
  try { enemiesEnabled = JSON.parse(localStorage.getItem("plaqueMan_enemiesEnabled") || "true"); } catch(e){ enemiesEnabled = true; }

  

  let promptMode = "cases";
  try { promptMode = (localStorage.getItem("plaqueMan_promptMode") || "cases"); } catch(e){ promptMode = "cases"; }
  if (promptMode !== "cases" && promptMode !== "vessels") promptMode = "cases";
const btnSettings = document.getElementById("btnSettings");
  const btnHow = document.getElementById("btnHow");
  const settingsBackdrop = document.getElementById("settingsBackdrop");
  const helpBackdrop = document.getElementById("helpBackdrop");
  const btnHelpOk = document.getElementById("btnHelpOk");
  const btnCloseSettings = document.getElementById("btnCloseSettings");
  const toggleLabels = document.getElementById("toggleLabels");
  const toggleEnemies = document.getElementById("toggleEnemies");
  const modeCases = document.getElementById("modeCases");
  const modeVessels = document.getElementById("modeVessels");
  const btnResetProgress = document.getElementById("btnResetProgress");

  // Shop UI
  const shopBackdrop = document.getElementById("shopBackdrop");
  const btnCloseShop = document.getElementById("btnCloseShop");
  const shopCashEl = document.getElementById("shopCash");
  const shopAmmoEl = document.getElementById("shopAmmo");
  const buyBlasterBtn = document.getElementById("buyBlaster");
  const buyHeartBtn = document.getElementById("buyHeart");
  const buyBoosterBtn = document.getElementById("buyBooster");
  const buyArmorBtn = document.getElementById("buyArmor");
  const buyPlasmaBtn = document.getElementById("buyPlasma");
  const buyChromeBtn = document.getElementById("buyChrome");
  const shopMsgEl = document.getElementById("shopMsg");

  const setShopMsg = (msg, kind="")=>{
    if (!shopMsgEl) return;
    shopMsgEl.textContent = msg || "";
    shopMsgEl.classList.remove("bad","good");
    if (kind) shopMsgEl.classList.add(kind);
  };

  const openSettings = ()=>{
    if (!settingsBackdrop) return;
    settingsBackdrop.classList.remove("hidden");
    if (toggleLabels) toggleLabels.checked = !!showLabels;
    if (toggleEnemies) toggleEnemies.checked = !!enemiesEnabled;
    if (modeCases) modeCases.checked = (promptMode === "cases");
    if (modeVessels) modeVessels.checked = (promptMode === "vessels");
    setShopMsg("");
  };
  const closeSettings = ()=>{
    if (!settingsBackdrop) return;
    settingsBackdrop.classList.add("hidden");
  };

  const openHelp = ()=>{
    if (!helpBackdrop) return;
    if (!helpBackdrop.classList.contains("hidden")) return;
    helpBackdrop.classList.remove("hidden");
    try { btnHelpOk && btnHelpOk.focus && btnHelpOk.focus(); } catch(e){}
  };
  const closeHelp = ()=>{
    if (!helpBackdrop) return;
    helpBackdrop.classList.add("hidden");
    // avoid any big dt jump after pausing in the modal
    try { last = performance.now(); } catch(e){}
    // clear held keys so you don't "launch" on close
    try { keys && keys.clear && keys.clear(); } catch(e){}
  };
  btnHelpOk?.addEventListener("click", closeHelp);


  const isUIPaused = () =>
    (settingsBackdrop && !settingsBackdrop.classList.contains("hidden")) ||
    (shopBackdrop && !shopBackdrop.classList.contains("hidden")) ||
    (helpBackdrop && !helpBackdrop.classList.contains("hidden"));

  const openShop = ()=>{
    if (!shopBackdrop) return;
    shopBackdrop.classList.remove("hidden");
    playSfx("shop");
    setShopMsg("");
    if (typeof refreshShopHUD === "function") refreshShopHUD();
  };
  const closeShop = ()=>{
    if (!shopBackdrop) return;
    shopBackdrop.classList.add("hidden");
    setShopMsg("");
  };

  btnSettings?.addEventListener("click", openSettings);
  btnHow?.addEventListener("click", ()=>{
    if (shopBackdrop && !shopBackdrop.classList.contains("hidden")) closeShop();
    if (settingsBackdrop && !settingsBackdrop.classList.contains("hidden")) closeSettings();
    openHelp();
  });

  btnCloseSettings?.addEventListener("click", closeSettings);
  settingsBackdrop?.addEventListener("click", (e)=>{ if (e.target === settingsBackdrop) closeSettings(); });

  btnResetProgress?.addEventListener("click", ()=>{
    const ok = confirm("Reset permanent upgrades and progress? This cannot be undone.");
    if (!ok) return;
    if (typeof resetProgress === "function") resetProgress();
  });
  window.addEventListener("keydown", (e)=>{
    if (e.key !== "Escape") return;
    e.preventDefault();
    if (shopBackdrop && !shopBackdrop.classList.contains("hidden")) closeShop();
    if (settingsBackdrop && !settingsBackdrop.classList.contains("hidden")) closeSettings();
    openHelp();
  }, {passive:false});

  toggleLabels?.addEventListener("change", ()=>{
    showLabels = !!toggleLabels.checked;
    try { localStorage.setItem("plaqueMan_showLabels", JSON.stringify(showLabels)); } catch(e){}
  });


  toggleEnemies?.addEventListener("change", ()=>{
    enemiesEnabled = !!toggleEnemies.checked;
    try { localStorage.setItem("plaqueMan_enemiesEnabled", JSON.stringify(enemiesEnabled)); } catch(e){}
    if (enemiesEnabled){
      if (typeof initEnemies === "function") initEnemies();
    } else {
      if (typeof enemies !== "undefined" && enemies && enemies.length !== undefined) enemies.length = 0;
    }
  });


  const setPromptMode = (mode)=>{
    promptMode = (mode === "vessels") ? "vessels" : "cases";
    try { localStorage.setItem("plaqueMan_promptMode", promptMode); } catch(e){}
    // Update the on-screen prompt without changing the active answer key
    try { if (typeof renderPrompt === "function") renderPrompt(); } catch(e){}
  };

  modeCases?.addEventListener("change", ()=>{ if (modeCases && modeCases.checked) setPromptMode("cases"); });
  modeVessels?.addEventListener("change", ()=>{ if (modeVessels && modeVessels.checked) setPromptMode("vessels"); });

  btnCloseShop?.addEventListener("click", closeShop);
  shopBackdrop?.addEventListener("click", (e)=>{ if (e.target === shopBackdrop) closeShop(); });

  buyBlasterBtn?.addEventListener("click", ()=>{ if (typeof buyBlasterPack === "function") buyBlasterPack(); });
  buyHeartBtn?.addEventListener("click", ()=>{ if (typeof buyHeart === "function") buyHeart(); });

  buyBoosterBtn?.addEventListener("click", ()=>{ if (typeof buyBooster === "function") buyBooster(); });
  buyArmorBtn?.addEventListener("click", ()=>{ if (typeof buyArmor === "function") buyArmor(); });
  buyPlasmaBtn?.addEventListener("click", ()=>{ if (typeof buyPlasma === "function") buyPlasma(); });
  buyChromeBtn?.addEventListener("click", ()=>{ if (typeof buyChromeHull === "function") buyChromeHull(); });

  const ctx = canvas.getContext("2d", { alpha: false });
const fitCanvasCSS = () => {
  // Keep the entire maze visible without scrolling:
  // fit to the smaller of (available viewport height below the canvas top) and width.
  const rect = canvas.getBoundingClientRect();
  const availH = Math.max(320, window.innerHeight - rect.top - 16);
  const availW = Math.max(320, window.innerWidth * 0.92);
  const size = Math.min(720, availH, availW);
  canvas.style.width = size + "px";
  canvas.style.height = size + "px";
};
window.addEventListener("resize", fitCanvasCSS, {passive:true});
// run after layout
requestAnimationFrame(fitCanvasCSS);
setTimeout(fitCanvasCSS, 50); 

  // Pre-rendered maze background
  const mazeImg = mazeVis; // neon pre-rendered

  function forEachWrappedCopy(x,y,pad,cb){
  const xs = [x], ys = [y];
  if (x < pad) xs.push(x + CW);
  if (x > CW - pad) xs.push(x - CW);
  if (y < pad) ys.push(y + CH);
  if (y > CH - pad) ys.push(y - CH);
  for (const xx of xs){
    for (const yy of ys){
      cb(xx,yy);
    }
  }
}

function drawShip(x,y,dir,phase=0.0){
  // dir: 0R 1D 2L 3U
  const ang = [0, Math.PI/2, Math.PI, -Math.PI/2][dir] ?? 0;
  const r = 13;

  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(ang);

  // body
  ctx.beginPath();
  ctx.moveTo(r, 0);
  ctx.lineTo(-r*0.85, -r*0.65);
  ctx.lineTo(-r*0.55, 0);
  ctx.lineTo(-r*0.85, r*0.65);
  ctx.closePath();
  ctx.fillStyle = chromeHull ? "#d8dde7" : "#a7d9ff";
  ctx.fill();
  if (chromeHull){
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.stroke();
  }

  // cockpit
  ctx.beginPath();
  ctx.arc(-r*0.1, 0, r*0.18, 0, Math.PI*2);
  ctx.fillStyle = "#0b0d10";
  ctx.fill();

  // thrust flicker
  const flick = 0.35 + 0.65*Math.abs(Math.sin(phase*6.283185307179586));
  ctx.beginPath();
  ctx.moveTo(-r*0.95, 0);
  ctx.lineTo(-r*1.35, -r*0.25*flick);
  ctx.lineTo(-r*1.35, r*0.25*flick);
  ctx.closePath();
  ctx.fillStyle = "#ffcf33";
  ctx.fill();

  ctx.restore();
}

function drawShipWrapped(x,y,dir,phase){
  const pad = 24;
  forEachWrappedCopy(x,y,pad,(xx,yy)=> drawShip(xx,yy,dir,phase));
}

  function drawLabels(){
    ctx.save();
    ctx.font = "700 24px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ff2d2d";
    ctx.strokeStyle = "rgba(0,0,0,0.65)";
    ctx.lineWidth = 5;
    ctx.shadowColor = "rgba(255, 40, 40, 0.95)";
    ctx.shadowBlur = 18;

    const label = (t,x,y,align="left")=>{
      ctx.textAlign = align;
      ctx.strokeText(t, x, y);
      ctx.fillText(t, x, y);
    };

    // Approximate placements to match the reference screenshot
    label("L ACA", 270 + T/2, 86, "center");
    label("R ACA", 396 + T/2, 86, "center");

    label("L MCA", 36, upperY + T/2, "left");
    label("R MCA", CW-36, upperY + T/2, "right");

    label("L PCA", 36, 240 + T/2, "left");
    label("R PCA", CW-36, 240 + T/2, "right");

    const OUT = 58;

    label("L SCA",  trunkX - rungW - OUT, rungY_SCA  + rungH/2, "right");
    label("R SCA",  trunkX + T + rungW + OUT, rungY_SCA  + rungH/2, "left");

    label("L AICA", trunkX - rungW - OUT, rungY_AICA + rungH/2, "right");
    label("R AICA", trunkX + T + rungW + OUT, rungY_AICA + rungH/2, "left");

    label("L PICA", 36, picaY + rungH/2, "left");
    label("R PICA", CW-36, picaY + rungH/2, "right");

    ctx.restore();
  }

  function draw(){
  // background
  ctx.drawImage(mazeImg,0,0);

  if (showLabels) drawLabels();

  // pellets (activation requires a grenade explosion)
  for (const p of pellets){
    drawClotPellet(p);
  }


  // currency pills
  for (const c of loot){
    ctx.save();
    ctx.shadowColor = "rgba(0, 255, 255, 0.70)";
    ctx.shadowBlur = 12;
    const w = 16, h = 9;
    ctx.translate(c.x, c.y);
    ctx.rotate(0.25);

    // capsule outline path
    ctx.beginPath();
    const r = h/2;
    ctx.moveTo(-w/2 + r, -h/2);
    ctx.lineTo(w/2 - r, -h/2);
    ctx.arc(w/2 - r, 0, r, -Math.PI/2, Math.PI/2);
    ctx.lineTo(-w/2 + r, h/2);
    ctx.arc(-w/2 + r, 0, r, Math.PI/2, -Math.PI/2);
    ctx.closePath();

    ctx.fillStyle = "#0b0b0b";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#8ff6ff";
    ctx.stroke();

    // left half
    ctx.save();
    ctx.beginPath();
    ctx.rect(-w/2 + 1.2, -h/2 + 1.2, w/2 - 1.8, h - 2.4);
    ctx.clip();
    ctx.beginPath();
    ctx.moveTo(-w/2 + r, -h/2);
    ctx.lineTo(w/2 - r, -h/2);
    ctx.arc(w/2 - r, 0, r, -Math.PI/2, Math.PI/2);
    ctx.lineTo(-w/2 + r, h/2);
    ctx.arc(-w/2 + r, 0, r, Math.PI/2, -Math.PI/2);
    ctx.closePath();
    ctx.fillStyle = "#b7fff0";
    ctx.fill();
    ctx.restore();

    // right half
    ctx.save();
    ctx.beginPath();
    ctx.rect(0.6, -h/2 + 1.2, w/2 - 1.8, h - 2.4);
    ctx.clip();
    ctx.beginPath();
    ctx.moveTo(-w/2 + r, -h/2);
    ctx.lineTo(w/2 - r, -h/2);
    ctx.arc(w/2 - r, 0, r, -Math.PI/2, Math.PI/2);
    ctx.lineTo(-w/2 + r, h/2);
    ctx.arc(-w/2 + r, 0, r, Math.PI/2, -Math.PI/2);
    ctx.closePath();
    ctx.fillStyle = "#5df0ff";
    ctx.fill();
    ctx.restore();

    // seam
    ctx.beginPath();
    ctx.moveTo(0, -h/2 + 1.5);
    ctx.lineTo(0, h/2 - 1.5);
    ctx.strokeStyle = "rgba(0,0,0,0.45)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.restore();
  }


  // shop icon (appears periodically)
  if (shopIcon && shopIcon.active){
    drawShopIconWrapped(shopIcon, tNow);
  }

  // blaster shots
  for (const s of shots){
    drawShotWrapped(s, tNow);
  }

  // grenades
  for (const g of grenades){
    const age01 = clamp((tNow - g.t0)/GRENADE_FUSE_MS, 0, 1);
    // Grenade visuals do NOT wrap across borders (matches non-wrapping explosions).
    drawGrenade(g.x, g.y, age01);
  }

  // explosions
  for (const ex of explosions){
    const a = clamp((tNow - ex.t0)/EXPLOSION_MS, 0, 1);
    const r = EXPLOSION_R * (0.55 + 0.85*a);
    const alpha = (1-a) * 0.55;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#ffcf33";
    // Explosion visuals do NOT wrap across borders.
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, r, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // enemies
  if (enemiesEnabled){
    for (const e of enemies){
      if (!e.alive) continue;
      drawEnemyWrapped(e, tNow);
    }
  }

  // enemy destruction bursts
  for (let i = enemyBursts.length - 1; i >= 0; i--){
    const b = enemyBursts[i];
    if ((tNow - b.t0) >= b.dur) { enemyBursts.splice(i, 1); continue; }
    drawEnemyBurst(b, tNow);
  }

  // player ship
  drawShipWrapped(player.x, player.y, player.dir, player.mouth);

  // lives HUD (top-left, inside the playfield)
  ctx.save();
  const hearts = "â¤ï¸".repeat(Math.max(0, lives));
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = '20px "Orbitron", "Share Tech Mono", ui-monospace, monospace';
  ctx.shadowColor = "rgba(255, 60, 120, 0.85)";
  ctx.shadowBlur = 14;
  ctx.fillStyle = "#ffffff";
  ctx.fillText(hearts, 22, 18);
  // cash HUD (under hearts)
  ctx.shadowColor = "rgba(0, 190, 255, 0.85)";
  ctx.shadowBlur = 18;
  ctx.font = '16px "Orbitron", "Share Tech Mono", ui-monospace, monospace';
  ctx.fillStyle = "#e9fbff";
  ctx.fillText("ðŸ’Š " + String(cash), 22, 44);
  // ammo HUD (under currency). Always shown (0 is still informative).
  ctx.shadowColor = "rgba(0, 255, 210, 0.90)";
  ctx.shadowBlur = 18;
  ctx.font = '14px "Orbitron", "Share Tech Mono", ui-monospace, monospace';
  ctx.fillStyle = "#ddfff7";
  const ammoLabel = unlimitedAmmo ? "âˆž" : String(ammo);
  ctx.fillText("ðŸ”« " + ammoLabel, 22, 66);


  // armor HUD (under ammo)
  if (armor > 0){
    ctx.shadowColor = "rgba(160, 210, 255, 0.85)";
    ctx.shadowBlur = 14;
    ctx.font = '14px "Orbitron", "Share Tech Mono", ui-monospace, monospace';
    ctx.fillStyle = "#eef9ff";
    ctx.fillText("ðŸ›¡ï¸ " + String(armor), 22, 88);
  }
  // score HUD (top-right, inside the playfield)
  ctx.textAlign = "right";
  ctx.textBaseline = "top";
  ctx.shadowColor = "rgba(0, 180, 255, 0.95)";
  ctx.shadowBlur = 20;
  ctx.font = '18px "Orbitron", "Share Tech Mono", ui-monospace, monospace';
  ctx.fillStyle = "#eaf6ff";
  ctx.fillText("Score: " + String(score), CW - 22, 18);
  ctx.restore();

}

  // =============================
  // Movement + collision
  // =============================
  const keys = new Set();
  window.addEventListener("keydown", (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowup","arrowdown","arrowleft","arrowright"," ","w","a","s","d"].includes(k)) e.preventDefault();

  if (isUIPaused()) return;

  if (k === " "){
    dropGrenade();
    return;
  }

  if (k === "control"){
    fireShot();
    return;
  }

  keys.add(k);
  if (k === "n") {
    if (gameOver) restartGame();
    else newCase();
  }
}, {passive:false});

  window.addEventListener("keyup", (e)=>{
    keys.delete(e.key.toLowerCase());
  });

  // Touch joystick (simple swipe)
  let touchStart = null;
  canvas.addEventListener("touchstart", (e)=>{
    if (isUIPaused()) return;
    if (!e.touches || e.touches.length!==1) return;
    const t = e.touches[0];
    touchStart = {x:t.clientX, y:t.clientY};
  }, {passive:true});
  canvas.addEventListener("touchend", (e)=>{
    if (isUIPaused()) return;
    if (!touchStart) return;
    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!t) return;
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    touchStart = null;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax,ay) < 16){ dropGrenade(); return; }
    if (ax > ay){
      queueDir(dx>0 ? 0 : 2);
    } else {
      queueDir(dy>0 ? 1 : 3);
    }
  }, {passive:true});

  const start = {x: trunkX + T/2, y: sqY + T/2};

  const player = {
    x: start.x,
    y: start.y,
    r: 9,
    dir: 0,
    want: 0,
    mouth: 0.34
  };

  function resetPlayer(){
    player.x = start.x;
    player.y = start.y;
    player.dir = 0;
    player.want = 0;
  }


  // =============================
  // Currency pills (2 on the maze at all times)
  // Collect by touching OR by grenade explosion
  // =============================
  const LOOT_COUNT = 2;
  const LOOT_R = 7;
  const loot = []; // {x,y,val}


  // =============================
  // Shop icon (spawns periodically)
  // =============================
  const SHOP_SPAWN_MS = 30000;
  const SHOP_LIFETIME_MS = 12000;
  const SHOP_R = 12;
  const shopIcon = {active:false, x:0, y:0, expiresAt:0};
  let nextShopSpawnAt = performance.now() + SHOP_SPAWN_MS;

  // =============================
  // Enemies (2 per screen)
  // =============================
  const ENEMY_COUNT = 2;
  const ENEMY_R = 9;
  const ENEMY_SPEED = 165;
  const ENEMY_RESPAWN_BASE = 2600;
  const ENEMY_RESPAWN_JITTER = 900;
  const ENEMY_HIT_RESPAWN_BASE = 1900;
  const ENEMY_HIT_RESPAWN_JITTER = 800;
  const enemies = []; // {x,y,r,dir,nextDecisionAt,alive,respawnAt,phase}
  const enemyBursts = []; // {x,y,t0,dur}

  function spawnEnemyBurst(x,y,now){
    enemyBursts.push({x, y, t0: now, dur: 260});
    if (enemyBursts.length > 24) enemyBursts.shift();
  }


  // For collisions in a wrapping playfield (movement wraps; explosions do NOT)
  function dist2Wrap(x1,y1,x2,y2){
    let dx = Math.abs(x1-x2);
    dx = Math.min(dx, CW - dx);
    let dy = Math.abs(y1-y2);
    dy = Math.min(dy, CH - dy);
    return dx*dx + dy*dy;
  }

  function reverseDir(d){ return (d + 2) & 3; }

  function possibleDirsAt(x,y,r){
    const step = 10;
    const out = [];
    for (let d=0; d<4; d++){
      let dx=0, dy=0;
      if (d===0) dx=1;
      if (d===2) dx=-1;
      if (d===1) dy=1;
      if (d===3) dy=-1;
      const nx = wrap(x + dx*step, CW);
      const ny = wrap(y + dy*step, CH);
      if (canMove(d, nx, ny, r)) out.push(d);
    }
    return out;
  }


  function spawnEnemyFromEdge(){
    const now = performance.now();
    // Entry points are the open wrap mouths / exits on the silhouette
    const pts = [
      // Horizontal wrap tunnels (left/right)
      {x: ENEMY_R + 2,      y: upperY + T*0.5, dir: 0}, // left MCA tunnel -> right
      {x: CW - ENEMY_R - 2, y: upperY + T*0.5, dir: 2}, // right MCA tunnel -> left
      {x: ENEMY_R + 2,      y: 240 + T*0.5,    dir: 0}, // left posterior bar -> right
      {x: CW - ENEMY_R - 2, y: 240 + T*0.5,    dir: 2}, // right posterior bar -> left

      // Top exits (ACA stalks)
      {x: 270 + T*0.5,      y: ENEMY_R + 2,    dir: 1}, // top left ACA -> down
      {x: 396 + T*0.5,      y: ENEMY_R + 2,    dir: 1}, // top right ACA -> down

      // Bottom exits (vertebral columns)
      {x: sqX + T*0.5,              y: CH - ENEMY_R - 2, dir: 3}, // bottom left -> up
      {x: (sqX + sqOuterW - T) + T*0.5, y: CH - ENEMY_R - 2, dir: 3}, // bottom right -> up
    ];

    // Shuffle for variety
    for (let i = pts.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      const tmp = pts[i]; pts[i] = pts[j]; pts[j] = tmp;
    }

    const order = pts.slice();
    for (let i = order.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      const tmp = order[i]; order[i] = order[j]; order[j] = tmp;
    }

    for (const p of order){
      const x = p.x, y = p.y;

      if (!circleFitsOnMaze(x, y, ENEMY_R + 2)) continue;
      if (tooCloseToPellets(x, y)) continue;
      if (typeof tooCloseToLoot === "function" && tooCloseToLoot(x, y)) continue;

      // Keep away from the player a bit
      if (dist2Wrap(x, y, player.x, player.y) < (140*140)) continue;

      // Keep away from other enemies
      let ok = true;
      for (const e of enemies){
        if (e.alive && dist2Wrap(x, y, e.x, e.y) < (90*90)) { ok = false; break; }
      }
      if (!ok) continue;

      return {
        x, y,
        r: ENEMY_R,
        dir: p.dir,
        // Give them time to "enter" before making intersection decisions
        nextDecisionAt: now + 900 + Math.random()*450,
        alive: true,
        respawnAt: 0,
        phase: Math.random()*10
      };
    }
    return null;
  }

  function spawnEnemy(){
    // Prefer edge entry (requirement: respawns enter from edges)
    const e = spawnEnemyFromEdge();
    if (e) return e;

    // Fallback: random (should rarely be used)
    for (let tries = 0; tries < 900; tries++){
      const x = Math.random() * (CW - 2*ENEMY_R) + ENEMY_R;
      const y = Math.random() * (CH - 2*ENEMY_R) + ENEMY_R;

      if (!circleFitsOnMaze(x,y,ENEMY_R+2)) continue;
      if (tooCloseToPellets(x,y)) continue;
      if (typeof tooCloseToLoot === "function" && tooCloseToLoot(x,y)) continue;
      if (dist2Wrap(x,y,player.x,player.y) < (150*150)) continue;

      let ok = true;
      for (const ee of enemies){
        if (ee.alive && dist2Wrap(x,y,ee.x,ee.y) < (90*90)) { ok = false; break; }
      }
      if (!ok) continue;

      const dir = (Math.random()*4)|0;
      return {x, y, r: ENEMY_R, dir, nextDecisionAt: performance.now() + 250 + Math.random()*650, alive:true, respawnAt:0, phase: Math.random()*10};
    }

    return {x: start.x, y: start.y, r: ENEMY_R, dir:2, nextDecisionAt: performance.now()+400, alive:true, respawnAt:0, phase: Math.random()*10};
  }


  function initEnemies(){
    enemies.length = 0;
    for (let i=0; i<ENEMY_COUNT; i++){
      enemies.push(spawnEnemy());
    }
  }

  function updateEnemies(dt, now){
    for (const e of enemies){
      if (!e.alive){
        if (now >= e.respawnAt){
          const ne = spawnEnemyFromEdge() || spawnEnemy();
          e.x = ne.x; e.y = ne.y; e.dir = ne.dir;
          e.nextDecisionAt = now + 220 + Math.random()*720;
          e.alive = true;
        }
        continue;
      }

      const opts = possibleDirsAt(e.x, e.y, e.r);
      if (opts.length === 0) continue;

      if (!opts.includes(e.dir)){
        e.dir = opts[(Math.random()*opts.length)|0];
        e.nextDecisionAt = now + 240 + Math.random()*700;
      } else if (opts.length >= 3 && now >= e.nextDecisionAt){
        // intersection: prefer not to reverse unless forced
        const rev = reverseDir(e.dir);
        let choices = opts.filter(d=>d!==rev);
        if (choices.length === 0) choices = opts;
        // usually keep going, sometimes turn
        if (Math.random() < 0.35){
          e.dir = choices[(Math.random()*choices.length)|0];
        }
        e.nextDecisionAt = now + 260 + Math.random()*760;
      }

      let dx=0, dy=0;
      if (e.dir===0) dx=1;
      if (e.dir===2) dx=-1;
      if (e.dir===1) dy=1;
      if (e.dir===3) dy=-1;

      const nx = wrap(e.x + dx*ENEMY_SPEED*dt, CW);
      const ny = wrap(e.y + dy*ENEMY_SPEED*dt, CH);

      if (canMove(e.dir, nx, ny, e.r)){
        e.x = nx; e.y = ny;
      } else {
        // blocked -> turn
        const rev = reverseDir(e.dir);
        let choices = opts.filter(d=>d!==rev);
        if (choices.length === 0) choices = opts;
        e.dir = choices[(Math.random()*choices.length)|0];
        e.nextDecisionAt = now + 200 + Math.random()*600;
      }

      e.phase += dt;
    }
  }

  // If the ship hits an enemy, you lose a life (but the case does NOT advance).
  let invulnUntil = 0;
  function checkEnemyCollisions(now){
    if (gameOver) return;
    if (now < invulnUntil) return;

    const rr = (player.r + ENEMY_R + 2);
    const rr2 = rr*rr;

    for (const e of enemies){
      if (!e.alive) continue;
      if (dist2Wrap(player.x, player.y, e.x, e.y) <= rr2){

        // Chrome Hull: invincible ramming â€” destroy the enemy, take no damage.
        if (chromeHull){
          e.alive = false;
          e.respawnAt = now + ENEMY_RESPAWN_BASE + Math.random()*ENEMY_RESPAWN_JITTER;
          spawnEnemyBurst(e.x, e.y, now);
          playSfx("explosion");
          score += 10;
          flash = {t: 0.7, kind:"good"};
          invulnUntil = now + 220; // short grace to avoid multi-trigger
          updateHUD();
          break;
        }

        // Shield Armor: consume an armor charge instead of a life.
        const usedArmor = (armor > 0);
        if (usedArmor){
          armor = Math.max(0, armor - 1);
        } else {
          lives = Math.max(0, lives - 1);
        }

        playSfx("hit");
        flash = {t: 1.0, kind:"bad"};
        invulnUntil = now + 1100;

        // respawn enemies away from the ship to prevent instant re-hit
        for (const ee of enemies){
          ee.alive = false;
          ee.respawnAt = now + ENEMY_HIT_RESPAWN_BASE + Math.random()*ENEMY_HIT_RESPAWN_JITTER;
        }

        if (!usedArmor && lives <= 0){
          setGameOver(true);
        } else {
          locked = true;
          setTimeout(()=>{ locked = false; }, 220);
        }
        break;
      }
    }
  }

  // Grenade explosions can temporarily clear enemies (explosions do NOT wrap across borders).
  function damageEnemiesInRadius(x,y,r,now){
    if (!enemiesEnabled) return;
    if (gameOver) return;
    const rr2 = r*r;
    let killed = 0;
    for (const e of enemies){
      if (!e.alive) continue;
      if (dist2Plain(x,y,e.x,e.y) <= rr2){
        e.alive = false;
        e.respawnAt = now + ENEMY_RESPAWN_BASE + Math.random()*ENEMY_RESPAWN_JITTER;
        spawnEnemyBurst(e.x, e.y, now);
        killed += 1;
      }
    }
    if (killed > 0){
      playSfx("explosion");
      score += 10 * killed;
      updateHUD();
    }
  }

  function drawEnemy(x,y,dir,phase=0.0){
    const ang = [0, Math.PI/2, Math.PI, -Math.PI/2][dir] ?? 0;
    const r = 12;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);

    ctx.shadowColor = "rgba(255, 0, 255, 0.95)";
    ctx.shadowBlur = 18;

    // saucer body
    ctx.beginPath();
    ctx.ellipse(0, 0, r*1.15, r*0.75, 0, 0, Math.PI*2);
    ctx.fillStyle = "#cf5bff";
    ctx.fill();

    // dome
    ctx.beginPath();
    ctx.ellipse(r*0.15, -r*0.15, r*0.45, r*0.32, 0, 0, Math.PI*2);
    ctx.fillStyle = "#0b0d10";
    ctx.fill();

    // eye
    ctx.beginPath();
    ctx.arc(r*0.55, 0, 2.3, 0, Math.PI*2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();

    // thruster flicker
    const flick = 0.3 + 0.7*Math.abs(Math.sin(phase*7.2));
    ctx.beginPath();
    ctx.moveTo(-r*1.25, 0);
    ctx.lineTo(-r*1.6, -r*0.25*flick);
    ctx.lineTo(-r*1.6, r*0.25*flick);
    ctx.closePath();
    ctx.fillStyle = "#ff2d2d";
    ctx.fill();

    ctx.restore();
  }

  function drawEnemyWrapped(e, now){
    const pad = 24;
    forEachWrappedCopy(e.x, e.y, pad, (xx,yy)=> drawEnemy(xx,yy,e.dir, e.phase + now*0.001));
  }
  function drawEnemyBurst(b, now){
    const t = (now - b.t0) / b.dur;
    if (t < 0 || t >= 1) return;
    const TAU = Math.PI * 2;
    const a = 1 - t;

    const r1 = 6 + t * 22;
    const r2 = 3 + t * 14;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.globalAlpha = a;

    // hot core
    ctx.shadowColor = "rgba(255, 60, 170, 0.95)";
    ctx.shadowBlur = 18;

    ctx.lineWidth = 3.0;
    ctx.strokeStyle = "#ff4bd2";
    ctx.beginPath();
    ctx.arc(0,0,r2,0,TAU);
    ctx.stroke();

    ctx.lineWidth = 3.8;
    ctx.strokeStyle = "#fff06a";
    ctx.beginPath();
    ctx.arc(0,0,r1,0,TAU);
    ctx.stroke();

    // rays
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = "#8ff6ff";
    const rays = 7;
    for (let k=0; k<rays; k++){
      const ang = (k * TAU / rays) + t * 0.9;
      const inner = r2 + 3;
      const outer = r1 + 7;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*inner, Math.sin(ang)*inner);
      ctx.lineTo(Math.cos(ang)*outer, Math.sin(ang)*outer);
      ctx.stroke();
    }

    ctx.restore();
  }



  function circleFitsOnMaze(x,y,r){
    // sample around the circle; uses walkable mask (walkability itself wraps)
    const pts = [
      [x+r, y], [x-r, y], [x, y+r], [x, y-r],
      [x+r*0.7, y+r*0.7], [x-r*0.7, y+r*0.7], [x+r*0.7, y-r*0.7], [x-r*0.7, y-r*0.7]
    ];
    for (const [px,py] of pts){
      if (!isWalkable(px,py)) return false;
    }
    return true;
  }

  function tooCloseToPellets(x,y){
    for (const p of pellets){
      if (dist2Plain(x,y,p.x,p.y) < (28*28)) return true;
    }
    return false;
  }

  function tooCloseToLoot(x,y){
    for (const q of loot){
      if (dist2Plain(x,y,q.x,q.y) < (30*30)) return true;
    }
    return false;
  }

  function tooCloseToPlayer(x,y){
    return dist2Plain(x,y,player.x,player.y) < (40*40);
  }

  function spawnLootOne(){
    for (let tries = 0; tries < 700; tries++){
      const x = Math.random() * (CW - 2*LOOT_R) + LOOT_R;
      const y = Math.random() * (CH - 2*LOOT_R) + LOOT_R;

      if (!circleFitsOnMaze(x,y,LOOT_R+2)) continue;
      if (tooCloseToPellets(x,y)) continue;
      if (tooCloseToLoot(x,y)) continue;
      if (tooCloseToPlayer(x,y)) continue;

      loot.push({x, y, val: 1});
      return true;
    }
    return false;
  }

  function ensureLootCount(){
    while (loot.length < LOOT_COUNT){
      if (!spawnLootOne()) break;
    }
  }

  function collectLootAtIndex(i){
    const it = loot[i];
    cash += (it?.val || 1);
    playSfx("get");
    loot.splice(i, 1);
    ensureLootCount();
    if (typeof refreshShopHUD === "function") refreshShopHUD();
  }

  function collectLootByTouch(){
    const rr = (player.r + LOOT_R + 2);
    const rr2 = rr*rr;
    for (let i = loot.length - 1; i >= 0; i--){
      if (dist2Plain(player.x, player.y, loot[i].x, loot[i].y) <= rr2){
        collectLootAtIndex(i);
      }
    }
  }

  
  function spawnShopIcon(now){
    for (let tries = 0; tries < 700; tries++){
      const x = WALL_PAD + Math.random()*(CW - 2*WALL_PAD);
      const y = WALL_PAD + Math.random()*(CH - 2*WALL_PAD);

      if (!circleFitsOnMaze(x, y, SHOP_R + 2)) continue;
      if (tooCloseToPellets(x, y, SHOP_R + 10)) continue;

      let ok = true;
      for (const c of loot){
        if (dist2Plain(x,y,c.x,c.y) < (SHOP_R + LOOT_R + 12)*(SHOP_R + LOOT_R + 12)){
          ok = false; break;
        }
      }
      if (!ok) continue;

      if (dist2Plain(x,y,player.x,player.y) < (SHOP_R + player.r + 34)*(SHOP_R + player.r + 34)) continue;

      shopIcon.active = true;
      shopIcon.x = x;
      shopIcon.y = y;
      shopIcon.expiresAt = now + SHOP_LIFETIME_MS;
      return true;
    }
    return false;
  }

  function updateShopIcon(now){
    if (shopIcon.active && now >= shopIcon.expiresAt){
      shopIcon.active = false;
    }
    if (!shopIcon.active && now >= nextShopSpawnAt){
      spawnShopIcon(now);
      nextShopSpawnAt = now + SHOP_SPAWN_MS;
    }
  }

  function maybeOpenShopByTouch(now){
    if (!shopIcon.active) return;
    const rr = (player.r + SHOP_R + 2);
    if (dist2Wrap(player.x, player.y, shopIcon.x, shopIcon.y) <= rr*rr){
      shopIcon.active = false;
      openShop();
      if (typeof refreshShopHUD === "function") refreshShopHUD();
    }
  }


function collectLootInRadius(x,y,r){
    // IMPORTANT: explosions do NOT wrap across borders, so use plain distance
    const rr2 = r*r;
    for (let i = loot.length - 1; i >= 0; i--){
      if (dist2Plain(x,y,loot[i].x, loot[i].y) <= rr2){
        collectLootAtIndex(i);
      }
    }
  }

  function queueDir(d){
    player.want = d;
  }// =============================
// Grenades (spacebar / tap)
// =============================
const GRENADE_FUSE_MS = 950;    // ~1 second
const EXPLOSION_MS    = 420;
const EXPLOSION_R     = 30;
const grenades = [];
const explosions = [];
const shots = [];
const SHOT_SPEED = 560;
const SHOT_R = 3;
const SHOT_TTL_MS = 1200;
let lastShotMs = -1;

let lastGrenadeMs = -1;
let tNow = performance.now();

function dist2Plain(x1,y1,x2,y2){
  const dx = x1 - x2;
  const dy = y1 - y2;
  return dx*dx + dy*dy;
}
function nearestPelletInRadius(x,y,r){
  // IMPORTANT: explosions do NOT wrap across screen borders.
  const rr = r*r;
  let best = null, bestD = 1e18;
  for (const p of pellets){
    const d2 = dist2Plain(x,y,p.x,p.y);
    if (d2 <= rr && d2 < bestD){
      best = p; bestD = d2;
    }
  }
  return best;
}

function dropGrenade(){
  if (locked || gameOver) return;
  const now = performance.now();
  if (now - lastGrenadeMs < 250) return;
  lastGrenadeMs = now;
  grenades.push({x: player.x, y: player.y, t0: now});
}


function fireShot(){
  if (locked || gameOver) return;
  if (!hasBlaster) return;
  if (!unlimitedAmmo && ammo <= 0) return;

  const now = performance.now();
  if (now - lastShotMs < 120) return;
  lastShotMs = now;

  const dir = player.dir ?? 0;
  let dx=0, dy=0;
  if (dir===0) dx=1;
  if (dir===2) dx=-1;
  if (dir===1) dy=1;
  if (dir===3) dy=-1;

  // spawn a bit in front of the ship
  const sx = player.x + dx*(player.r + 10);
  const sy = player.y + dy*(player.r + 10);
  // shots do NOT wrap; if spawned off-screen, skip
  if (sx < 0 || sx > CW || sy < 0 || sy > CH) return;
// if immediately blocked, don't fire
  if (!canMove(dir, sx, sy, SHOT_R+1)) return;

  if (!unlimitedAmmo){ ammo = Math.max(0, ammo - 1); }
  if (typeof refreshShopHUD === "function") refreshShopHUD();

  playSfx("laser");

  shots.push({x: sx, y: sy, dir, t0: now});
}

function explodeAt(x,y,now){
  playSfx("explosionQ");
  explosions.push({x, y, t0: now});
  // collect currency pills (no wrap)
  collectLootInRadius(x,y,EXPLOSION_R);
  // enemies can be cleared by an explosion (no wrap)
  if (enemiesEnabled) damageEnemiesInRadius(x,y,EXPLOSION_R,now);

  // shop icon can be opened by an explosion (no wrap)
  if (shopIcon && shopIcon.active && dist2Plain(x,y,shopIcon.x,shopIcon.y) <= (EXPLOSION_R*EXPLOSION_R)){
    shopIcon.active = false;
    openShop();
    if (typeof refreshShopHUD === "function") refreshShopHUD();
  }

  const hit = nearestPelletInRadius(x,y,EXPLOSION_R);
  if (hit) onPelletHit(hit);
}


function drawGrenade(x,y,age01){
  const r = 6;
  // body
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fillStyle = "#d7d7d7";
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x,y,r-2,0,Math.PI*2);
  ctx.fillStyle = "#3a3a3a";
  ctx.fill();
  // fuse spark
  ctx.beginPath();
  ctx.arc(x + r*0.65, y - r*0.75, 2.2, 0, Math.PI*2);
  ctx.fillStyle = (age01 > 0.82) ? "#ff3b30" : "#ffcf33";
  ctx.fill();
}


function drawShot(x,y,dir,now){
  const ang = (dir===0)?0 : (dir===1)?Math.PI/2 : (dir===2)?Math.PI : -Math.PI/2;
  const pulse = 0.6 + 0.4*Math.sin(now/80);
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(ang);
  ctx.globalAlpha = 0.95;
  ctx.shadowColor = "rgba(0,220,255,.85)";
  ctx.shadowBlur = 12 * pulse;
  ctx.fillStyle = "rgba(160,245,255,.95)";
  ctx.fillRect(-7, -1.5, 14, 3);
  ctx.restore();
}

function drawShotWrapped(s, now){
  forEachWrappedCopy(s.x, s.y, 20, (xx,yy)=> drawShot(xx,yy,s.dir,now));
}

function drawShopIcon(x,y,now){
  const pulse = 0.55 + 0.45*Math.sin(now/150);
  ctx.save();
  ctx.translate(x,y);
  ctx.shadowColor = "rgba(40,170,255,.9)";
  ctx.shadowBlur = 18 * pulse;
  ctx.fillStyle = "rgba(40,170,255,.25)";
  ctx.beginPath();
  ctx.arc(0,0,13,0,Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(40,170,255,.85)";
  ctx.beginPath();
  ctx.arc(0,0,13,0,Math.PI*2);
  ctx.stroke();

  // tiny cart-ish glyph
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(210,250,255,.95)";
  ctx.beginPath();
  ctx.moveTo(-6,-3);
  ctx.lineTo(5,-3);
  ctx.lineTo(3,4);
  ctx.lineTo(-4,4);
  ctx.closePath();
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(-2,7,2,0,Math.PI*2);
  ctx.arc(4,7,2,0,Math.PI*2);
  ctx.stroke();

  ctx.restore();
}

function drawShopIconWrapped(icon, now){
  forEachWrappedCopy(icon.x, icon.y, 26, (xx,yy)=> drawShopIcon(xx,yy,now));
}

function updateShots(dt, now){
  if (!shots.length) return;

  for (let i = shots.length - 1; i >= 0; i--){
    const s = shots[i];
    if (now - s.t0 > SHOT_TTL_MS){
      shots.splice(i, 1);
      continue;
    }

    let dx=0, dy=0;
    if (s.dir===0) dx=1;
    if (s.dir===2) dx=-1;
    if (s.dir===1) dy=1;
    if (s.dir===3) dy=-1;

    const nx = s.x + dx*SHOT_SPEED*dt;
    const ny = s.y + dy*SHOT_SPEED*dt;

    // shots do NOT wrap; if they leave the playfield, remove them
    if (nx < 0 || nx > CW || ny < 0 || ny > CH){
      shots.splice(i, 1);
      continue;
    }
if (!canMove(s.dir, nx, ny, SHOT_R)){
      shots.splice(i, 1);
      continue;
    }

    s.x = nx; s.y = ny;

    // shots can collect currency pills (wrap distance)
    for (let j = loot.length - 1; j >= 0; j--){
      const c = loot[j];
      if (dist2Plain(s.x,s.y,c.x,c.y) <= (SHOT_R+7)*(SHOT_R+7)){
        collectLootAtIndex(j);
      }
    }

    // shots can open the shop icon (wrap distance)
    if (shopIcon && shopIcon.active && dist2Plain(s.x,s.y,shopIcon.x,shopIcon.y) <= (SHOT_R+12)*(SHOT_R+12)){
      shopIcon.active = false;
      shots.splice(i, 1);
      openShop();
      if (typeof refreshShopHUD === "function") refreshShopHUD();
      continue;
    }

    // shots can destroy enemies
    if (enemiesEnabled){
      for (const e of enemies){
        if (!e.alive) continue;
        if (dist2Plain(s.x,s.y,e.x,e.y) <= (SHOT_R+e.r)*(SHOT_R+e.r)){
          e.alive = false;
          e.respawnAt = now + ENEMY_RESPAWN_BASE + Math.random()*ENEMY_RESPAWN_JITTER;
          spawnEnemyBurst(e.x, e.y, now);
          playSfx("explosion");
          score += 10;
          updateHUD();
          shots.splice(i, 1);
          break;
        }
      }
    }
  }
}



  function readDirFromKeys(){
    // prefer last-pressed behavior via order
    if (keys.has("arrowleft") || keys.has("a")) return 2;
    if (keys.has("arrowright") || keys.has("d")) return 0;
    if (keys.has("arrowup") || keys.has("w")) return 3;
    if (keys.has("arrowdown") || keys.has("s")) return 1;
    return null;
  }

  function canMove(dir, nx, ny, rOverride){
    // sample a few points around a circle of radius rOverride (defaults to player radius)
    const r = (rOverride ?? player.r);
    const pts = [
      [nx+r, ny], [nx-r, ny], [nx, ny+r], [nx, ny-r],
      [nx+r*0.7, ny+r*0.7], [nx-r*0.7, ny+r*0.7], [nx+r*0.7, ny-r*0.7], [nx-r*0.7, ny-r*0.7]
    ];
    for (const [px,py] of pts){
      if (!isWalkable(px,py)) return false;
    }
    return true;
  }

  // =============================
  // Case logic
  // =============================
  let caseN = 1;
  let score = 0;
  let lives = 3;
  let cash = 0; // currency collected from small pills
  let hasBlaster = true;
  let ammo = 10;
  // Upgrades (shop)
  const ARMOR_MAX = 3;
  let speedBoost = false;      // Speed Booster
  let armor = 0;              // Shield Armor charges
  let unlimitedAmmo = false;  // Plasma Cannon
let chromeHull = false;     // Invincibility
let gameOver = false;

// =============================
// Permanent progress (saved upgrades)
// =============================
const PROGRESS_KEY = "circleOfThrillis_progress_v1";
const defaultProgress = ()=>({
  upgrades: {
    speedBooster: false,
    armorLevel: 0,
    plasmaCannon: false,
    chromeHull: false
  }
});

function loadProgress(){
  try{
    const raw = localStorage.getItem(PROGRESS_KEY);
    if (!raw) return defaultProgress();
    const p = JSON.parse(raw);
    const u = (p && typeof p === "object" && p.upgrades && typeof p.upgrades === "object") ? p.upgrades : {};
    const armorLevel = Math.max(0, Math.min(ARMOR_MAX, Number(u.armorLevel) || 0));
    return {
      upgrades: {
        speedBooster: !!u.speedBooster,
        armorLevel,
        plasmaCannon: !!u.plasmaCannon,
        chromeHull: !!u.chromeHull
      }
    };
  } catch(e){
    return defaultProgress();
  }
}

function saveProgress(){
  try { localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress)); } catch(e){}
}

function applyProgressUpgrades(){
  speedBoost = !!progress.upgrades.speedBooster;
  unlimitedAmmo = !!progress.upgrades.plasmaCannon;
  chromeHull = !!progress.upgrades.chromeHull;
  armor = Math.max(0, Math.min(ARMOR_MAX, Number(progress.upgrades.armorLevel) || 0));
  if (unlimitedAmmo) hasBlaster = true;
}

function resetProgress(){
  progress = defaultProgress();
  try { localStorage.removeItem(PROGRESS_KEY); } catch(e){}
  // Apply immediately (no restart required)
  applyProgressUpgrades();
  if (typeof syncShopButtons === "function") syncShopButtons();
  if (typeof refreshShopHUD === "function") refreshShopHUD();
}

let progress = loadProgress();
applyProgressUpgrades();
  let current = null; // { key, stem }
  let locked = false;
  let flash = {t:0, kind:""};

  const stemEl = document.getElementById("stem");
  const gameOverEl = document.getElementById("gameOver");
  const playAgainBtn = document.getElementById("playAgainBtn");
  playAgainBtn?.addEventListener("click", ()=>{ if (gameOver) restartGame(); });

  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  

  function updateHUD(){
    // HUD is rendered on-canvas (hearts, currency, score). Keep this hook for future.
  }


  function refreshShopHUD(){
    if (shopCashEl) shopCashEl.textContent = String(cash);
    if (shopAmmoEl) shopAmmoEl.textContent = unlimitedAmmo ? "âˆž" : String(ammo);
    if (typeof syncShopButtons === "function") syncShopButtons();
  }

  function syncShopButtons(){
    if (buyBoosterBtn){
      if (speedBoost){
        buyBoosterBtn.disabled = true;
        buyBoosterBtn.textContent = "Owned";
      } else {
        buyBoosterBtn.disabled = false;
        buyBoosterBtn.textContent = "Buy (ðŸ’Š 12)";
      }
    }
    if (buyArmorBtn){
      if (armor >= ARMOR_MAX){
        buyArmorBtn.disabled = true;
        buyArmorBtn.textContent = "Maxed";
      } else {
        buyArmorBtn.disabled = false;
        buyArmorBtn.textContent = "Buy (ðŸ’Š 10)";
      }
    }
    if (buyPlasmaBtn){
      if (unlimitedAmmo){
        buyPlasmaBtn.disabled = true;
        buyPlasmaBtn.textContent = "Installed";
      } else {
        buyPlasmaBtn.disabled = false;
        buyPlasmaBtn.textContent = "Buy (ðŸ’Š 50)";
      }
    }
    if (buyChromeBtn){
      if (chromeHull){
        buyChromeBtn.disabled = true;
        buyChromeBtn.textContent = "Installed";
      } else {
        buyChromeBtn.disabled = false;
        buyChromeBtn.textContent = "Buy (ðŸ’Š 100)";
      }
    }
  }


  function buyBlasterPack(){
    const cost = 6;
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    hasBlaster = true;
    ammo += 15;
    setShopMsg("Blaster loaded (+15).", "good");
    refreshShopHUD();
  }

  function buyHeart(){
    const cost = 4;
    const maxLives = 5;
    if (lives >= maxLives){
      setShopMsg("Already at max hearts.", "bad");
      return;
    }
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    lives += 1;
    setShopMsg("+1 heart.", "good");
    refreshShopHUD();
  }

  
  function buyBooster(){
    const cost = 12;
    if (speedBoost){
      setShopMsg("Booster already installed.", "bad");
      return;
    }
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    speedBoost = true;
    progress.upgrades.speedBooster = true;
    saveProgress();
    setShopMsg("Booster installed (+25% speed).", "good");
    refreshShopHUD();
  }

  function buyArmor(){
    const cost = 10;
    if (armor >= ARMOR_MAX){
      setShopMsg("Armor already maxed.", "bad");
      return;
    }
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    armor = Math.min(ARMOR_MAX, armor + 1);
    progress.upgrades.armorLevel = Math.max(Number(progress.upgrades.armorLevel)||0, armor);
    saveProgress();
    setShopMsg("Armor charged (+1).", "good");
    refreshShopHUD();
  }

  function buyPlasma(){
    const cost = 50;
    if (unlimitedAmmo){
      setShopMsg("Plasma Cannon already installed.", "bad");
      return;
    }
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    unlimitedAmmo = true;
    progress.upgrades.plasmaCannon = true;
    saveProgress();
    hasBlaster = true;
    setShopMsg("Plasma Cannon online (âˆž ammo).", "good");
    refreshShopHUD();
  }

  function buyChromeHull(){
    const cost = 100;
    if (chromeHull){
      setShopMsg("Chrome Hull already installed.", "bad");
      return;
    }
    if (cash < cost){
      setShopMsg("Not enough ðŸ’Š.", "bad");
      return;
    }
    cash -= cost;
    playSfx("buy");
    chromeHull = true;
    progress.upgrades.chromeHull = true;
    saveProgress();
    setShopMsg("Chrome Hull engaged (invincible).", "good");
    refreshShopHUD();
  }

function setGameOver(on){
    const wasOver = gameOver;
    gameOver = on;
    if (on){
      if (!wasOver) playSfx("gameover");
      gameOverEl.classList.remove("hidden");
      locked = true;
      grenades.length = 0;
      explosions.length = 0;
    } else {
      gameOverEl.classList.add("hidden");
    }
  }

  function restartGame(){
    score = 0;
    lives = 3;
    cash = 0;
    hasBlaster = true;
    ammo = 10;
    // Re-apply permanent upgrades
    applyProgressUpgrades();
    if (typeof syncShopButtons === "function") syncShopButtons();
    shots.length = 0;
    shopIcon.active = false;
    nextShopSpawnAt = performance.now() + SHOP_SPAWN_MS;
    loot.length = 0;
    ensureLootCount();
    if (enemiesEnabled) initEnemies(); else enemies.length = 0;
    invulnUntil = 0;
    caseN = 1;
    setGameOver(false);
    locked = false;
    playSfx("laser");
    newCase();
  }

  function renderPrompt(){
    if (!stemEl || !current) return;
    if (promptMode === "vessels"){
      const vesselName = (typeof V !== "undefined" && V && V[current.key]) ? V[current.key] : current.key;
      stemEl.classList.add("isVesselPrompt");
      stemEl.textContent = vesselName;
    } else {
      stemEl.classList.remove("isVesselPrompt");
      stemEl.textContent = current.stem;
    }
  }

  function newCase(){
    locked = false;
    current = null;
    // keep player position between rounds

    const key = pick(vesselKeys);
    const stem = pick(stems[key] || ["A patient presents with acute neurologic deficits."]);
    current = {key, stem};

    renderPrompt();
    updateHUD();
    fitCanvasCSS();
  }

  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function onPelletHit(p){
    if (locked || gameOver) return;

    const correct = (p.key === current.key);
    if (correct){
      locked = true;
      score += 100;
      flash = {t: 1.0, kind:"good"};
      updateHUD();

      // brief pause then next case
      setTimeout(()=>{
        caseN += 1;
        newCase();
      }, 650);
      return;
    }

    // wrong answer: do NOT advance the case
    lives = Math.max(0, lives - 1);
    flash = {t: 1.0, kind:"bad"};
    updateHUD();

    if (lives <= 0){
      setGameOver(true);
      return;
    }

    // small lockout to prevent rapid multi-hits from one blast
    locked = true;
    setTimeout(()=>{ locked = false; }, 280);
  }

  // =============================
  // Main loop
  // =============================
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    
    if (gameOver){
      tNow = now;
      draw();
      // feedback flash overlay still allowed
      if (flash.t > 0){
        flash.t -= dt*1.5;
        ctx.save();
        ctx.globalAlpha = clamp(flash.t,0,1)*0.35;
        ctx.fillStyle = (flash.kind === "good") ? "#2cffb0" : "#ff2f5b";
        ctx.fillRect(0,0,CW,CH);
        ctx.restore();
      }
      requestAnimationFrame(tick);
      return;
    }


    if (helpBackdrop && !helpBackdrop.classList.contains("hidden")){
      tNow = now;
      draw();
      requestAnimationFrame(tick);
      return;
    }


    // pause gameplay while a modal is open
    if (isUIPaused()){
      tNow = now;
      draw();
      // feedback flash overlay
      if (flash.t > 0){
        flash.t -= dt*1.5;
        ctx.save();
        ctx.globalAlpha = clamp(flash.t,0,1)*0.35;
        ctx.fillStyle = (flash.kind==="good") ? "#2cffb0" : "#ff2f5b";
        ctx.fillRect(0,0,CW,CH);
        ctx.restore();
      }
      requestAnimationFrame(tick);
      return;
    }

// input
    const kdir = readDirFromKeys();
    if (kdir !== null) queueDir(kdir);

    // periodic shop icon
    updateShopIcon(now);

    // movement
    const speed = 220 * (speedBoost ? 1.25 : 1.0); // px/sec
    // attempt to turn into wanted direction first (feels responsive)
    const dirOrder = [player.want, player.dir].filter((v,i,a)=>a.indexOf(v)===i);

    for (const d of dirOrder){
      if (d === null || d === undefined) continue;
      let dx=0, dy=0;
      if (d===0) dx=1;
      if (d===2) dx=-1;
      if (d===1) dy=1;
      if (d===3) dy=-1;

      const rawX = player.x + dx*speed*dt;
      const rawY = player.y + dy*speed*dt;
      const nx = wrap(rawX, CW);
      const ny = wrap(rawY, CH);
      const didWrap = (dx !== 0 && (rawX < 0 || rawX >= CW)) || (dy !== 0 && (rawY < 0 || rawY >= CH));

      if (canMove(d, nx, ny)){
        player.x = nx; player.y = ny; player.dir = d;
        if (didWrap) playSfx("warp");
        break;
      }
    }

    // mouth animation
    player.mouth = 0.18 + 0.22*Math.abs(Math.sin(now/120));

    // enemies
    if (enemiesEnabled){
      updateEnemies(dt, now);
      checkEnemyCollisions(now);
    }

    // collect currency pills by touch
    collectLootByTouch();

    // open shop by touching the shop icon
    maybeOpenShopByTouch(now);

    // blaster shots
    updateShots(dt, now);

// grenades (pellets activate only via explosion, not by touch)
for (let i = grenades.length - 1; i >= 0; i--){
  const g = grenades[i];
  if (now - g.t0 >= GRENADE_FUSE_MS){
    grenades.splice(i, 1);
    explodeAt(g.x, g.y, now);
  }
}
for (let i = explosions.length - 1; i >= 0; i--){
  const ex = explosions[i];
  if (now - ex.t0 >= EXPLOSION_MS){
    explosions.splice(i, 1);
  }
}

    // draw
    tNow = now;
    draw();

    // feedback flash overlay
    if (flash.t > 0){
      flash.t -= dt*1.5;
      ctx.save();
      ctx.globalAlpha = clamp(flash.t,0,1)*0.35;
      ctx.fillStyle = (flash.kind==="good") ? "#2cffb0" : "#ff2f5b";
      ctx.fillRect(0,0,CW,CH);
      ctx.restore();
    }

    requestAnimationFrame(tick);
  }

  // init
  fitCanvasCSS();
  newCase();
  ensureLootCount();
  if (enemiesEnabled) initEnemies(); else enemies.length = 0;
  openHelp();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>