<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wheel of Neurology â€” v1.2 stable</title>
<style>
:root{
  --bg:#052b1a; --panel:#0b3526; --ink:#ffffff; --muted:#cfe6db;
  --accent:#d3af5e; --good:#146c43; --bad:#111111;
  --wof-frame1:#33d1c7; --wof-frame2:#0aa2a0;
}
html,body{height:100%}
*,*::before,*::after{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
    Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
.wrap{max-width:1280px;margin:0 auto;padding:16px;display:grid;gap:16px}
header{display:flex;flex-wrap:wrap;align-items:baseline;gap:12px}
header h1{margin:0;font-size:24px;letter-spacing:.5px}
header small{color:var(--muted)}
.grid{display:grid;gap:16px;grid-template-columns:0.65fr 1.35fr}
@media (max-width: 960px){ .grid{grid-template-columns:1fr} }

.panel{background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
  border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:14px;
  box-shadow:0 10px 24px rgba(0,0,0,.25), inset 0 1px rgba(255,255,255,.05);
}

/* Left column layout */
.wheelPanel{display:grid;grid-template-rows:auto auto auto auto;gap:8px;align-content:start}
.peek{position:relative;height:70px;display:grid;place-items:center}
.peek canvas{height:52px;width:270px;border-radius:10px;border:1px solid rgba(211,175,94,.35);background:#062516}
.pointer{position:absolute;top:2px;left:50%;transform:translateX(-50%) rotate(180deg);width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;border-bottom:20px solid var(--accent);z-index:2;}
.peekLabel{
  position:absolute; bottom:0; left:50%; transform:translateX(-50%);
  font-weight:900; font-size:14px; letter-spacing:.3px;
  background:#0d2f23; color:#fff; padding:4px 10px;
  border:1px solid rgba(211,175,94,.45); border-radius:999px;
  box-shadow:0 2px 0 rgba(0,0,0,.35), inset 0 1px rgba(255,255,255,.06);
}

/* Hide the actual wheel at rest so only the peek is visible */
.wheelWrap{position:relative;width:100%;max-width:560px;transform-origin:top center;will-change:transform;z-index:6}
.wheelWrap.rest{position:absolute;left:-10000px;top:-10000px;width:1px;height:1px;visibility:hidden;overflow:hidden}
.wheelWrap.spin{transform:scale(1.10)}
.wheelWrap.fullscreen{position:fixed;inset:0;margin:auto;display:grid;place-items:center;background:rgba(0,0,0,.55);max-height:calc(100vh - 60px);z-index:60}
#wheelCanvas{width:100%;height:auto;max-width:640px;background:radial-gradient(ellipse at center, #0e3b2a 0%, #082718 70%);border-radius:12px}

/* Controls + info */
.controls{display:grid;gap:8px;place-items:center;width:100%}
.controls .row{display:flex;gap:10px;align-items:center;justify-content:center;flex-wrap:wrap}
.controls button{padding:10px 14px;border-radius:10px;border:1px solid rgba(211,175,94,.35);background:#0d2f23;color:#fff;font-weight:800;cursor:pointer;box-shadow:0 2px 0 rgba(0,0,0,.35)}
.controls button.good{background:#124b36}
.controls button:disabled{opacity:.55;cursor:not-allowed;box-shadow:none}
.score{display:grid;place-items:center}
.box{display:inline-grid;gap:3px;border:1px dashed rgba(211,175,94,.35);border-radius:10px;padding:12px 16px}
.box .muted{color:var(--muted);font-size:12px}
.players{display:flex;gap:8px;margin-top:4px;align-items:stretch;width:100%}
.player{background:#082a1d;border:1px solid rgba(211,175,94,.35);border-radius:10px;padding:8px;text-align:center;flex:1 1 0}
.player.active{outline:2px solid var(--accent)}
.player b{display:block;font-size:12px;color:var(--muted);letter-spacing:.3px}
.player span{display:block;font-weight:800;margin-top:4px}
.status{margin-top:6px;text-align:center;color:var(--accent)}
.secondary{display:flex;gap:12px;justify-content:center;margin-top:8px}

/* RIGHT: board styling */
.puzzleBoard{display:grid;gap:14px;grid-template-rows:auto auto auto;align-content:start;align-items:start}
.category{color:var(--accent);font-weight:800;letter-spacing:.4px}

/* Outer neon-like frame */
.board{
  --cols:14;
  display:grid;
  grid-template-columns:repeat(var(--cols),1fr);
  gap:5px;
  padding:14px;
  border-radius:18px;
  background:
    linear-gradient(var(--wof-frame1),var(--wof-frame2)) padding-box,
    linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,0)) border-box;
  border:4px solid transparent;
  box-shadow: 0 12px 28px rgba(0,0,0,.35), inset 0 1px rgba(255,255,255,.06);
}

/* Tiles */
.cell{
  height:50px;
  display:grid; place-items:center;
  color:#fff;
  font-weight:900; font-size:22px; letter-spacing:.6px;
  border-radius:6px;
  background: linear-gradient(180deg,#0b5f4e,#063a2f);
  border:2px solid #022b24;
  box-shadow: inset 0 2px 0 rgba(255,255,255,.15), inset 0 -6px 0 rgba(0,0,0,.35);
  position:relative;
}
.cell.revealed{
  background: linear-gradient(180deg,#138a73,#0c6a58);
  border-color:#045446;
  text-shadow: 0 2px 0 rgba(0,0,0,.35);
}
.cell.space{background: transparent;border-color: transparent;box-shadow:none}
.cell:not(.revealed):not(.space)::before{
  content:"âœ»";
  color:#bff3ec;
  font-size:20px;
  line-height:1;
  opacity:.85;
}
.cell.filler{filter: saturate(.8) brightness(.9)}


.cell.letter{background:#ffffff !important; border-color:#cccccc !important; color:#000000 !important; text-shadow:none !important}
.cell.letter:not(.revealed)::before{content:none !important}



#startModal .dialog{max-width:520px;width:90%;margin:0 auto}


#startModal .dialog footer{display:flex;justify-content:center}


#startModal .options{flex-wrap:wrap;justify-content:center}


/* Brand logo */
.brand img{height:36px;display:block}
/* Keyboard */
.keyboard{display:grid;grid-template-columns:repeat(13,1fr);gap:8px}
.keyboard button{
  padding:10px 0;border-radius:10px;font-weight:900;
  border:1px solid rgba(211,175,94,.20);
  background:linear-gradient(180deg,#103728,#0c2c20);
  color:#fff; box-shadow:0 2px 0 rgba(0,0,0,.35), inset 0 1px rgba(255,255,255,.06);
}
.keyboard button:hover:not(:disabled){transform:translateY(-1px)}
.keyboard button:disabled{opacity:.55;background:#0b241a;color:#a8c3b7;border-color:rgba(211,175,94,.12);box-shadow:none}

.modal{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.6);z-index:100}
.modal.show{display:grid}
.dialog{width:min(680px,90vw);background:#0d2f23;border:1px solid rgba(211,175,94,.35);border-radius:12px;padding:16px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
.dialog h3{margin:.25rem 0 1rem 0}
.dialog footer{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
.dialog button{padding:8px 12px;border-radius:8px;border:1px solid rgba(211,175,94,.35);background:#12372a;color:#fff;font-weight:800}
.dialog .field{margin:.5rem 0;display:grid;gap:6px}
.dialog .field label{font-size:12px;color:var(--muted)}
.dialog .field select{background:#0b1f17;color:#fff;border:1px solid rgba(211,175,94,.35);border-radius:8px;padding:8px}

#startModal .options{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 12px 0}
#startModal .options input[type=radio]{accent-color:#146c43;}
#startModal .options label{padding:8px 10px;border-radius:10px;border:1px solid rgba(211,175,94,.35);background:#0d2f23;color:#fff;font-weight:900;gap:8px;}
#optionsModal .options{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 12px 0}
#optionsModal .options input[type=radio]{accent-color:#146c43;}
#optionsModal .options label{padding:8px 10px;border-radius:10px;border:1px solid rgba(211,175,94,.35);background:#0d2f23;color:#fff;font-weight:900;gap:8px;}

.overlayPointer{position:fixed;z-index:65;width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:26px solid var(--accent);transform:rotate(180deg);pointer-events:none;}

footer{color:var(--muted);text-align:center;padding:6px 0 12px 0}


/* Remove dim background/shadow around fullscreen wheel overlay */
.wheelWrap.fullscreen{background:transparent !important; box-shadow:none !important;}

.landed-flash{ outline: 3px solid rgba(255,255,255,.8); box-shadow: 0 0 12px 4px rgba(255,255,255,.8) inset; }

/* guessed letter styling */
#keyboard button.guess-correct { color: #0a8a0a; text-decoration: line-through; text-decoration-thickness: 2px; }
#keyboard button.guess-wrong   { color: #c01818; text-decoration: line-through; text-decoration-thickness: 2px; }

</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1 class="brand"><img src="wheelofneurology-logo.png" alt="Wheel of Neurology"></h1>
    <small></small>
  </header>

  <div class="grid">
    <!-- LEFT -->
    <div class="panel wheelPanel">
      <div class="peek">
        <div class="pointer"></div>
        <canvas id="peekCanvas" width="320" height="52" aria-hidden="true"></canvas>
        <div id="peekLabel" class="peekLabel">$0</div>
      </div>

      <!-- Hidden at rest; only shown during spin in a fullscreen overlay clone -->
      <div class="wheelWrap rest" aria-hidden="true">
        <canvas id="wheelCanvas" width="720" height="720"></canvas>
      </div>

      <div class="controls">
        <div class="row">
          <button id="spinBtn" class="good">ðŸ§  Spin</button>
          <button id="buyVowelBtn">Vowel ($250)</button>
          <button id="solveBtn">Solve</button>
        </div>
                <div id="playersBoard" class="players"></div>
        <div id="status" class="status"></div>
        <div class="secondary"><button id="optionsBtn">Options</button></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel puzzleBoard">
      <div><div class="category" id="categoryTop">Category</div></div>
      <div id="board" class="board" aria-live="polite"></div>
      <div><div id="keyboard" class="keyboard"></div></div>
    </div>
  </div>

  <footer>created by micah etter, md</footer>
</div>

<!-- CLUE MODAL -->
<div id="clueModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="clueTitle">
  <div class="dialog">
    <h3 id="clueTitle">Long-form Clue</h3>
    <div id="clueContent" class="clueBox"></div>
    <footer>
      <button id="buyClueBtn">Buy clue ($400)</button>
      <button id="closeClueBtn">Close</button>
    </footer>
  </div>
</div>

<!-- SOLVE MODAL -->
<div id="solveModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="solveTitle">
  <div class="dialog">
    <h3 id="solveTitle">Solve the Puzzle</h3>
    <input id="solveInput" placeholder="Type the full answer..." style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(211,175,94,.35);background:#0b1f17;color:#fff">
    <footer>
      <button id="submitSolveBtn" class="good">Submit</button>
      <button id="closeSolveBtn">Cancel</button>
    </footer>
  </div>
</div>

<!-- START MODAL -->
<div id="startModal" class="modal show" role="dialog" aria-modal="true" aria-labelledby="startTitle">
  <div class="dialog">
    <h3 id="startTitle">How many players?</h3>
    <div class="options" role="radiogroup" aria-label="Players">
  <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="players" value="1" checked> 1</label>
  <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="players" value="2"> 2</label>
  <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="players" value="3"> 3</label>
</div>
    <footer>
      <button id="startSpinBtn" class="good">Spin to begin!</button>
    </footer>
  </div>
</div>

<div id="optionsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="optTitle">
  <div class="dialog">
    <h3 id="optTitle">Options</h3>
    <div class="options" role="radiogroup" aria-label="Players (Options)">
      <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="playersOptions" value="1"> 1</label>
      <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="playersOptions" value="2"> 2</label>
      <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="playersOptions" value="3"> 3</label>
    </div>
    <div class="field">
      <label for="categorySelect">Category for new puzzles</label>
      <select id="categorySelect"></select>
    </div>
    <footer>
      <button id="newBtn" style="margin-right:auto">New Puzzle</button><button id="saveOptionsBtn" class="good">Save</button>
      <button id="cancelOptionsBtn">Cancel</button>
    </footer>
  </div>
</div>

<div id="spinOverlay" class="spinOverlay"></div>

<script>
  // -------- CSV loader (no deps) --------
  async function loadCsvPuzzles(path="fangmanclues.csv"){
    try{
      const res = await fetch(path);
      if(!res.ok) throw new Error("HTTP "+res.status);
      const text = await res.text();
      const rows = parseCSV(text);
      const items = [];
      for(const r of rows){
        if(!r || r.length < 3) continue;
        const [answerRaw, clueRaw, categoryRaw] = r;
        const category = (categoryRaw||"").trim();
        if(!category) continue; // skip rows with empty category col3
        const answer = (answerRaw||"").trim();
        const clue = (clueRaw||"").trim();
        if(!answer) continue;
        items.push({answer, category, clue});
      }
      return items;
    }catch(err){
      console.warn("CSV load failed:", err);
      return [];
    }
  }
  function parseCSV(text){
    const rows = []; let row=[], field="", inQuotes=false;
    for(let i=0;i<text.length;i++){
      const ch=text[i];
      if(inQuotes){
        if(ch==='\"'){
          if(text[i+1]==='\"'){ field+='\"'; i++; }
          else{       try{ SFX.buzz(); }catch(e){} 
      inQuotes=false; }
        } else { field+=ch; }
      } else {
        if(ch==='\"'){ inQuotes=true; }
        else if(ch===','){ row.push(field); field=''; }
        else if(ch==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
        else if(ch==='\r'){ /*ignore*/ }
        else { field+=ch; }
      }
    }
    if(field.length || row.length){ row.push(field); rows.push(row); }
    if(rows.length && /category/i.test((rows[0][2]||'').trim())) rows.shift();
    return rows.map(r=>r.map(c=>(c||'').trim()));
  }

  // -------- Data --------
  let puzzles = []; // will load from CSV
  const seedPuzzles = [
    { answer: "CEREBELLAR ATAXIA", category: "Sign & Symptom", clue: "Uncoordinated, clumsy movement with dysmetria and wide-based gait." },
    { answer: "BROCA APHASIA", category: "Language Disorder", clue: "Nonfluent, effortful speech with intact comprehension." },
    { answer: "MYASTHENIA GRAVIS", category: "Neuromuscular Junction", clue: "Autoimmune postsynaptic ACh receptor dysfunction causing fatigable weakness." },
    { answer: "MULTIPLE SCLEROSIS", category: "Inflammatory Demyelination", clue: "CNS demyelination with dissemination in time and space." }
  ];

  const wheelWedges = [
    {type:"cash", label:"$500", value:500},{type:"cash", label:"$600", value:600},{type:"cash", label:"$700", value:700},
    {type:"cash", label:"$800", value:800},{type:"cash", label:"$900", value:900},{type:"cash", label:"$650", value:650},
    {type:"cash", label:"$750", value:750},{type:"cash", label:"$1000", value:1000},{type:"bankrupt", label:"BANKRUPT"},
    {type:"lose", label:"LOSE TURN"},{type:"clue", label:"CLUE"},{type:"cash", label:"$550", value:550},
    {type:"clue", label:"CLUE"},{type:"cash", label:"$700", value:700},{type:"cash", label:"$850", value:850},{type:"cash", label:"$500", value:500}
  ];

  const BOARD = { rows:3, minCols:14, maxCols:20, maxRows:4 };

  // -------- State --------
  const state = {
    
  guessedCorrect: new Set(),
  guessedWrong: new Set(),
puzzleIndex: 0, answer: "", grid: [], cols: 14,
    guessed: new Set(), canGuessConsonant:false, canBuyVowel:false,
    currentCash: 0, spinning:false, cluePurchased:false,
    players:1, banks:[0,0,0], currentPlayer:0,
    vowelPrice:250, cluePrice:400, rotation:0,
    categories: [],
    selectedCategory: 'RANDOM'
  };

  // -------- DOM --------
  const canvas = document.getElementById("wheelCanvas");
  const wheelWrap = document.querySelector('.wheelWrap');
  const peekCanvas = document.getElementById("peekCanvas");
  const peekLabel = document.getElementById("peekLabel");
  const spinBtn = document.getElementById("spinBtn");
  const buyVowelBtn = document.getElementById("buyVowelBtn");
  const solveBtn = document.getElementById("solveBtn");
  const newBtn = document.getElementById("newBtn");
    const categoryTopEl = document.getElementById("categoryTop");
  const boardEl = document.getElementById("board");
  const keyboardEl = document.getElementById("keyboard");
  const statusEl = document.getElementById("status");
  const playersBoard = document.getElementById("playersBoard");
  const clueModal = document.getElementById("clueModal");
  const clueContent = document.getElementById("clueContent");
  const buyClueBtn = document.getElementById("buyClueBtn");
  const closeClueBtn = document.getElementById("closeClueBtn");
  const solveModal = document.getElementById("solveModal");
  const solveInput = document.getElementById("solveInput");
  const submitSolveBtn = document.getElementById("submitSolveBtn");
  const closeSolveBtn = document.getElementById("closeSolveBtn");
  const optionsBtn = document.getElementById("optionsBtn");
  const optionsModal = document.getElementById("optionsModal");
  const playersInput = document.getElementById("playersInput");
  const saveOptionsBtn = document.getElementById("saveOptionsBtn");
  const cancelOptionsBtn = document.getElementById("cancelOptionsBtn");
  const categorySelect = document.getElementById("categorySelect");
  const startModal = document.getElementById("startModal");
  const startSpinBtn = document.getElementById("startSpinBtn");
  const startPlayerRadios = Array.from(startModal.querySelectorAll('.options input[type=radio]'));
  const optionsPlayerRadios = Array.from(optionsModal.querySelectorAll('.options input[type=radio]'));

  // -------- Helpers --------
  const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  
  // Count alphabetic letters only (ignore spaces/punct)
  function letterCount(s){
    return (String(s||'').match(/[A-Za-z]/g)||[]).length;
  }
const VOWELS = new Set("AEIOU".split(""));
  const sliceCount = wheelWedges.length;
  const sliceAngle = (Math.PI*2)/sliceCount;

  function CPL(){ return `Player ${state.currentPlayer+1}`; }
  function setStatus(m){ statusEl.textContent = m || ""; }
  function isLetter(ch){ return /^[A-Z]$/.test(ch); }
  function dollars(n){ return n.toLocaleString(undefined,{maximumFractionDigits:0}); }

  // -------- Board layout --------
  function layoutBoard(answer){
    function tokenLen(w){ let n=0; for(const ch of w){ if(isLetter(ch) || "'&-".includes(ch)) n++; } return n; }
    function attempt(rows, cols){
      const grid=Array.from({length:rows},()=>Array.from({length:cols},()=>({ch:"",type:"filler",revealed:true})));
      const words=answer.toUpperCase().trim().split(" ").filter(Boolean);
      let r=0,c=0;
      for(const w of words){
        const wlen=tokenLen(w); const sep = c>0?1:0;
        if(c+sep+wlen>cols){ r++; c=0; } if(r>=rows) return null;
        if(sep){ grid[r][c]={ch:"",type:"space",revealed:true}; c++; }
        for(const ch of w){
          if(isLetter(ch)) grid[r][c++]={ch,type:"letter",revealed:false};
          else if("'&-".includes(ch)) grid[r][c++]={ch,type:"punct",revealed:true};
          if(c>cols) return null;
        }
      }
      return grid;
    }
    let grid=null, chosenCols=BOARD.minCols;
    for(let cols=BOARD.minCols; cols<=BOARD.maxCols; cols++){ const g=attempt(BOARD.rows,cols); if(g){ grid=g; chosenCols=cols; break; } }
    if(!grid){
      for(let rows=BOARD.rows+1; rows<=BOARD.maxRows; rows++){
        for(let cols=BOARD.minCols; cols<=BOARD.maxCols; cols++){
          const g=attempt(rows,cols); if(g){ grid=g; chosenCols=cols; BOARD.rows=rows; break; }
        }
        if(grid) break;
      }
    }
    if(!grid){ grid=attempt(BOARD.maxRows,BOARD.maxCols)||[]; chosenCols=BOARD.maxCols; }
    state.grid=grid; state.cols=chosenCols;
  }

  function centerGridRows(){
    const cols = state.cols;
    for(let r=0;r<state.grid.length;r++){
      let content = state.grid[r].filter(c=>c.type!=="filler");
      const pad = Math.max(0, Math.floor((cols - content.length)/2));
      const newRow = Array.from({length:cols},()=>({ch:"",type:"filler",revealed:true}));
      for(let i=0;i<content.length && (pad+i)<cols;i++) newRow[pad+i]=content[i];
      state.grid[r] = newRow;
    }
  }

  function centerGridVertically(){
    const rows = state.grid.length;
    if(rows < 3) return;
    const contentRows = [];
    for(let r=0;r<rows;r++){
      const hasContent = state.grid[r].some(c=>c.type!=='filler');
      if(hasContent) contentRows.push(r);
    }
    if(contentRows.length === 1){
      const src = contentRows[0];
      const mid = Math.floor(rows/2);
      if(src !== mid){
        const tmp = state.grid[mid];
        state.grid[mid] = state.grid[src];
        state.grid[src] = tmp;
      }
    }
  }

  function renderBoard(){
    boardEl.innerHTML=""; const cols=state.cols||BOARD.cols; boardEl.style.setProperty("--cols",cols);
    for(let r=0;r<state.grid.length;r++){
      for(let c=0;c<cols;c++){
        const cell = state.grid[r][c];
        const el = document.createElement("div");
        const classes=["cell"];
        if(cell.type==="filler") classes.push("filler");
        if(cell.type==="space") classes.push("space");
        if(cell.type==="letter") classes.push("letter");
        if(cell.type==="punct") classes.push("punct");
        if((cell.type==="letter"||cell.type==="punct") && cell.revealed) classes.push("revealed");
        el.className=classes.join(" ");
        el.textContent=(cell.type==="letter"&&cell.revealed)?cell.ch:(cell.type==="punct"?cell.ch:"");
        boardEl.appendChild(el);
      }
    }
  }

  function renderPlayers(){
    playersBoard.innerHTML="";
    for(let i=0;i<state.players;i++){
      const d=document.createElement("div"); d.className="player"+(i===state.currentPlayer?" active":"");
      d.innerHTML = `<b>Player ${i+1}</b><span>$${dollars(state.banks[i])}</span>`;
      playersBoard.appendChild(d);
    }
  }

  // -------- Wheel drawing --------
  function wrapText(ctx,text,x,y,maxW,lineH){
    const words = text.split(" ");
    let line = "", lines = [];
    for(const w of words){
      const test = line ? (line+" "+w) : w;
      if(ctx.measureText(test).width > maxW){
        lines.push(line); line = w;
      } else { line = test; }
    }
    if(line) lines.push(line);
    lines.forEach((ln,i)=>ctx.fillText(ln,x,y+i*lineH));
  }

  
  function drawWheel(){
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const outerR = Math.min(W,H)/2 - 16, innerR = outerR*0.32;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(state.rotation);

    // Vivid palette similar to WoF
    const cashPalette = [
      '#e74c3c','#f1c40f','#2ecc71','#3498db','#9b59b6','#e67e22',
      '#1abc9c','#ff6f61','#ffd166','#06d6a0','#118ab2','#d881f8',
      '#f72585','#4cc9f0','#90be6d','#f8961e'
    ];
    const special = {
      bankrupt: {fill:'#000', text:'#fff'},
      lose: {fill:'#f4f1ea', text:'#111'},
      clue: {fill:'#c2185b', text:'#fff'}
    };
    function textColorFor(hex){
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      const L = (0.299*r + 0.587*g + 0.114*b)/255;
      return L > 0.6 ? '#000' : '#fff';
    }
    function fitText(ctx, text, maxWidth, maxLines){
      let fontPx = 26;
      const words = (text||'').split(/\s+/);
      const canWrap = words.length > 1;
      const measure = (t)=>ctx.measureText(t).width;
      function wrap(px){
        ctx.font = `bold ${px}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
        if(!canWrap){ return {lines:[text], tooWide: measure(text) > maxWidth}; }
        const lines=[]; let line="";
        for(const w of words){
          const test = line ? (line+" "+w) : w;
          if(measure(test) > maxWidth){
            if(line){ lines.push(line); line = w; } else { lines.push(w); line=""; }
          } else { line = test; }
        }
        if(line) lines.push(line);
        return {lines, tooWide: lines.some(l=>measure(l)>maxWidth) || lines.length>maxLines};
      }
      let wrapped = wrap(fontPx);
      while(wrapped.tooWide && fontPx>10){ fontPx -= 1; wrapped = wrap(fontPx); }
      return {lines:wrapped.lines.slice(0,maxLines), fontPx};
    }

    // Draw wedges
    for(let i=0;i<wheelWedges.length;i++){
      const w = wheelWedges[i];
      const a0 = i*sliceAngle, a1 = a0 + sliceAngle;
      let fill, labelColor;
      if(w.type==='cash'){ fill = cashPalette[i % cashPalette.length]; labelColor = textColorFor(fill); }
      else if(w.type==='bankrupt'){ fill = special.bankrupt.fill; labelColor = special.bankrupt.text; }
      else if(w.type==='lose'){ fill = special.lose.fill; labelColor = special.lose.text; }
      else if(w.type==='clue'){ fill = special.clue.fill; labelColor = special.clue.text; }
      else { fill = '#146c43'; labelColor = '#fff'; }

      ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,outerR,a0,a1); ctx.closePath();
      ctx.fillStyle=fill; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.lineWidth=1.25; ctx.stroke();

      // Clip wedge for label
      ctx.save();
      ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,outerR,a0,a1); ctx.closePath();
      ctx.clip();

      // Label
      const mid=a0+sliceAngle/2;
      ctx.rotate(mid);
      const rLabel = (outerR+innerR)/2;
      const availableArc = rLabel * (sliceAngle - 0.1);
      const fit = fitText(ctx, w.label, availableArc, 2);
      ctx.translate(rLabel, 0); ctx.rotate(Math.PI/2);
      ctx.fillStyle=labelColor;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `bold ${fit.fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
      const lineH = fit.fontPx * 0.9;
      if(fit.lines.length===1){
        ctx.fillText(fit.lines[0], 0, 0);
      } else {
        ctx.fillText(fit.lines[0], 0, -lineH/2);
        ctx.fillText(fit.lines[1], 0, lineH/2);
      }
      ctx.restore();
    }

    // Hub
    ctx.beginPath(); ctx.arc(0,0,innerR,0,Math.PI*2); ctx.fillStyle='#0a2a1e'; ctx.fill();
    ctx.strokeStyle='#d3af5e'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle='#d3af5e'; ctx.font="800 18px ui-sans-serif"; ctx.textAlign='center';
    ctx.fillText('NEUROLOGY',0,14);
    ctx.restore();
  }

  
  function wedgeAtPointer(){
    // Pointer is fixed at 12 o'clock (top). Canvas rotates clockwise for positive angles.
    // Convert that fixed pointer direction into the wheel's LOCAL (unrotated) frame by subtracting the wheel rotation.
    const TWO_PI = Math.PI * 2;
    const slice = sliceAngle;
    // wheel rotation (clockwise, in radians)
    const theta = state.rotation || 0;
    // pointer angle in screen coords relative to 3 o'clock = -Ï€/2 (top)
    // local angle = screen angle - theta (undo the wheel's clockwise rotation)
    let local = (-Math.PI / 2) - theta;
    // normalize to [0, 2Ï€)
    local = local % TWO_PI; if (local < 0) local += TWO_PI;
    // choose the wedge that CONTAINS this angle
    let idx = Math.floor(local / slice);
    if (idx < 0) idx = 0;
    idx = idx % wheelWedges.length;
    return idx;
};


function drawPreview(){
    const tmp=document.createElement('canvas');
    const W=canvas.width, H=canvas.height;
    tmp.width=W; tmp.height=H;
    const tctx=tmp.getContext('2d');
    tctx.drawImage(canvas,0,0);
    const crop = 90;
    const scale = peekCanvas.width / W;
    const destH = Math.round(crop * scale);
    peekCanvas.height = destH;
    const pcx = peekCanvas.getContext('2d');
    pcx.clearRect(0,0,peekCanvas.width,peekCanvas.height);
    pcx.drawImage(tmp, 0,0, W, crop, 0,0, peekCanvas.width, destH);
    const idx = wedgeAtPointer();
    peekLabel.textContent = wheelWedges[idx].label || "";
  }

  // -------- Gameplay --------
  function resetKeyboard(enabled=true){
    keyboardEl.innerHTML="";
    LETTERS.forEach(L=>{
      const b=document.createElement('button');
      b.textContent=L;
      
    b.setAttribute('data-letter', L);
    try{
      if(state.guessedCorrect && state.guessedCorrect.has(L)){
        b.classList.add('guess-correct'); b.disabled = true;
      } else if(state.guessedWrong && state.guessedWrong.has(L)){
        b.classList.add('guess-wrong'); b.disabled = true;
      }
    }catch(e){}b.setAttribute('data-letter', L);
let enable = enabled && !state.guessed.has(L);
      if(enabled){
        if(state.canGuessConsonant){
          enable = enable && !VOWELS.has(L); // consonants only
        } else if(state.canBuyVowel){
          enable = enable && VOWELS.has(L);  // vowels only
        } else {
          enable = false; // nothing selectable
        }
      }
      b.disabled = !enable;
      b.addEventListener('click', ()=>{
        if(b.disabled) return;
        if(state.canGuessConsonant && !VOWELS.has(L)){
          handleLetterGuess(L);
        } else if(state.canBuyVowel && VOWELS.has(L)){
          purchaseVowel(L);
        }
      });
      keyboardEl.appendChild(b);
    });
}

  function revealMatching(L){
    let hits=0;
    for(const row of state.grid){
      for(const cell of row){
        if(cell.type==='letter' && cell.ch===L && !cell.revealed){
          cell.revealed=true; hits++;
        }
      }
    }
    renderBoard();
    return hits;
  }

  function allRevealed(){
    for(const row of state.grid){
      for(const cell of row){
        if(cell.type==='letter' && !cell.revealed) return false;
      }
    }
    return true;
  }

  function handleLetterGuess(L){
    try{ SFX.ensureReady(); }catch(e){}
if(state.guessed.has(L)) return;
    state.guessed.add(L);
    const hits = revealMatching(L);
    if(hits>0){
      
      
      try{ state.guessedCorrect.add(L); }catch(e){}
      try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`); if(btn){ btn.classList.add('guess-correct'); btn.disabled = true; } }catch(e){}// mark letter as correct
      try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`); if(btn){ btn.classList.add('guess-correct'); btn.disabled = true; } }catch(e){}
try{ SFX.ding(); }catch(e){}
      const earned = hits*(state.currentCash||0);
      state.banks[state.currentPlayer]+=earned;
      renderPlayers();
      setStatus(`${CPL()} found ${hits} Ã— ${L} for $${dollars(earned)}.`);
      if(allRevealed()){ celebrateWin(); return; }
      state.canGuessConsonant=false;
      resetKeyboard(false);
      buyVowelBtn.disabled = (state.players>1) || (state.banks[state.currentPlayer] < state.vowelPrice);
      spinBtn.disabled = false;
    } else {
            
      
      try{ state.guessedWrong.add(L); }catch(e){}
      try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`); if(btn){ btn.classList.add('guess-wrong'); btn.disabled = true; } }catch(e){}// mark letter as wrong
      try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`); if(btn){ btn.classList.add('guess-wrong'); btn.disabled = true; } }catch(e){}
try{ SFX.buzz(); }catch(e){}
if(state.players===1){
      setStatus(`No ${L}'s. Spin again.`);
      state.canGuessConsonant=false; resetKeyboard(false);
      buyVowelBtn.disabled=true; spinBtn.disabled=false;
    } else {
      setStatus(`${CPL()} guessed ${L}: none found. Turn passes.`);
      endTurn();
    }
    }
  }

  function purchaseVowel(L){
    try{ SFX.ensureReady(); }catch(e){}
if(!VOWELS.has(L)) return;
    if(state.banks[state.currentPlayer] < state.vowelPrice) return;
    state.banks[state.currentPlayer] -= state.vowelPrice;
    renderPlayers();
    const hits = revealMatching(L);
    setStatus(`Purchased ${L} for $${state.vowelPrice}. ${hits>0?hits+' revealed.':'None found.'}`);
    
    
    
    try{ (hits>0 ? state.guessedCorrect : state.guessedWrong).add(L); }catch(e){}
    try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`);
         if(btn){ btn.classList.add(hits>0 ? 'guess-correct' : 'guess-wrong'); btn.disabled = true; } }catch(e){}try{ const btn = keyboardEl.querySelector(`[data-letter="${L}"]`);
         if(btn){ btn.classList.add(hits>0 ? 'guess-correct' : 'guess-wrong'); btn.disabled = true; } }catch(e){}
try{ if(hits>0) SFX.ding(); else SFX.buzz(); }catch(e){} 
state.canBuyVowel=false;
    resetKeyboard(false);
    buyVowelBtn.disabled = (state.players>1) || (state.banks[state.currentPlayer] < state.vowelPrice);
    spinBtn.disabled = false;
    if(hits===0){ endTurn(); } else { if(allRevealed()) celebrateWin(); }
  }

  function celebrateWin(){
    setStatus(`${CPL()} solved it! ðŸŽ‰`);
    state.canGuessConsonant=false; state.canBuyVowel=false;
    buyVowelBtn.disabled=true; spinBtn.disabled=true;
  }

  function endTurn(){
    state.canGuessConsonant=false; state.canBuyVowel=false; resetKeyboard(false);
    buyVowelBtn.disabled=true; spinBtn.disabled=false;
    if(state.players>1){
      state.currentPlayer = (state.currentPlayer+1)%state.players;
      renderPlayers(); drawPreview();
      setStatus(`${CPL()} - your turn. Spin the wheel.`);
    }
  }

  
  function animateSpin(){
    if(state.spinning) return;
    state.spinning = true;
try{ SND_.ensureReady(); }catch(e){}
SND_.start(0);
_woN_startClunkSim();
    _woN_startClunkSim();
    _woN_initAudio();
    state._tickIdx = _woN_currentIndex();
    _woN_startTickLoop();
    _woN_initAudio();
    state._tickIdx = _woN_currentIndex();state._tickIdx = _woN_currentIndex();
    spinBtn.disabled = true;
    buyVowelBtn.disabled = true;
    setStatus(`${CPL()} is spinning...`);

    // Fullscreen overlay clone
    const ghost = wheelWrap.cloneNode(true);
    ghost.classList.remove('rest');
    ghost.classList.add('spin','fullscreen');
    document.body.appendChild(ghost);

    const ghostCanvas = ghost.querySelector('#wheelCanvas');
    const gctx = ghostCanvas.getContext('2d');

    // Snapshot current wheel
    const snap = document.createElement('canvas');
    snap.width = canvas.width; snap.height = canvas.height;
    snap.getContext('2d').drawImage(canvas,0,0);
    ghostCanvas.width = canvas.width; ghostCanvas.height = canvas.height;

    // Overlay pointer
    const overlayPtr = document.createElement('div');
    overlayPtr.className = 'overlayPointer';
    document.body.appendChild(overlayPtr);
    function positionOverlayPtr(){
      const r = ghostCanvas.getBoundingClientRect();
      overlayPtr.style.position='fixed';
      overlayPtr.style.left = `${Math.round(r.left + r.width/2 - 10)}px`;
      overlayPtr.style.top = `${Math.round(r.top + 6)}px`;
    }
    positionOverlayPtr();
    window.addEventListener('resize', positionOverlayPtr);

    // Animation params
    const startRot = state.rotation;
    const extraTurns = 12 + Math.random()*6;
    const endRot = startRot + extraTurns * Math.PI*2 + Math.random()*Math.PI*2;
    const duration = 3500;
    const t0 = performance.now();
    const twoPI = Math.PI*2;
    const easeOutCubic = (x)=>1 - Math.pow(1-x, 3);

    function frame(now){
      const t = Math.min(1, (now - t0)/duration);
      const eased = easeOutCubic(t);
      const rot = startRot + (endRot - startRot) * eased;

      SND_.frame(rot);
// Draw rotated snapshot
      const W=ghostCanvas.width, H=ghostCanvas.height, cx=W/2, cy=H/2;
      gctx.clearRect(0,0,W,H);
      gctx.save(); gctx.translate(cx,cy); gctx.rotate(rot - startRot);
      gctx.drawImage(snap, -W/2, -H/2);
      gctx.restore();

      if(t < 1){
        requestAnimationFrame(frame);
      } else {
        state.rotation = ((rot % twoPI) + twoPI) % twoPI;
    // tick on sector boundary crossing
    if (state.spinning) {
      if (state._tickIdx === undefined) state._tickIdx = _woN_currentIndex();
      const __cur = _woN_currentIndex();
      if (__cur !== state._tickIdx) { _woN_tickClunk(); state._tickIdx = __cur; }
    }
        drawWheel();
        drawPreview();
        setTimeout(()=>{
          document.body.removeChild(ghost);
          if(overlayPtr && overlayPtr.parentNode) overlayPtr.parentNode.removeChild(overlayPtr);
          window.removeEventListener('resize', positionOverlayPtr);
          onSpinComplete();
        }, 2000);
      }
    }
    requestAnimationFrame(frame);
  }


  function onSpinComplete(){
  if(!state._applausePlayed){ try{
state._applausePlayed=true; }catch(e){} }
    state.spinning = false;
_woN_stopClunkSim(false);
_woN_stopTickLoop();
_woN_stopClunkSim(true);
    _woN_stopClunkSim(true);
    _woN_stopTickLoop();
    delete state._tickIdx;
    const idx = wedgeAtPointer();
    const w = wheelWedges[idx];
    
  // End-of-spin SFX: sad trombone on bankrupt/lose, applause otherwise
  try{
    if(w && (w.type==='bankrupt' || w.type==='lose')){
      if(window.SFX && SFX.whomp) SFX.whomp();
    } else {
      if(window._woN_applause) _woN_applause();
    }
  }catch(e){} 
drawPreview(); // ensure peek shows landed wedge

    if(!w){ 
      // Fallback: allow another spin
      spinBtn.disabled = false;
      setStatus(`${CPL()} - spin again.`);
      return;
    }

    if(w.type === 'cash'){
      state.currentCash = w.value || 0;
      state.canGuessConsonant = true;
      state.canBuyVowel = false;
      resetKeyboard(true);
      buyVowelBtn.disabled = (state.players>1) || (state.banks[state.currentPlayer] < state.vowelPrice);
      setStatus(`${CPL()} landed on $${dollars(state.currentCash)}. Choose a consonant.`);
      // keep spin disabled until guess resolves
    } else if(w.type === 'bankrupt'){
      state.currentCash = 0;
      state.banks[state.currentPlayer] = 0;
      renderPlayers();
      setStatus(`BANKRUPT! ${state.players>1 ? "Turn passes." : ""}`);
      endTurn();
    } else if(w.type === 'lose'){
      setStatus(`Lose a turn.${state.players>1 ? " Turn passes." : ""}`);
      endTurn();
    } else if(w.type === 'clue'){
      state.currentCash = 0;
      state.canGuessConsonant = false;
      state.canBuyVowel = false;
      resetKeyboard(false);
      buyVowelBtn.disabled = true;
      // Open the clue/hint modal (disabled in MP)
      openClue();
      // After viewing, allow a new spin (no pass in SP; MP rule doesn't grant extra action)
      spinBtn.disabled = false;
      if(state.players>1){
        // In multiplayer, opening clue is disabled; we still advance turn to keep pace
        setStatus(`Clue wedge (disabled in multiplayer). Turn passes.`);
        endTurn();
      } else {
        setStatus(`Clue wedge. You may buy the hint ($${state.cluePrice}) or spin again.`);
      }
    } else {
      // Unknown wedge type: just allow spinning again
      setStatus(`${CPL()} - spin again.`);
      spinBtn.disabled = false;
    }
  }

// -------- Clue & Solve --------
  function openClue(){
    const p = puzzles[state.puzzleIndex];
    if(state.cluePurchased){
      clueContent.textContent = p.clue || "No clue text provided.";
      buyClueBtn.style.display = 'none';
    } else {
      clueContent.textContent = (p.clue || "No clue text provided.") + "  (" + (state.players>1 ? "Disabled in multiplayer" : "Costs $" + state.cluePrice) + ")";
      buyClueBtn.style.display = (state.players>1) ? 'none' : 'inline-block';
    }
    document.getElementById('clueModal').classList.add('show');
  }
  function closeClue(){ document.getElementById('clueModal').classList.remove('show'); }
  buyClueBtn.addEventListener('click', ()=>{
    if(state.players>1 || state.cluePurchased) return;
    if(state.banks[state.currentPlayer] < state.cluePrice) return;
    state.banks[state.currentPlayer] -= state.cluePrice;
    renderPlayers();
    state.cluePurchased = true;
    openClue();
  });
  closeClueBtn.addEventListener('click', closeClue);

  function openSolve(){
    solveInput.value='';
    document.getElementById('solveModal').classList.add('show');
    setTimeout(()=>solveInput.focus(), 50);
  }
  function closeSolve(pass){
    document.getElementById('solveModal').classList.remove('show');
    if(pass && state.players>1) endTurn();
  }
  function submitSolve(){
    const guess=(solveInput.value||'').trim().toUpperCase().replace(/\s+/g,' ');
    const ans = state.answer.toUpperCase();
    if(guess===ans){
      for(const row of state.grid){
        for(const cell of row){
          if(cell.type==='letter') cell.revealed=true;
        }
      }
      renderBoard();
      closeSolve(false);
      celebrateWin();
    } else {
      closeSolve(true);
      setStatus(`Incorrect solution by ${CPL()}. Turn passes.`);
    }
  }
  
  buyVowelBtn.addEventListener('click', ()=>{
    if(state.players>1) return;
    if(state.banks[state.currentPlayer] < state.vowelPrice) return;
    state.canGuessConsonant = false;
    state.canBuyVowel = true;
    resetKeyboard(true);
    setStatus(`Choose a vowel to buy for $${state.vowelPrice}.`);
  });
solveBtn.addEventListener('click', openSolve);
  submitSolveBtn.addEventListener('click', submitSolve);
  closeSolveBtn.addEventListener('click', ()=>closeSolve(true));

// -------- Options --------
  function populateCategorySelect(){
    if(!categorySelect) return;
    categorySelect.innerHTML = '';
    const optRand = document.createElement('option');
    optRand.value = 'RANDOM'; optRand.textContent = 'RANDOM';
    categorySelect.appendChild(optRand);
    (state.categories||[]).forEach(cat=>{
      const o = document.createElement('option'); o.value = cat; o.textContent = cat; categorySelect.appendChild(o);
    });
    categorySelect.value = state.selectedCategory || 'RANDOM';
  }
  optionsBtn.addEventListener('click', ()=>{
    const rads = Array.from(optionsModal.querySelectorAll('.options input[type=radio]'));
    rads.forEach(r => r.checked = (parseInt(r.value,10) === state.players));
    populateCategorySelect();
    optionsModal.classList.add('show');
  });
  saveOptionsBtn.addEventListener('click', ()=>{
    const sel = Array.from(optionsModal.querySelectorAll('.options input[type=radio]')).find(r=>r.checked);
    let n = Math.min(3, Math.max(1, parseInt(sel ? sel.value : '1', 10)));
    state.players = n; state.banks=[0,0,0]; state.currentPlayer=0;
    if(categorySelect){ state.selectedCategory = categorySelect.value || 'RANDOM'; }
    renderPlayers();
    setStatus(`Players set to ${n}.`);
    optionsModal.classList.remove('show');
  });
  cancelOptionsBtn.addEventListener('click', ()=> optionsModal.classList.remove('show'));

  // -------- New Puzzle / Init --------
  function newPuzzle(index){
    if(!puzzles.length){ puzzles = seedPuzzles.slice(); }
    state.cols = BOARD.minCols; state.guessed.clear(); state.cluePurchased=false;
    let source = puzzles;
    let cat = state.selectedCategory || 'RANDOM';
    if(cat === 'RANDOM' && state.categories && state.categories.length){ cat = state.categories[Math.floor(Math.random()*state.categories.length)]; }
    if(cat && cat !== 'RANDOM'){
      const filtered = puzzles.filter(p=>p.category===cat);
      if(filtered.length) source = filtered;
    }
    // Enforce minimum 5 letters in the answer (ignore spaces/punct)
    let eligible = source.filter(p=>letterCount(p.answer) >= 5);
    if(!eligible.length){ eligible = puzzles.filter(p=>letterCount(p.answer) >= 5); }
    if(!eligible.length){ eligible = source; }
    const idx = (typeof index === "number") ? index : Math.floor(Math.random()*eligible.length);
    state.puzzleIndex = idx;
    const p = eligible[idx];
    state.answer = (p.answer||"").toUpperCase();
    categoryTopEl.textContent = (p.category ? `Category: ${p.category}` : "Category: â€”");
    layoutBoard(state.answer);
    centerGridRows();
    centerGridVertically();
    renderBoard();
    renderPlayers();
    resetKeyboard(false);
    buyVowelBtn.disabled = (state.players>1) || state.banks[state.currentPlayer] < state.vowelPrice;
    drawWheel(); drawPreview();
    setStatus(`Choose players, then spin to begin!`);
    spinBtn.disabled=false;
  }
  newBtn.addEventListener('click', ()=> newPuzzle());

  // Start modal logic
  startSpinBtn.addEventListener('click', () => {
    const sel = startPlayerRadios.find(r=>r.checked);
    const n = sel ? parseInt(sel.value,10) : 1;
    state.players = Math.min(3, Math.max(1, n||1));
    state.banks = [0,0,0];
    state.currentPlayer = 0;
    renderPlayers();
    startModal.classList.remove('show');
    animateSpin();
  });
  spinBtn.addEventListener('click', animateSpin);

  async function init(){
    puzzles = await loadCsvPuzzles("wheelclues.csv");
    if(!puzzles.length) puzzles = seedPuzzles.slice();
    state.categories = Array.from(new Set(puzzles.map(p=>p.category).filter(Boolean))).sort();
    renderPlayers();
    newPuzzle(0);
    // start modal already shown
  }
  init();

function flashLandedWedge(idx){
  try{
    const el = document.querySelector(`[data-wedge-index="${'${idx}'}"]`);
    if(!el) return;
    el.classList.add('landed-flash');
    setTimeout(()=>el.classList.remove('landed-flash'), 500);
  }catch(e){}
}


function readLandedWedge(cb){
  // Wait two frames to allow any easing/rounding to finish, then sample.
  requestAnimationFrame(()=>{
    requestAnimationFrame(()=>{
      const i = wedgeAtPointer();
      if (typeof cb === 'function') cb(i);
    });
  });
}



// ---- Deep "clunk" tick using WebAudio ----
let _woN_audioCtx = null;
let _woN_comp = null;          // dynamics compressor
let _woN_master = null;        // master gain

function _woN_initAudio(){
  try{
    if(!_woN_audioCtx) {
      _woN_audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    // Some browsers require resume after a gesture
    if(_woN_audioCtx.state === 'suspended'){
      _woN_audioCtx.resume().catch(()=>{});
    }
    if(!_woN_master){
      _woN_master = _woN_audioCtx.createGain();
      _woN_master.gain.value = 0.7; // overall volume
      _woN_comp = _woN_audioCtx.createDynamicsCompressor();
      _woN_comp.threshold.value = -16;
      _woN_comp.knee.value = 20;
      _woN_comp.ratio.value = 8;
      _woN_comp.attack.value = 0.003;
      _woN_comp.release.value = 0.06;
      _woN_master.connect(_woN_comp);
      _woN_comp.connect(_woN_audioCtx.destination);
    }
  }catch(e){/* ignore */}
}

// Play a low, punchy "clunk": short pitchâ€‘dropping oscillator + filtered noise burst

function _woN_tickClunk(){
  // Crisp "click": ultra-short triangle blip + filtered noise tick
  if(!_woN_audioCtx) return;
  const ctx = _woN_audioCtx;
  const t0 = ctx.currentTime + 0.001;

  // High-pass to keep it snappy, no bass tail
  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 1800;
  hp.Q.value = 0.7;

  const mix = ctx.createGain();
  mix.gain.value = 0.65; // overall click loudness
  mix.connect(hp);
  hp.connect(_woN_master);

  // Very short oscillator blip (~2.6 kHz) with fast decay
  const o = ctx.createOscillator();
  o.type = 'triangle';
  o.frequency.setValueAtTime(2600, t0);
  const go = ctx.createGain();
  go.gain.setValueAtTime(0.35, t0);
  go.gain.exponentialRampToValueAtTime(0.001, t0 + 0.03);
  o.connect(go); go.connect(mix);
  o.start(t0); o.stop(t0 + 0.035);

  // Tiny noise tick for attack
  const buffer = ctx.createBuffer(1, 1024, 44100);
  const data = buffer.getChannelData(0);
  for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * 0.9; }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;
  const gn = ctx.createGain();
  gn.gain.setValueAtTime(0.15, t0);
  gn.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.02);
  noise.connect(gn); gn.connect(mix);
  noise.start(t0); noise.stop(t0 + 0.025);
}
function _woN_currentIndex(){
  const TWO_PI = Math.PI * 2;
  const slice = sliceAngle;
  const theta = state.rotation || 0;
  let local = (-Math.PI / 2) - theta;
  local = local % TWO_PI; if (local < 0) local += TWO_PI;
  let idx = Math.floor(local / slice);
  return ((idx % wheelWedges.length) + wheelWedges.length) % wheelWedges.length;
}


// ---- Frame-based tick loop: fire clunk every time we enter a new wedge while spinning ----
let _woN_tickLoopActive = false;
function _woN_startTickLoop(){
  if(_woN_tickLoopActive) return;
  _woN_tickLoopActive = true;
  // Initialize last index so we don't fire immediately unless we actually cross
  if (state._tickIdx === undefined) state._tickIdx = _woN_currentIndex();
  const step = ()=>{
    if(!_woN_tickLoopActive) return;
    try{
      const cur = _woN_currentIndex();
      if(cur !== state._tickIdx){
        _woN_tickClunk();
        state._tickIdx = cur;
      }
    }catch(e){ /* no-op */ }
    requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}
function _woN_stopTickLoop(){
  _woN_tickLoopActive = false;
  delete state._tickIdx;
}




// ---- Simulated click cadence during spin (decaying tempo) ----
let _woN_simHandle = null;
let _woN_simActive = false;

function _woN_startClunkSim(){
  _woN_initAudio();
  if (_woN_simActive) return;
  _woN_simActive = true;
  let delay = 55;               // ms between clicks at start
  const mul = 1.09;             // growth per click -> slows down
  const maxDelay = 480;         // cap while spinning
  const step = () => {
    if(!_woN_simActive) return;
    try { _woN_tickClunk(); } catch(e){}
    delay = Math.min(maxDelay, Math.round(delay * mul));
    _woN_simHandle = setTimeout(step, delay);
  };
  _woN_simHandle = setTimeout(step, delay);
}

function _woN_stopClunkSim(forceFinal=true){
  if(_woN_simHandle){ try{ clearTimeout(_woN_simHandle);}catch(e){} _woN_simHandle = null; }
  const wasActive = _woN_simActive;
  _woN_simActive = false;
  if(forceFinal && wasActive){
    try { _woN_tickClunk(); } catch(e){}
  }
}
</script>

<script>
// Simple synthesized applause (noise + bursts) ~1.5s
function _woN_applause(){
  _woN_initAudio();
  if(!_woN_audioCtx) return;
  const ctx = _woN_audioCtx;
  const t0 = ctx.currentTime + 0.01;

  // Continuous crowd noise with gentle envelope
  const dur = 1.6;
  const noiseBuf = ctx.createBuffer(1, 44100*dur, 44100);
  const arr = noiseBuf.getChannelData(0);
  for(let i=0;i<arr.length;i++){ arr[i] = (Math.random()*2-1) * 0.4; }
  const noise = ctx.createBufferSource();
  noise.buffer = noiseBuf;

  // Filtering for 'crowd' timbre
  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 1200;
  bp.Q.value = 0.6;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, t0);
  g.gain.linearRampToValueAtTime(0.6, t0 + 0.25);
  g.gain.linearRampToValueAtTime(0.35, t0 + 0.9);
  g.gain.linearRampToValueAtTime(0.0001, t0 + dur);

  noise.connect(bp); bp.connect(g); g.connect(_woN_master);
  noise.start(t0); noise.stop(t0 + dur + 0.02);

  // Random handclap-like bursts
  const bursts = 12;
  for(let k=0;k<bursts;k++){
    const dt = (Math.random()*1.2); // distribute over first ~1.2s
    const burst = ctx.createBufferSource();
    const b = ctx.createBuffer(1, 2205, 44100); // 50ms
    const d = b.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * (1 - i/d.length); }
    burst.buffer = b;
    const hpf = ctx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = 1200;
    const gb = ctx.createGain();
    gb.gain.setValueAtTime(0.5*Math.random()+0.2, t0+dt);
    gb.gain.exponentialRampToValueAtTime(0.0001, t0+dt+0.08+Math.random()*0.05);
    burst.connect(hpf); hpf.connect(gb); gb.connect(_woN_master);
    burst.start(t0+dt); burst.stop(t0+dt+0.12);
  }
}
</script>



<!-- Fresh sound system: wedge-crossing clicks driven by the actual animated angle (no buffering) -->
<script>
const SND_ = (()=>{
  let ctx=null, master=null;
  let active=false;
  let lastWedge = null;
  let actives = []; // track playing nodes for instant stop

  function init(){
    if(!ctx){
      try{ ctx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ return; }
    }
    if(ctx && ctx.state === 'suspended'){ try{ ctx.resume(); }catch(e){} }
    if(!master && ctx){
      master = ctx.createGain();
      master.gain.value = 0.7;
      master.connect(ctx.destination);
    }
  }
  function stopAllNow(){
    const t = ctx ? ctx.currentTime : 0;
    actives.forEach(n=>{
      try{ if(n.stop) n.stop(t); }catch(e){}
      try{ if(n.disconnect) n.disconnect(); }catch(e){}
    });
    actives = [];
  }
  function click(nowFinal=false){
    if(!ctx || !master) return;
    const t0 = ctx.currentTime; // start immediately, no buffering

    // crisp short click (triangle + tiny noise, high-passed)
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1700;
    hp.Q.value = 0.9;

    const mix = ctx.createGain();
    mix.gain.value = nowFinal ? 0.7 : 0.6; // tiny boost for final click
    mix.connect(hp);
    hp.connect(master);

    const o = ctx.createOscillator();
    o.type = 'triangle';
    o.frequency.setValueAtTime(2400, t0);
    const go = ctx.createGain();
    go.gain.setValueAtTime(0.34, t0);
    go.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.018);
    o.connect(go); go.connect(mix);

    const noise = ctx.createBufferSource();
    const buf = ctx.createBuffer(1, 512, 44100);
    const d = buf.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * 0.8; }
    noise.buffer = buf;
    const gn = ctx.createGain();
    gn.gain.setValueAtTime(0.14, t0);
    gn.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.014);
    noise.connect(gn); gn.connect(mix);

    // track nodes so we can cancel instantly
    actives.push(o, noise, go, gn, mix, hp);

    o.start(t0);  o.stop(t0 + 0.022);
    noise.start(t0); noise.stop(t0 + 0.018);

    // clean up soon after
    const endT = t0 + 0.03;
    const cleanup = ()=>{
      // remove finished nodes
      actives = actives.filter(n=>{
        try{
          // nodes will be GC'd; we just drop references
          return false;
        }catch(e){ return false; }
      });
    };
    // best-effort micro-timeout; if blocked it doesn't queue audio
    try{ setTimeout(cleanup, 40); }catch(e){}
  }
  function normalize(a){ const TWO=Math.PI*2; a%=TWO; if(a<0)a+=TWO; return a; }
  function wedgeIndexForAngle(rot){
    const TWO = Math.PI*2;
    const slice = window.sliceAngle || 0;
    if(!slice || !window.wheelWedges || !wheelWedges.length) return null;
    let local = (-Math.PI/2) - rot;         // pointer in wheel frame
    local = normalize(local);
    let idx = Math.floor(local / slice);    // containing wedge
    idx = ((idx % wheelWedges.length) + wheelWedges.length) % wheelWedges.length;
    return idx;
  }
  return { ensureReady(){ try{ init(); }catch(e){} }, start(initialRot){
      init();
      active = true;
      lastWedge = wedgeIndexForAngle(initialRot||0);
    },
    frame(rot){
      if(!active) return;
      const idx = wedgeIndexForAngle(rot);
      if(idx==null) return;
      if(lastWedge===null){ lastWedge=idx; return; }
      if(idx!==lastWedge){
        lastWedge = idx;
        click(false); // immediate click, no buffering
      }
    },
    stop(playFinal=true){
      if(!ctx){ return; }
      // final click exactly now, then flush everything
      if(playFinal){ click(true); }
      stopAllNow();
      active = false;
      lastWedge = null;
    }
  };
})();
</script>



<script>
const SFX = (()=>{
  let ctx=null, master=null;
  let actives=[];
  function init(){
    if(!ctx){
      try{ ctx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ return; }
    }
    if(ctx.state==='suspended'){ try{ ctx.resume(); }catch(e){} }
    if(!master && ctx){ master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination); }
  }
  function stopAllNow(){
    const t = ctx ? ctx.currentTime : 0;
    actives.forEach(n=>{ try{ if(n.stop) n.stop(t);}catch(e){} try{ if(n.disconnect) n.disconnect(); }catch(e){} });
    actives.length=0;
  }
  function ding(){
    init(); if(!ctx) return;
    const t0 = ctx.currentTime;
    const o = ctx.createOscillator();
    o.type = 'triangle';
    o.frequency.setValueAtTime(1800, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.001, t0);
    g.gain.exponentialRampToValueAtTime(0.5, t0+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.12);
    o.connect(g); g.connect(master);
    actives.push(o,g);
    o.start(t0); o.stop(t0+0.14);
    setTimeout(()=>{ actives=[]; }, 160);
  }
  function buzz(){
    init(); if(!ctx) return;
    const t0 = ctx.currentTime;
    const o = ctx.createOscillator();
    o.type = 'square';
    o.frequency.setValueAtTime(120, t0);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.001, t0);
    g.gain.exponentialRampToValueAtTime(0.5, t0+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.18);
    o.connect(g); g.connect(master);
    actives.push(o,g);
    o.start(t0); o.stop(t0+0.2);
    setTimeout(()=>{ actives=[]; }, 220);
  }
  return { ensureReady(){ try{ init(); }catch(e){} }, ding, buzz, stopAllNow };
})();
</script>


<script>
// One-time audio unlock to satisfy browser autoplay policy
(function(){
  let unlocked = false;
  function unlock(){
    if (unlocked) return;
    try{ if (window.SND_ && SND_.ensureReady) SND_.ensureReady(); }catch(e){}
    try{ if (window.SFX  && SFX.ensureReady)  SFX.ensureReady();  }catch(e){}
    unlocked = true;
    window.removeEventListener('pointerdown', unlock);
    window.removeEventListener('keydown', unlock);
    window.removeEventListener('click', unlock);
    window.removeEventListener('touchstart', unlock, {passive:true});
  }
  window.addEventListener('pointerdown', unlock, {once:true});
  window.addEventListener('keydown', unlock, {once:true});
  window.addEventListener('click', unlock, {once:true});
  window.addEventListener('touchstart', unlock, {once:true, passive:true});
})();
</script>

</body>
</html>