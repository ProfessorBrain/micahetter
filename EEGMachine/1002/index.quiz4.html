<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>EEG Machine</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
/* Quiz panel styles */
#quizPanel{position:fixed;top:64px;right:8px;width:320px;max-width:38vw;background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.12);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.14);display:none; z-index:9999;}
#quizPanel h2{font-size:1.05rem;margin:.2rem 0 .4rem;font-weight:700}
.quiz-step{margin:.6rem 0;border-top:1px dashed rgba(0,0,0,.15);padding-top:.5rem}
.quiz-pills{display:flex;flex-wrap:wrap;gap:.4rem}
.quiz-pill{padding:.28rem .6rem;border-radius:999px;border:1px solid rgba(0,0,0,.2);background:#fff;cursor:pointer;font-size:.9rem}
.quiz-pill.active{background:#eef5ff;border-color:#6aa1ff}
.quiz-pill.correct{background:#e7f8ea;border-color:#4db569}
.quiz-pill.wrong{background:#fde7ea;border-color:#e05757}
#quizBanner{position:absolute;top:10px;right:50%;transform:translateX(50%);background:#0c8;color:#fff;padding:.5rem .8rem;border-radius:.6rem;display:none;box-shadow:0 8px 24px rgba(0,0,0,.2);font-weight:700; z-index:10000;}
#quizControls{display:flex;gap:.5rem;margin-top:.6rem}

/* Stronger Options button */
button.options-strong{
  padding: .45rem .8rem;
  border-radius: .6rem;
  border: 2px solid rgba(0,0,0,.2);
  background: rgba(255,255,255,.85);
  font-weight: 600;
  box-shadow: 0 1px 2px rgba(0,0,0,.06);
  transition: transform .06s ease, box-shadow .12s ease, background .12s ease;
}
button.options-strong:hover{
  transform: translateY(-1px);
  box-shadow: 0 3px 10px rgba(0,0,0,.12);
  background: rgba(255,255,255,.95);
}
button.options-strong:active{
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0,0,0,.08);
}

    :root { 
      --bg:#e9f7e6;
      --grid-major:#2b6f2b;
      --grid-minor:#a9d6a6;
      --trace-blue:#1d49d8;
      --trace-red:#c42424;
      --trace-black:#000000;
      --text:#0b1b12;
      --panel:#f3fbf1;
      --panel-border:#b8d9b3;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.2 system-ui,Segoe UI,Roboto,Arial}
    body{display:flex;flex-direction:column}
    #topbar{display:flex;flex-direction:row;flex-wrap:wrap;gap:.75rem;align-items:flex-end;padding:.5rem .75rem;border-bottom:1px solid var(--panel-border);background:var(--panel);position:sticky;top:0;z-index:2}
    .ctrl{display:flex;flex-direction:column;gap:.25rem;min-width:120px}
    .ctrl label{font-size:12px;opacity:.8;display:block}
    select{background:#fff;color:var(--text);border:1px solid var(--panel-border);border-radius:6px;padding:.3rem .45rem;max-width:200px}
    button{background:#fff;color:var(--text);border:1px solid var(--panel-border);border-radius:6px;padding:.35rem .6rem;cursor:pointer;white-space:nowrap}
    button:hover{filter:brightness(0.98)}
    fieldset{border:1px solid var(--panel-border);border-radius:8px;padding:.35rem .5rem}
    legend{font-size:12px;opacity:.85;padding:0 .25rem}
    .radio{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
    .mini{font-size:12px;padding:.25rem .45rem;border-radius:6px}
    .pill{background:#fff;border:1px solid var(--panel-border);border-radius:999px;padding:.2rem .5rem;font-size:12px;color:#245f24}
    #wrap{position:relative;flex:1;min-height:0}
    #c{width:100%;height:100%;display:block}
    #err{position:absolute;left:8px;bottom:8px;background:#ffefef;border:1px solid #e6b0b0;border-radius:8px;padding:.35rem .55rem;font-size:12px;display:none;color:#7b1b1b}
    .popover{position:fixed;top:56px;right:12px;background:#fff;border:1px solid var(--panel-border);border-radius:8px;padding:.5rem .75rem;box-shadow:0 8px 24px rgba(0,0,0,.08);display:none;z-index:3}
    .popover.open{display:block}
    /* Intro modal */
    .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.25);z-index:5}
    .modal[hidden]{display:none}
    .modal-card{background:#fff;border:1px solid var(--panel-border);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.18);max-width:520px;width:min(92vw,520px);padding:1rem 1.25rem}
    .modal-card h1{margin:0 0 .25rem 0;font-size:22px}
    .modal-card p{margin:.25rem 0;line-height:1.35}
    .modal-card .sub{opacity:.8;font-size:13px}
    .modal-actions{display:flex;justify-content:flex-end;gap:.5rem;margin-top:.75rem}
  </style>

<style id="quiz-style-patch">
.quiz-pill.correct { font-weight: 700; color: #0a0; }
.quiz-pill.wrong { color: #b00; text-decoration: line-through; }
</style>


<style id="quiz-layout-patch">
#quizPanel{ width: 520px; max-width: 92vw; max-height: 80vh; overflow:auto; }
#quizPanel .panel-title{ font-size: 14px; }
.quiz-step{ margin:6px 10px; }
.quiz-step > div:first-child{ font-weight:600; margin-bottom:4px; font-size:13px; }
.quiz-pills{ display:flex; flex-wrap:wrap; gap:8px; }
.quiz-subrow{ display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
.quiz-pill{ padding:2px 10px; border-radius:16px; border:1px solid rgba(0,0,0,.15); background:#f6f7f8; font-size:12px; }
.quiz-pill.active{ box-shadow:0 0 0 2px rgba(0,0,0,.08) inset; }
.quiz-pill.correct{ font-weight:700; color:#0a0; }
.quiz-pill.wrong{ color:#b00; text-decoration:line-through; }
</style>


<style id="quiz-next-hide">
#quizNext{display:none !important;}
</style>

</head>
<body>
  <div id="topbar">
    <div class="ctrl"><label>Montage</label>
      <select id="montageSel">
        <option value="bipolar_longitudinal" selected>Longitudinal (Double Banana)</option>
        <option value="bipolar_transverse">Transverse</option>
        <option value="referential">Reference (ipsilateral ear A1/A2)</option>
        <option value="average">Average reference (AVG)</option>
      </select>
    </div>
    <div class="ctrl"><label>Timebase (mm/sec)</label>
      <select id="timebase">
        <option value="15">15 mm/sec</option>
        <option value="30" selected>30 mm/sec</option>
        <option value="60">60 mm/sec</option>
      </select>
    </div>
    <div class="ctrl"><label>Sensitivity</label>
      <select id="sensitivity">
        <option value="3">3 µV/mm</option>
        <option value="5">5 µV/mm</option>
        <option value="7" selected>7 µV/mm</option>
        <option value="10">10 µV/mm</option>
        <option value="15">15 µV/mm</option>
      </select>
    </div>
    <fieldset id="rhythmFieldset" style="margin:0;display:flex;align-items:center;gap:.4rem;flex:1 1 auto;min-width:240px"><legend>Rhythm / State</legend>
      <div class="radio" id="modeRadios">
        <!-- Order: delta, theta, alpha, beta (leftmost), then awake/drowsy, sleep 1/2, REM, SWS -->
        <label><input type="radio" name="mode" value="delta"> Delta</label>
        <label><input type="radio" name="mode" value="theta"> Theta</label>
        <label><input type="radio" name="mode" value="alpha"> Alpha</label>
        <label><input type="radio" name="mode" value="beta"> Beta</label>
        <label><input type="radio" name="mode" value="awake" checked> Awake</label>
        <label><input type="radio" name="mode" value="drowsy"> Drowsy</label>
        <label><input type="radio" name="mode" value="n1"> Sleep 1</label>
        <label><input type="radio" name="mode" value="n2"> Sleep 2</label>
        <label><input type="radio" name="mode" value="sws"> SWS</label>
        <label><input type="radio" name="mode" value="rem"> REM</label>
        <label class="pill"><input type="checkbox" id="eyesOpen"> Eyes open</label>
      </div>
    </fieldset>
    <div style="margin-left:auto;display:flex;gap:.4rem;align-items:center">
      <button id="play">Pause</button>
      <button id="pathologyBtn" class="options-strong">PATHOLOGY</button>
      <button id="optionsBtn" class="options-strong">Options</button>
    </div>
  </div>

  <!-- Intro modal -->
  <div id="introModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="introTitle">
    <div class="modal-card">
      <h1 id="introTitle">EEG Machine</h1>
      <p class="sub">Created by <strong>Micah Etter, MD</strong></p>
      <p><strong>Disclaimer:</strong> Not for medical use — educational purposes only.</p>
      <div class="modal-actions">
        <button id="introClose">Got it</button>
      </div>
    </div>
  </div>

  <!-- Options modal -->
  <div id="optionsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="optionsTitle" hidden>
    <div class="modal-card">
      <h1 id="optionsTitle">Options</h1>
      <fieldset>
        <legend>Artifacts</legend>
        <div style="display:flex;flex-direction:column;gap:.35rem;margin-top:.25rem">
          <label><input id="blink" type="checkbox"> Eye blinks</label>
          <label><input id="chew" type="checkbox"> Chewing</label>
          <label><input id="sweat" type="checkbox"> Sweat</label>
          <label><input id="pop" type="checkbox"> Electrode pop</label>
          <label><input id="emg" type="checkbox"> EMG</label>
        </div>
      </fieldset>

      <fieldset>
        <legend>Playback speed</legend>
        <div style="display:flex;align-items:center;gap:.6rem;margin-top:.25rem">
          <input id="speedSlider" type="range" min="0.25" max="5" step="0.25" value="1" style="width:260px">
          <output id="speedValue" for="speedSlider">1.00×</output>
        </div>
</fieldset>
      <fieldset>
        <legend>Realism</legend>
        <div style="display:flex;align-items:center;gap:.6rem;margin-top:.25rem">
          <input id="realismSlider" type="range" min="0" max="1" step="0.01" value="0.75" style="width:260px">
          <output id="realismValue" for="realismSlider">75%</output>
        </div>
      </fieldset>

      <div class="modal-actions">
        <button id="optionsClose">Close</button>
      </div>
    </div>
  </div></div>

  <!-- Pathology modal -->
  <div id="pathologyModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="pathologyTitle" hidden>
    <div class="modal-card">
      <h1 id="pathologyTitle">Pathology</h1>
      <fieldset>
        <legend>Potential patterns</legend>
        <div style="display:flex;flex-direction:column;gap:.35rem;margin-top:.25rem">
          <label><input id="gpd" type="checkbox"> Generalized periodic discharges (GPDs)</label>
          <label><input id="lpd" type="checkbox"> Lateralized periodic discharges (LPDs)</label>
        </div>
      </fieldset>
      <div class="modal-actions">
        <button id="startQuizBtn" class="options-strong" onclick="startQuiz()">Start Quiz</button>
        <button id="endQuizBtn" onclick="endQuiz()">End Quiz</button>
        <button id="pathologyClose">Close</button>
      </div>
    </div>
  </div>


  <div id="quizBanner">✔ Correct! New quiz ready.</div>
  <aside id="quizPanel" aria-live="polite">
    <h2>EEG Quiz</h2>
    <div id="quizSteps"></div>
    <div id="quizControls">
      <button id="quizNext">Next</button>
      <button id="quizNew">New Case</button>
    </div>
  </aside>


  <div id="wrap"><canvas id="c"></canvas>
    <div id="err"></div>
  </div>

<script>
/***********************
 * Electrodes & Montages
 ***********************/
const ELECTRODES = [
  "Fp1","F3","C3","P3","O1","F7","T3","T5",
  "Fz","Cz","Pz",
  "Fp2","F4","C4","P4","O2","F8","T4","T6",
  "Oz",
  "A1","A2"
];
const DISPLAY_ORDER = [
  "Fp1","F3","C3","P3","O1","F7","T3","T5",
  "Fz","Cz","Pz",
  "Fp2","F4","C4","P4","O2","F8","T4","T6"
];
const AVERAGE_ORDER = [
  "Fp1","F7","T3","T5",
  "Fp2","F8","T4","T6",
  "F3","C3","P3","O1",
  "F4","C4","P4","O2",
  "Fz","Cz","Pz"
];
const LONGITUDINAL_CHAINS = [
  ["Fp1","F7"],["F7","T3"],["T3","T5"],["T5","O1"],
  ["Fp2","F8"],["F8","T4"],["T4","T6"],["T6","O2"],
  ["Fp1","F3"],["F3","C3"],["C3","P3"],["P3","O1"],
  ["Fp2","F4"],["F4","C4"],["C4","P4"],["P4","O2"],
  ["Fz","Cz"],["Cz","Pz"]
];
const TRANSVERSE_CHAINS = [
  ["F7","Fp1"],["Fp1","Fp2"],["Fp2","F8"],

  ["F7","F3"],["F3","Fz"],["Fz","F4"],["F4","F8"],

  ["T3","C3"],["C3","Cz"],["Cz","C4"],["C4","T4"],

  ["T5","P3"],["P3","Pz"],["Pz","P4"],["P4","T6"],

  ["T5","O1"],["O1","O2"],["O2","T6"]
];

/***********************
 * Seeded RNG
 ***********************/
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return ()=>{h=Math.imul(h^ (h>>>16),2246822507);h=Math.imul(h^ (h>>>13),3266489909);h^=h>>>16;return h>>>0;};}
function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^b>>>9;b=c+(c<<3)|0;c=(c<<21|c>>>11);c=c+t|0;return (t>>>0)/4294967296;};}
function makeRNG(seedStr){ const seed = xmur3(seedStr); return sfc32(seed(),seed(),seed(),seed()); }

/***********************
 * Signal Model
 ***********************/
const Fs = 256;
const BLINK_DUR = 0.35;      // s
const EMG_PWR = 0.25;


// ---- GPD (Generalized Periodic Discharges) helper (tuned) ----
// Returns a triphasic-like generalized discharge at ~1 Hz.
// Morphology: brief sharp component, brief polarity reversal, followed by a slow wave.
// Frequency: ~1/sec (fixed period 1.0s with mild phase dither to avoid perfect metronome).
function gpdWave(clock, rng){
  const basePeriod = 1.0;                    // 1 Hz nominal
  const dither = 0.04 * Math.sin(0.15*clock); // gentle ±40 ms drift over time
  const period = basePeriod + dither;
  const phase = (clock % period) / period;   // 0..1 within current cycle

  // Triphasic-ish composite using Gaussians in phase space
  // timings chosen to cluster within ~250–300 ms total complex
  const g = (mu, sigma, sign=1)=> sign*Math.exp(-0.5*((phase-mu)/sigma)**2);

  // Components: sharp negative, brief positive, slower negative
  const c1 = g(0.03, 0.010, -1.0);  // ~30 ms negative sharp
  const c2 = g(0.07, 0.015, +0.7);  // brief positive reversal
  const c3 = g(0.16, 0.060, -0.5);  // slower negative/slow wave

  // Envelope gate—keep energy mostly in first 300 ms of the second
  const gate = phase < 0.35 ? 1.0 : 0.0;

  // Scale to microvolt range appropriate for display at typical sensitivities
  const amplitude_uV = 120; // ~120 µV peak features
  return gate * amplitude_uV * (c1 + c2 + c3);
}

// Electrode-wise amplitude scaling (frontally predominant) and tiny propagation lags
function gpdScale(e){
  // Slight frontopolar/frontal predominance, midline > parasagittal > temporal > occipital
  if (/^(Fp|Fz|F[34])/.test(e)) return 1.0;
  if (/^(Cz|C[34]|F7|F8)/.test(e)) return 0.85;
  if (/^(Pz|P[34]|T3|T4|T5|T6)/.test(e)) return 0.70;
  if (/^(O1|O2)/.test(e)) return 0.55;
  return 0.75;
}
function gpdLag(e){
  // Millisecond-scale delays to avoid perfect common-mode cancellation in bipolar
  let base = 0.0;
  if (/^(P|O)/.test(e)) base += 0.010; // 10 ms posterior delay
  if (/[2|4|8|6]$/.test(e)) base += 0.003; // slight right-hemisphere delay (~3 ms)
  if (/z$/.test(e)) base -= 0.002; // midline slightly earlier
  return base; // seconds
}
// ---- LPDs (Lateralized Periodic Discharges) helpers ----
// Default focus: LEFT temporal-predominant (F7/T3/T5) with spread to ipsilateral frontal/parietal.
function lpdWave(clock, rng){
  const basePeriod = 1.0; // ~1 Hz
  const dither = 0.03 * Math.sin(0.2*clock);
  const period = basePeriod + dither;
  const phase = (clock % period) / period;
  const g = (mu, sigma, sign=1)=> sign*Math.exp(-0.5*((phase-mu)/sigma)**2);
  // Biphasic/triphasic-like complex contained within ~250 ms
  const c1 = g(0.04, 0.012, -1.0);
  const c2 = g(0.09, 0.018, +0.7);
  const c3 = g(0.16, 0.050, -0.45);
  const gate = phase < 0.35 ? 1.0 : 0.0;
  const amplitude_uV = 140;
  return gate * amplitude_uV * (c1 + c2 + c3);
}
// Electrode scaling for LEFT-sided LPDs (temporal > frontal/parietal > occipital; contralateral small)
function lpdScaleLeft(e){
  if (/^(F7|T3|T5)$/.test(e)) return 1.0;
  if (/^(Fp1|F3|C3|P3)$/.test(e)) return 0.65;
  if (/^(O1)$/.test(e)) return 0.45;
  if (/^(Fz|Cz|Pz)$/.test(e)) return 0.30;  // midline small
  if (/^(F8|T4|T6|Fp2|F4|C4|P4|O2)$/.test(e)) return 0.18;  // contralateral
  return 0.25;
}
// Tiny delays to avoid bipolar cancellation, biased to temporal onset then spread
function lpdLagLeft(e){
  let lag = 0.0;
  if (/^(T3|F7)$/.test(e)) lag += 0.000;  // earliest
  if (/^(T5)$/.test(e)) lag += 0.006;
  if (/^(F3|C3)$/.test(e)) lag += 0.010;
  if (/^(P3)$/.test(e)) lag += 0.014;
  if (/^(O1)$/.test(e)) lag += 0.018;
  if (/^(Fz|Cz|Pz)$/.test(e)) lag += 0.012;
  if (/^(Fp1)$/.test(e)) lag += 0.008;
  if (/^(.*2|F4|C4|P4|O2)$/.test(e)) lag += 0.020; // right hemisphere latest
  return lag;
}
// Right-sided variants for BIPDs
function lpdScaleRight(e){
  if (/^(F8|T4|T6)$/.test(e)) return 1.0;
  if (/^(Fp2|F4|C4|P4)$/.test(e)) return 0.65;
  if (/^(O2)$/.test(e)) return 0.45;
  if (/^(Fz|Cz|Pz)$/.test(e)) return 0.30;
  if (/^(F7|T3|T5|Fp1|F3|C3|P3|O1)$/.test(e)) return 0.18;
  return 0.25;
}
function lpdLagRight(e){
  let lag = 0.0;
  if (/^(T4|F8)$/.test(e)) lag += 0.000;
  if (/^(T6)$/.test(e)) lag += 0.006;
  if (/^(F4|C4)$/.test(e)) lag += 0.010;
  if (/^(P4)$/.test(e)) lag += 0.014;
  if (/^(O2)$/.test(e)) lag += 0.018;
  if (/^(Fz|Cz|Pz)$/.test(e)) lag += 0.012;
  if (/^(Fp2)$/.test(e)) lag += 0.008;
  if (/^(.*1|F3|C3|P3|O1)$/.test(e)) lag += 0.020;
  return lag;
}




function region(e){
  if (/^O/.test(e)) return 'occipital';
  if (/^Fp/.test(e)) return 'frontal';
  if (/^(F7|F8|T3|T4|T5|T6)/.test(e)) return 'temporal';
  if (/^(P|C|Fz|Cz|Pz)/.test(e)) return 'central';
  return 'other';
}
function lowpass(prev, x, a){ return prev + a*(x - prev); }

class Channel {
  constructor(name, rng){
    this.name=name; this.rng=rng;
    this.phAlpha=this.rng()*Math.PI*2;
    this.phBeta =this.rng()*Math.PI*2;
    this.phTheta=this.rng()*Math.PI*2;
    this.phDelta=this.rng()*Math.PI*2;
    this.envA=0; this.envB=0; this.envT=0; this.envD=0;
    this.brown=0;
    this.alphaJitterBase=(this.rng()-0.5)*0.2;
  }
  sample(t, opts){
    const r = region(this.name);
    const R = (opts && typeof opts.realism==='number') ? opts.realism : 1;
    // Non-linear mapping: bottom half linear, top half quadratic for extra punch
    const Rnl = (R <= 0.5) ? R : (0.5 + 2*Math.pow(R-0.5, 2));
    const S3 = Math.max(0, Math.min(3*Rnl, 3));
    let A=8,B=6,T=6,D=3;
    switch(opts.mode){
      case 'alpha': case 'awake':
        if (r==='occipital') A = (opts.eyesOpen? 6: 40); else if (r==='central') A = 10; else if (r==='frontal') A = 6; else A = 8;
        B = (r==='frontal') ? 8 : 6; T = (r==='temporal') ? 7 : 5; D = 3; break;
      case 'beta':
        B = (r==='frontal')? 14 : 10; A = (r==='occipital') ? (opts.eyesOpen?5:12) : 6; T=6; D=3; break;
      case 'theta': case 'drowsy':
        T = (r==='temporal'||r==='central'||opts.mode==='theta') ? 15 : 10; 
        A = (r==='occipital') ? (opts.eyesOpen?4:12) : 6; B=6; D=4; break;
      case 'delta':
        D = (r==='frontal'||r==='central') ? 20 : 12; T=8; A=6; B=4; break;
      case 'n1':
        T = (r==='central') ? 16 : 12; A=6; B=6; D=5; break;
      case 'n2':
        T = (r==='central') ? 14 : 10; A=6; B=7; D=6; break;
      case 'rem':
        T = 12; B = 8; A = 5; D = 4; break;
      case 'sws':
        D = 35; T=6; A=4; B=3; break;
    }
    this.envA = lowpass(this.envA, (this.rng()-0.5)*2*S3, 0.002);
    this.envB = lowpass(this.envB, (this.rng()-0.5)*2*S3, 0.004);
    this.envT = lowpass(this.envT, (this.rng()-0.5)*2*S3, 0.003);
    this.envD = lowpass(this.envD, (this.rng()-0.5)*2*S3, 0.0015);
    const fAlpha = ((opts.mode==='alpha' || opts.mode==='awake') && r==='occipital') ? opts.pdrHz : 8 + this.rng()*4;
    const fBeta  = 18 + (this.rng()*10*S3);
    const fTheta = 4.5 + (this.rng()*2.5*S3);
    const fDelta = 1.0 + (this.rng()*1.5*S3);
    this.phAlpha += 2*Math.PI*fAlpha/Fs;
    this.phBeta  += 2*Math.PI*fBeta /Fs;
    this.phTheta += 2*Math.PI*fTheta/Fs;
    this.phDelta += 2*Math.PI*fDelta/Fs;
    let y = 0;
    const alphaTerm = ((opts.mode==='alpha' || opts.mode==='awake') && r==='occipital')
      ? Math.sin(opts.pdrPhase + this.alphaJitterBase*S3)
      : Math.sin(this.phAlpha);
    y += (A*(1+0.6*this.envA)) * alphaTerm;
    y += (B*(1+0.6*this.envB)) * Math.sin(this.phBeta);
    y += (T*(1+0.6*this.envT)) * Math.sin(this.phTheta);
    y += (D*(1+0.6*this.envD)) * Math.sin(this.phDelta);
    if (opts.mode==='drowsy' && /^Fp|^F/.test(this.name)) y += 40*Math.sin(2*Math.PI*0.25*opts.clock);
    if (opts.mode==='rem' && /^Fp|^F/.test(this.name)) {
      const fREM = 0.8 + 0.4*Math.sin(0.2*opts.clock);
      const burst = (Math.sin(2*Math.PI*0.12*opts.clock)>0.7) ? 1 : 0;
      const saw = 2*(opts.clock*fREM - Math.floor(0.5 + opts.clock*fREM));
      y += burst * 35 * (saw);
    }
    if (opts.vertex && (this.name==='Cz' || this.name==='Fz')) y += opts.vertexShape * (this.name==='Cz' ? 120 : 60);
    if (opts.spindleEnv && /^(C3|C4|Cz)$/.test(this.name)) {
      const fSigma = 12 + 2*Math.sin(0.1*opts.clock);
      y += 25*opts.spindleEnv*Math.sin(2*Math.PI*fSigma*opts.clock);
    }
    if (opts.kcShape && /^(F3|F4|C3|C4|Cz|Fz)$/.test(this.name)) y += 120*opts.kcShape * (/(F|Fz)/.test(this.name)?1.0:0.8);
    const w = (this.rng()-0.5)*4.0*S3;
    this.brown = 0.98*this.brown + w;
    const pinkish = 0.9*this.brown + 0.1*w;
    y += pinkish;
    if (opts.blinkShape && /^Fp|^F[34]$/.test(this.name)) y += (60 + 160*R)*opts.blinkShape;
    if (opts.chewWave && /^(T3|T4|T5|T6)$/.test(this.name)) y += (10 + 60*R)*opts.chewWave;
    if (opts.sweatOffset && /^(Fp|F|C)/.test(this.name)) y += (5 + 45*R)*opts.sweatOffset;
    if (opts.pop && this.rng()<0.0005) y += 200*(this.rng()-0.5);
    if (opts.emg && /^(F7|F8|T3|T4|T5|T6)$/.test(this.name)){
      const hf = 30 + this.rng()*40;
      y += (EMG_PWR*(0.5+S3))*20*Math.sin(2*Math.PI*hf*opts.clock + 6*this.rng());
    }
    return y;
  }
}

/***********************
 * Engine state
 ***********************/
const state = {
  rng: makeRNG("EEG-1001"),
  channels: new Map(),
  buffer: new Map(),
  idx: 0,
  seconds: 10,
  uvPerDiv: 70,
  running: true,
  realism: 0.75,
  speed: 1,
  opts: {blink:false, chew:false, sweat:false, pop:false, emg:false},
  pathology: {gpd:false, lpd:false},
  montage: 'bipolar_longitudinal',
  mode: 'awake',
  eyesOpen: false,
  pdrHz: 10.5,
  pdrPhase: 0,
  artClock: 0,
  spindle: {active:false, t0:0, dur:0.0},
  kcomplex: {active:false, t0:0},
  vertex: {active:false, t0:0}
};

function initChannels(){
  state.channels.clear(); state.buffer.clear();
  ELECTRODES.forEach(e=>{
    state.channels.set(e, new Channel(e, state.rng));
    state.buffer.set(e, new Float32Array(Fs*state.seconds));
  });
  // Synthetic buffer for average reference
  state.buffer.set("AVG", new Float32Array(Fs*state.seconds));
  state.idx = 0;
}

/***********************
 * Montage helpers
 ***********************/
function leftHem(e){ return /^(Fp1|F3|C3|P3|O1|F7|T3|T5|A1|Fz|Cz|Pz)$/.test(e); }
function avgElectrodes(){
  // Use DISPLAY_ORDER as scalp set; excludes A1/A2 and Oz.
  return DISPLAY_ORDER.slice();
}

function transverseBreaks(){
  // Visual cluster breaks after lines 3, 7, 11, 15
  return new Set([3,7,11,15]);
}

function montagePairs(){
  const arr=[];
  if (state.montage==='referential'){
    for (const e of DISPLAY_ORDER){ const ref=leftHem(e)?'A1':'A2'; arr.push({a:e,b:ref,label:`${e}-${ref}`}); }
  } else if (state.montage==='bipolar_transverse'){
    // Exact transverse layout per spec with vertical cluster gaps handled elsewhere
    const lines = [
      ["F7","Fp1"],["Fp1","Fp2"],["Fp2","F8"],
      ["F7","F3"],["F3","Fz"],["Fz","F4"],["F4","F8"],
      ["T3","C3"],["C3","Cz"],["Cz","C4"],["C4","T4"],
      ["T5","P3"],["P3","Pz"],["Pz","P4"],["P4","T6"],
      ["T5","O1"],["O1","O2"],["O2","T6"]
    ];
    for (const [a,b] of lines){ arr.push({a,b,label:`${a}-${b}`}); }
  } else if (state.montage==='average'){
    for (const e of AVERAGE_ORDER){ arr.push({a:e,b:'AVG',label:`${e} - AVG`}); }
  } else {
    for (const [a,b] of LONGITUDINAL_CHAINS){ arr.push({a,b,label:`${a}-${b}`}); }
  }
  return arr;
}

/***********************
 * Renderer
 ***********************/
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const errBox=document.getElementById('err');

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio||1);
  canvas.width = Math.floor(canvas.clientWidth * dpr);
  canvas.height = Math.floor(canvas.clientHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize); resize();

function drawGrid(rows, secs){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg');
  ctx.fillRect(0,0,w,h);
  const pxPerSec = w / secs;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-minor');
  for (let s=0; s<secs*5; s++){ const x=Math.round(s*(pxPerSec/5))+0.5; ctx.moveTo(x,0); ctx.lineTo(x,h); }
  ctx.stroke();
  ctx.beginPath();
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-major');
  for (let s=0; s<=secs; s++){ const x=Math.round(s*pxPerSec)+0.5; ctx.moveTo(x,0); ctx.lineTo(x,h); }
  ctx.stroke();
  ctx.restore();
}

function groupColor(index){
  const red=getComputedStyle(document.documentElement).getPropertyValue('--trace-red');
  const blue=getComputedStyle(document.documentElement).getPropertyValue('--trace-blue');
  const black=getComputedStyle(document.documentElement).getPropertyValue('--trace-black');
  const label=montagePairs()[index]?.label||"";
  if (/^(Fz-Cz|Cz-Pz)$/.test(label)) return black;
  if (state.montage==='bipolar_longitudinal') return (Math.floor(index/4)%2===1)?red:blue;
  if (state.montage==='bipolar_transverse'){
    const redSet = new Set(['F3-Fz','Fz-F4','C3-Cz','Cz-C4','P3-Pz','Pz-P4']);
    return redSet.has(label) ? red : black;
  }
  return '#333';
}

function computeRowMids(count){
  // Reserve vertical padding so top channels (e.g., Fp1–F7) never get cut off near the toolbar.
  // Use responsive padding with sensible minimums.
  const h = canvas.clientHeight;
  const topPad = Math.max(56, Math.floor(h*0.07));
  const bottomPad = Math.max(32, Math.floor(h*0.05));
  const isTrans = (state.montage==='bipolar_transverse');
// Apply row gaps for longitudinal, transverse, and average
const useGaps = (state.montage==='bipolar_longitudinal' || isTrans || state.montage==='average');
const defaultGap = 10; // uniform gap size like longitudinal
const extraBreaks = isTrans ? transverseBreaks() : (state.montage==='average' ? new Set([4,8,12,16]) : new Set([4,8,12]));
const extraFactor = 2.2; // same prominence as longitudinal
  let totalExtra = 0;
  for (let i=0;i<count;i++){
    if (!useGaps) continue;
    let extra = 0;
    if (i>0 && i%4===0) extra += defaultGap;
    if (extraBreaks.has(i)) extra += defaultGap*(extraFactor-1);
    totalExtra += extra;
  }
  const base = (h - topPad - bottomPad - totalExtra) / count;
  const y = []; let acc = 0;
  for (let i=0;i<count;i++){
    let extra = 0;
    if (useGaps){ if (!isTrans && i>0 && i%4===0) extra += defaultGap; if (extraBreaks.has(i)) extra += defaultGap*(extraFactor-1); }
    acc += extra;
    const rowTop = topPad + i*base + acc;
    y.push(rowTop + base/2);
  }
  return y;
}

function renderLabels(pairs, yMids, colorAtIndex){
  if (!pairs.length) return;
  const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg');
  ctx.textBaseline = 'middle';
  for (let i=0;i<pairs.length;i++){
    const label = pairs[i].label;
    const isMid = /^(Fz-Cz|Cz-Pz)$/.test(label);
    const font = isMid ? 'bold 12px system-ui,Segoe UI,Roboto,Arial' : '12px system-ui,Segoe UI,Roboto,Arial';
    ctx.font = font;
    const xText = 8;
    const y = yMids[i];
    const metrics = ctx.measureText(label);
    const textW = Math.ceil(metrics.width);
    const ascent = metrics.actualBoundingBoxAscent || 9;
    const descent = metrics.actualBoundingBoxDescent || 3;
    const textH = ascent + descent;
    const padX = 4, padY = 2;
    const rectX = xText - padX;
    const rectY = y - textH/2 - padY;
    const rectW = textW + 2*padX;
    const rectH = textH + 2*padY;
    // Background highlight
    ctx.save();
    ctx.fillStyle = bg;
    ctx.fillRect(rectX, rectY, rectW, rectH);
    ctx.restore();
    // Text
    ctx.fillStyle = colorAtIndex(i);
    ctx.fillText(label, xText, y);
  }
}

/***********************
 * Timebase mapping
 ***********************/
function secondsFromTimebase(mmps){
  const v=parseInt(mmps,10);
  if (v===15) return 20;
  if (v===30) return 10;
  if (v===60) return 5;
  return 10;
}

/***********************
 * Sleep event helpers
 ***********************/
function spindleEnvelope(t, t0, dur){ const x=(t-t0)/dur; if(x<0||x>1) return 0; return Math.sin(Math.PI*x)**2; }
function kComplexShape(t, t0){ const x=t-t0; if(x<-0.1||x>1.0) return 0; const neg=x>=0&&x<=0.2?-Math.sin(Math.PI*(x/0.2)):0; const pos=(x>0.2&&x<=0.8)?Math.sin(Math.PI*((x-0.2)/0.6)):0; return neg+0.6*pos; }
function vertexShape(t, t0){ const x=t-t0; if(x<0||x>0.15) return 0; return -Math.sin(Math.PI*(x/0.15)); }

/***********************
 * Main loop
 ***********************/
let lastT=performance.now()/1000;
function step(){
  try{
    if(state.running){
      const now=performance.now()/1000; const dt=Math.min(0.05, now-lastT); lastT=now;
      const samples=Math.max(1, Math.floor(dt*Fs*state.speed));
      for(let n=0;n<samples;n++){
        state.pdrPhase += 2*Math.PI*state.pdrHz/Fs;
        if(state.mode==='n2' && !state.spindle.active && Math.random()<0.02){ state.spindle.active=true; state.spindle.t0=state.artClock+Math.random()*0.5; state.spindle.dur=0.5+Math.random()*1.2; }
        if(state.mode==='n2' && !state.kcomplex.active && Math.random()<0.005){ state.kcomplex.active=true; state.kcomplex.t0=state.artClock+Math.random()*0.3; }
        if(state.mode==='n1' && !state.vertex.active && Math.random()<0.01){ state.vertex.active=true; state.vertex.t0=state.artClock+Math.random()*0.2; }
        if(state.spindle.active && state.artClock>state.spindle.t0+state.spindle.dur) state.spindle.active=false;
        if(state.kcomplex.active && state.artClock>state.kcomplex.t0+1.0) state.kcomplex.active=false;
        if(state.vertex.active && state.artClock>state.vertex.t0+0.15) state.vertex.active=false;
        const blinkT=state.artClock%1; let blinkShape=0;
        if(state.opts.blink && blinkT<BLINK_DUR){ const u=blinkT/BLINK_DUR; blinkShape=Math.sin(Math.PI*u); }
        const chewWave=state.opts.chew?Math.sin(2*Math.PI*3*state.artClock):0;
        const sweatOffset=state.opts.sweat?Math.sin(2*Math.PI*0.2*state.artClock):0;
        const opts={
          mode:state.mode, eyesOpen:state.eyesOpen,
          blinkShape,chewWave,sweatOffset,
          pop:state.opts.pop, emg:state.opts.emg,
          pdrPhase:state.pdrPhase, pdrHz:state.pdrHz,
          clock:state.artClock,
          spindleEnv:state.spindle.active?spindleEnvelope(state.artClock,state.spindle.t0,state.spindle.dur):0,
          kcShape:state.kcomplex.active?kComplexShape(state.artClock,state.kcomplex.t0):0,
          vertex:state.vertex.active, vertexShape:state.vertex.active?vertexShape(state.artClock,state.vertex.t0):0
        };
        const t=(state.idx%Fs)/Fs;
        let sum=0, cnt=0;
        for(const e of ELECTRODES){
          const ch=state.channels.get(e);
          const y0=ch.sample(t+n/Fs, opts);
          let y = y0;
          if (state.pathology && state.pathology.gpd) {
            y += gpdWave(state.artClock + n/Fs + gpdLag(e), state.rng) * gpdScale(e);
          }
          if (state.pathology && state.pathology.lpd) {
            y += lpdWave(state.artClock + n/Fs + lpdLagLeft(e), state.rng) * lpdScaleLeft(e);
          }

          if (state.pathology && state.pathology.bipds) {
            // Add independent right-sided LPD as well
            y += lpdWave(state.artClock + 0.31 + n/Fs + lpdLagRight(e), state.rng) * lpdScaleRight(e);
          }
          // Apply quiz amplitude biases
          if (state.quiz && state.quiz.active && state.quiz.bias){
            const L = /^(Fp1|F3|C3|P3|O1|F7|T3|T5|Fz|Cz|Pz)$/.test(e);
            let hemiScale = 1;
            if (state.quiz.bias.leftScale!==1 && L) hemiScale = state.quiz.bias.leftScale;
            if (state.quiz.bias.rightScale!==1 && !L) hemiScale = state.quiz.bias.rightScale;
            const focalScale = (state.quiz.bias.focal[e]!==undefined) ? state.quiz.bias.focal[e] : 1;
            y *= hemiScale * focalScale;
          }
          const buf=state.buffer.get(e);
          buf[state.idx%buf.length]=y;
          // contribute to AVG if scalp electrode (exclude ears and Oz)
          if (avgElectrodes().includes(e)) { sum+=y; cnt++; }
        }
        const avg = cnt? (sum/cnt) : 0;
        const avgBuf = state.buffer.get("AVG");
        avgBuf[state.idx%avgBuf.length] = avg;
        state.idx++; state.artClock+=1/Fs;
      }
    }
    const pairs=montagePairs(); drawGrid(pairs.length, state.seconds);
    const w=canvas.clientWidth; const pxPerSec=w/state.seconds; const yMids=computeRowMids(pairs.length);
    for(let i=0;i<pairs.length;i++){
      const {a,b}=pairs[i]; const ra=state.buffer.get(a); const rb=state.buffer.get(b); if(!ra||!rb) continue;
      const yMid=yMids[i]; ctx.beginPath(); ctx.strokeStyle=groupColor(i); ctx.lineWidth=1.2;
      for(let x=0;x<w;x++){ const secAgo=(w-x)/pxPerSec; const idx=(state.idx-Math.floor(secAgo*Fs)); const len=ra.length; const j=((idx%len)+len)%len; const uv=ra[j]-rb[j]; const rowH=(canvas.clientHeight/pairs.length); const y=yMid-(uv/state.uvPerDiv)*(rowH/4); if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke();
    }
    renderLabels(pairs, yMids, groupColor); errBox.style.display='none';
  }catch(e){ console.error(e); errBox.textContent='Render error: '+e.message; errBox.style.display='block'; }
  requestAnimationFrame(step);
}

/***********************
 * UI wiring
 ***********************/
const $=id=>document.getElementById(id);
function uvPerDivFromSensitivity(uVperMM){ return (parseFloat(uVperMM)||7)*10; }
function secondsFromUI(){ const tb=$('timebase'); return tb?secondsFromTimebase(tb.value):10; }
function regen(){
  state.seconds=secondsFromUI(); const sensEl=$('sensitivity'); if(sensEl) state.uvPerDiv=uvPerDivFromSensitivity(sensEl.value);
  state.opts={ blink:$('blink')?.checked||false, chew:$('chew')?.checked||false, sweat:$('sweat')?.checked||false, pop:$('pop')?.checked||false, emg:$('emg')?.checked||false };
  state.montage=$('montageSel')?$('montageSel').value:state.montage;
  state.pdrHz=10+(Math.random()*1); state.pdrPhase=0; state.artClock=0; initChannels();
}
function updateEyesOpenEnabled(){
  const dis=(state.mode==='n1'||state.mode==='n2'||state.mode==='sws'||state.mode==='rem');
  const chk=$('eyesOpen'); if(!chk) return; chk.disabled=dis; if(dis) chk.checked=false; state.eyesOpen=chk.checked;
}
if($('play')) $('play').addEventListener('click',()=>{ state.running=!state.running; $('play').textContent=state.running?'Pause':'Play'; });
if($('montageSel')) $('montageSel').addEventListener('change',()=>{ state.montage=$('montageSel').value; });
document.querySelectorAll('#modeRadios input[name="mode"]').forEach(el=>{
  el.addEventListener('change',()=>{ if(el.checked){ state.mode=el.value; updateEyesOpenEnabled(); }});
});
if($('eyesOpen')) $('eyesOpen').addEventListener('change',()=>{ state.eyesOpen=$('eyesOpen').checked; });
const optBtn = $('optionsBtn');
const optionsModal = document.getElementById('optionsModal');

// Playback speed slider wiring
const speedSlider = $('speedSlider');
const speedValue = $('speedValue');
if (speedSlider && speedValue) {
  speedSlider.value = String(state.speed || 1);
  speedValue.textContent = (Number(speedSlider.value)).toFixed(2) + '×';
  speedSlider.addEventListener('input', () => {
    const v = Math.max(0.25, Math.min(5, Number(speedSlider.value)));
    state.speed = v || 1;
    speedValue.textContent = v.toFixed(2) + '×';
  });
}

const optionsClose = document.getElementById('optionsClose');
if (optBtn && optionsModal) {
  const openOptions = () => { optionsModal.hidden = false; };
  const closeOptions = () => { optionsModal.hidden = true; };
  optBtn.addEventListener('click', (e) => { e.stopPropagation(); openOptions(); });
  optionsClose?.addEventListener('click', closeOptions);
  optionsModal.addEventListener('click', (e) => { if (e.target === optionsModal) closeOptions(); });
  document.addEventListener('keydown', (e) => { if (!optionsModal.hidden && e.key === 'Escape') closeOptions(); });
  optionsModal.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.addEventListener('change', () => { regen(); }));
}
if($('timebase')) $('timebase').addEventListener('change',()=>{ state.seconds=secondsFromTimebase($('timebase').value); initChannels(); });
if($('sensitivity')) $('sensitivity').addEventListener('change',()=>{ state.uvPerDiv=uvPerDivFromSensitivity($('sensitivity').value); });

/* Intro modal */
(function(){ const modal=document.getElementById('introModal'); const closeBtn=document.getElementById('introClose'); function close(){ modal.setAttribute('hidden',''); } if(closeBtn) closeBtn.addEventListener('click', close); if(modal) modal.addEventListener('click',(e)=>{ if(e.target===modal) close(); }); document.addEventListener('keydown',(e)=>{ if(e.key==='Escape') close(); }); })();

/***********************
 * Self-tests & boot
 ***********************/
function selfTests(){
  const prev=state.montage;
  state.montage='referential'; console.assert(montagePairs().length===DISPLAY_ORDER.length,'ref count');
  state.montage='bipolar_longitudinal'; console.assert(montagePairs().length===LONGITUDINAL_CHAINS.length,'long count');
  state.montage='bipolar_transverse'; console.assert(montagePairs().length===TRANSVERSE_CHAINS.length,'trans count');
  state.montage=prev;
}
selfTests();
const tbEl=document.getElementById('timebase'); if(tbEl) state.seconds=secondsFromTimebase(tbEl.value);
const seEl=document.getElementById('sensitivity'); if(seEl) state.uvPerDiv=uvPerDivFromSensitivity(seEl.value);
resize();
// Ensure default eyes-open on first load
const eoEl = document.getElementById('eyesOpen');
if (eoEl) { eoEl.checked = true; state.eyesOpen = true; }
regen();
updateEyesOpenEnabled();
requestAnimationFrame(step);


// Pathology modal wiring
const pathologyBtn = $('pathologyBtn');
const pathologyModal = document.getElementById('pathologyModal');
const pathologyClose = document.getElementById('pathologyClose');
const gpdBox = $('gpd');
const lpdBox = $('lpd');
if (pathologyBtn && pathologyModal) pathologyBtn.addEventListener('click', ()=>{ pathologyModal.hidden = false; });
if (pathologyClose) pathologyClose.addEventListener('click', ()=>{ pathologyModal.hidden = true; });
if (pathologyModal) {
  pathologyModal.addEventListener('click', (e)=>{ if(e.target===pathologyModal) pathologyModal.hidden = true; });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && !pathologyModal.hidden) pathologyModal.hidden = true; });
}
if (gpdBox) {
  gpdBox.checked = !!(state.pathology && state.pathology.gpd);
  gpdBox.addEventListener('change', ()=>{ state.pathology.gpd = gpdBox.checked; });
}
if (lpdBox) {
  lpdBox.checked = !!(state.pathology && state.pathology.lpd);
  lpdBox.addEventListener('change', ()=>{ state.pathology.lpd = lpdBox.checked; });
}


// Realism slider wiring
const realismSlider = $('realismSlider');
const realismValue = $('realismValue');
if (realismSlider && realismValue) {
  realismSlider.value = String(state.realism);
  realismValue.textContent = Math.round(Number(realismSlider.value)*100) + '%';
  realismSlider.addEventListener('input', () => {
    const v = Math.max(0, Math.min(1, Number(realismSlider.value)));
    state.realism = v;
    realismValue.textContent = Math.round(v*100) + '%';
  });
}



// ---------------- Quiz Mode ----------------
state.quiz = {
  active:false,
  stepIndex:0,
  truth:{},
  answered:{},
  order:[]
};

function randChoice(rng, arr){ return arr[Math.floor(rng()*arr.length)] }

const QUIZ_SPEC_BASE = [
  {key:'background',   label:'Background rhythm',        options:['delta','theta','alpha','beta']},
  {key:'artifact',     label:'Artifact',                 options:['None','Eye blinks','Chewing','Sweat','EMG']},
  {key:'symmetry',     label:'Symmetry',                 options:['symmetric','asymmetric']},
  {key:'amplitude',    label:'Amplitude pattern',        options:['Normal','diffuse attenuation','focal attenuation']},
  {group:'Slowing',    parts:[
      {key:'slowingDist',  label:'', options:['None','Generalized','Focal - Left','Focal - Right']},
      {key:'slowingTempo', label:'', options:['No slowing','intermittent','continuous']}
  ]},
  {key:'periodic',     label:'Periodic / Rhythmic',      options:['None','GPDs','LPDs','BIPDs']},
  {key:'sleep',        label:'Sleep',                    options:['Awake','Drowsy','Stage 1','Stage 2','SWS','REM']},
  {key:'epileptiform', label:'Epileptiform discharges',  options:['none','generalized','focal']}
];

function startQuiz(){
  const rng = state.rng;

  // Reset quiz state
  state.quiz.active   = true;
  state.quiz.stepIndex= 0;
  state.quiz.answered = {};
  state.quiz.bias     = {leftScale:1,rightScale:1,focal:{}};
  state.quiz.slowing  = {};
  state.quiz.spikes   = {};

  // Random ground truth
  const background = randChoice(rng, ['delta','theta','alpha','beta']);
  const sleep      = randChoice(rng, ['Awake','Drowsy','Stage 1','Stage 2','SWS','REM']);
  const artifact   = (rng()<0.25) ? randChoice(rng, ['Eye blinks','Chewing','Sweat','EMG']) : 'None';
  const symmetry   = randChoice(rng, ['symmetric','asymmetric']);
  const amplitude  = randChoice(rng, ['diffuse attenuation','focal attenuation']);
  const slowScope  = randChoice(rng, ['Generalized','Focal']);
  const slowTempo  = randChoice(rng, ['intermittent','continuous']);
  const periodic   = randChoice(rng, ['None','GPDs','LPDs','BIPDs']);
  const epileptiform = randChoice(rng, ['none','generalized','focal']);

  let spindles='absent', kcomplexes='absent';
  if (sleep==='Stage 2'){
    spindles   = rng()<0.7 ? 'present' : 'absent';
    kcomplexes = rng()<0.7 ? 'present' : 'absent';
  }

  state.quiz.truth = {
    background, artifact, symmetry, amplitude,
    slowingDist: (rng()<0.33 ? 'None' : (rng()<0.5 ? 'Generalized' : (rng()<0.5 ? 'Focal - Left' : 'Focal - Right'))),
    slowingTempo: (rng()<0.5 ? 'Intermittent' : 'Continuous'),
    periodic, sleep, spindles, kcomplexes, epileptiform
  };

  // Drive the simulator to match truth
  state.mode = ({
    'Stage 1':'n1','Stage 2':'n2','SWS':'sws','REM':'rem',
    'Awake':'awake','Drowsy':'drowsy'
  })[sleep] || 'awake';

  state.pathology.gpd   = (periodic==='GPDs');
  state.pathology.lpd   = (periodic==='LPDs' || periodic==='BIPDs');
  state.pathology.bipds = (periodic==='BIPDs');

  state.opts = state.opts || {};
  state.opts.blink = (artifact==='Eye blinks');
  state.opts.chew  = (artifact==='Chewing');
  state.opts.sweat = (artifact==='Sweat');
  state.opts.pop   = false;
  state.opts.emg   = (artifact==='EMG');

  if (symmetry==='asymmetric'){
    const bias = 0.7 + 0.25*rng();
    if (rng()<0.5){ state.quiz.bias.leftScale=bias; } else { state.quiz.bias.rightScale=bias; }
  }
  if (amplitude==='focal attenuation'){
    const target = randChoice(rng, ['F7','T3','T5','F8','T4','T6','F3','C3','P3','F4','C4','P4','O1','O2']);
    state.quiz.bias.focal[target]=0.55;
  }

  // --- Build the ordered spec the UI renderer consumes ---
  state.quiz.order = [...QUIZ_SPEC_BASE];

  // If stage 2, append N2 sub-steps
  if (sleep==='Stage 2'){
    state.quiz.order.push(
      {key:'spindles',   label:'N2: sleep spindles', options:['present','absent']},
      {key:'kcomplexes', label:'N2: K-complexes',    options:['present','absent']}
    );
  }

  // Render UI
  buildQuizUI();

  // Show panel & hide rhythm radio row
  const panel = document.getElementById('quizPanel');
  if (panel){ panel.style.display='block'; panel.style.zIndex='9999'; }
  const rf = document.getElementById('rhythmFieldset');
  if (rf) rf.style.display='none';

  // Close the pathology modal if open and regenerate signals
  const pm = document.getElementById('pathologyModal');
  if (pm) pm.hidden = true;
  regen();
}

function buildQuizUI(){
  const stepsEl = document.getElementById('quizSteps');
  if (!stepsEl) return;
  stepsEl.innerHTML = '';

  state.quiz.order.forEach((step)=>{
    // Grouped "Slowing" with two sub-rows
    if (step.group && Array.isArray(step.parts)){
      const container = document.createElement('div');
      container.className = 'quiz-step';

      const header = document.createElement('div');
      header.textContent = step.group;
      container.appendChild(header);

      step.parts.forEach((row, rIndex)=>{
        const rowWrap = document.createElement('div');
        rowWrap.className = 'quiz-subrow';
        row.options.forEach(opt=>{
          const b = document.createElement('button');
          b.className='quiz-pill';
          b.textContent = opt;
          b.addEventListener('click', ()=> onAnswer(row.key, opt, b));
          rowWrap.appendChild(b);
        });
        container.appendChild(rowWrap);
      });

      stepsEl.appendChild(container);
      return;
    }

    // Standard single-row step
    const s = document.createElement('div');
    s.className='quiz-step';

    const h = document.createElement('div');
    h.textContent = step.label;
    s.appendChild(h);

    const pills = document.createElement('div');
    pills.className='quiz-pills';

    step.options.forEach(opt=>{
      const b = document.createElement('button');
      b.className='quiz-pill';
      b.textContent = opt;
      b.addEventListener('click', ()=> onAnswer(step.key, opt, b));
      pills.appendChild(b);
    });

    s.appendChild(pills);
    stepsEl.appendChild(s);
  });
}

function onAnswer(key, val, btn){
  // toggle active visual
  Array.from(btn.parentElement.children).forEach(el=>el.classList.remove('active'));
  btn.classList.add('active');

  // grade
  const truth = (state.quiz.truth[key] ?? '').toString();
  const isCorrect =
    (val === truth) ||
    (key==='spindles'   && val.toLowerCase() === truth.toLowerCase()) ||
    (key==='kcomplexes' && val.toLowerCase() === truth.toLowerCase());

  btn.classList.add(isCorrect ? 'correct' : 'wrong');
  state.quiz.answered[key] = isCorrect;

  checkWin();
}

function checkWin(){
  const allAnswered = state.quiz.order.every(s => s.key in state.quiz.answered);
  if (!allAnswered) return;

  const allCorrect  = state.quiz.order.every(s => state.quiz.answered[s.key] === true);
  const banner = document.getElementById('quizBanner');

  if (banner){
    banner.textContent = allCorrect ? '✔ Correct! New quiz ready.' : '✖ Not quite — answer all correctly.';
    banner.style.display='block';
    setTimeout(()=>{ banner.style.display='none'; if (allCorrect) startQuiz(); }, 1600);
  }
}

const _qn = document.getElementById('quizNew'); if (_qn){ _qn.innerText = 'New Case'; _qn.addEventListener('click', ()=> startQuiz()); }

// Pathology modal buttons are already wired above
</script>
</body>
</html>